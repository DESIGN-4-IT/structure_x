


i wanted to make canvas container more more responsive now only selected set no , phase no and attachment columns 
value drop into canvas container but user allows to assign any droped value to any small part of tower correctly 
i want all functionality that help user to assign any values to any part of 3d tower if user assign any value 
to specific part then we zoom that part then ralted values also zoom in and zoom out like all other functionality 
don't change other functioanlity modify code for canvas container  
give only modified code and give hint where to add we have large limit code so give only modified code 
this is hdata1.html 
"<div class="container">
    <h3>OVERHEAD LOAD DESIGN CRITERIA</h3>
    
    <div class="row">
        <!-- Left side - Selection Options (reduced width) -->
        <div class="col-md-4">
            {% if button_type == 'joint_labels' %}
            <!-- Show only joint labels section when joint labels button was clicked -->
            <div class="form-group">
                <label for="joint-labels">Attachment Joint Labels:</label>
                <div class="checkbox-list" id="joint-labels">
                    {% for label in joint_labels %}
                        <label draggable="true" class="drag-item" data-type="joint" data-value="{{ label }}">
                            <input type="checkbox" name="joint-labels" value="{{ label }}"> {{ label }}
                        </label>
                    {% endfor %}
                </div>
            </div>
            {% elif button_type == 'set_phase' %}
            <!-- Show only set/phase sections when set/phase button was clicked -->
            <div class="form-group">
                <label for="set-numbers">Set No.:</label>
                <div class="checkbox-list" id="set-numbers">
                    {% for num in set_numbers %}
                        <label draggable="true" class="drag-item" data-type="set" data-value="{{ num }}">
                            <input type="checkbox" name="set-numbers" value="{{ num }}"> {{ num }}
                        </label>
                    {% endfor %}
                </div>
            </div>
            
            <div class="form-group">
                <label for="phase-numbers">Phase No.:</label>
                <div class="checkbox-list" id="phase-numbers">
                    {% for num in phase_numbers %}
                        <label draggable="true" class="drag-item" data-type="phase" data-value="{{ num }}">
                            <input type="checkbox" name="phase-numbers" value="{{ num }}"> {{ num }}
                        </label>
                    {% endfor %}
                </div>
            </div>
            {% endif %}
        </div>
        
        <!-- Right side - 3D Model Viewer (increased width) -->
        <div class="col-md-8">
            <div class="model-viewer-container">
                <canvas id="model-canvas"></canvas>
                <div id="joint-markers-container"></div>
                <div id="set-markers-container"></div>
                <div id="phase-markers-container"></div>
                <div id="load-displays-container"></div>
            </div>
        </div>
    </div>
    
    <!-- Load Display Table - now placed below and full width -->
    <div id="load-display">
        <h5>Load Values</h5>
        <div class="btn-container">
            <button id="calculate-btn" class="calculation-btn" disabled>
                <span>Calculate Selected Records</span>
            </button>
            <span id="selected-count" class="selected-count">0 selected</span>
        </div>
        <div class="table-container">
            <table class="table table-bordered" id="load-table">
                <thead>
                    <tr>
                        <th>Select</th>
                        {% for column in all_columns %}
                            <th>{{ column }}</th>
                        {% endfor %}
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
    </div>
</div>



<!-- Include Three.js library -->
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>



<script>
    // Load data passed from Django
    const loadData = JSON.parse('{{ load_data_json|escapejs }}');
    
    // Three.js variables
    let scene, camera, renderer, model, controls;
    const jointMarkers = {};
    const selectedJoints = new Set();
    const loadDisplays = {};
    const setMarkers = {};
    const phaseMarkers = {};
    const selectedSets = new Set();
    const selectedPhases = new Set();
    let activeJoint = null;
    const selectedRecords = new Set();
    let allTableData = [];

    
    // Initialize the 3D model viewer
    function initModelViewer() {
        // Create scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);
        
        // Create camera
        camera = new THREE.PerspectiveCamera(75, 800 / 600, 0.1, 1000);
        camera.position.set(5, 5, 5);
        
        // Create renderer
        const canvas = document.getElementById('model-canvas');
        renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(canvas.parentElement.clientWidth, canvas.parentElement.clientHeight);
        
        // Add controls
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;
        
        // Add lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);
        
        // Load GLB model
        const loader = new THREE.GLTFLoader();
        loader.load(
            "{% static 'app1/images/tower3d.glb' %}",
            function (gltf) {
                model = gltf.scene;
                scene.add(model);
                
                // Center the model
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                model.position.sub(center);
                
                // Auto-rotate
                model.rotation.y = Math.PI / 4;
                
                // Start animation loop
                animate();
            },
            undefined,
            function (error) {
                console.error('Error loading model:', error);
            }
        );
        
        // Handle window resize
        window.addEventListener('resize', onWindowResize);
    }
    
    // Add a marker for a joint on the 3D model
    function addJointMarker(jointLabel) {
        if (jointMarkers[jointLabel]) return; // Already exists
        
        // Find the load data for this joint
        const jointLoadData = loadData.find(item => item['Attach. Joint Labels'] === jointLabel);
        if (!jointLoadData) return;
        
        // Create a marker (smaller and without red dot)
        const geometry = new THREE.SphereGeometry(0.02, 16, 16); // Much smaller
        const material = new THREE.MeshBasicMaterial({ color: 0x333333 });
        const sphere = new THREE.Mesh(geometry, material);
        
        // Position the marker (you'll need to adjust this based on your model)
        sphere.position.set(
            (Math.random() - 0.5) * 2,
            Math.random() * 2,
            (Math.random() - 0.5) * 2
        );
        
        // Add label (HTML overlay)
        const markerDiv = document.createElement('div');
        markerDiv.className = 'joint-marker';
        markerDiv.textContent = jointLabel;
        markerDiv.style.position = 'absolute';
        markerDiv.style.cursor = 'move';
        markerDiv.style.pointerEvents = 'auto';
        markerDiv.dataset.jointLabel = jointLabel;
        document.getElementById('joint-markers-container').appendChild(markerDiv);
        
        // Click handler for the marker
        markerDiv.addEventListener('click', function(e) {
            e.stopPropagation();
            toggleLoadDisplay(jointLabel);
        });
        
        // Store references
        jointMarkers[jointLabel] = {
            mesh: sphere,
            div: markerDiv,
            loadData: jointLoadData,
            isDragging: false,
            fontSize: 12 // Default font size
        };
        
        scene.add(sphere);
        updateMarkerPosition(sphere, markerDiv);
        
        // Make marker draggable
        makeJointDraggable(markerDiv, jointLabel);
    }
    

    
    // Toggle load display visibility
    function toggleLoadDisplay(jointLabel) {
        if (loadDisplays[jointLabel]) {
            // Hide if already showing
            removeLoadDisplay(jointLabel);
            activeJoint = null;
        } else {
            // Show if hidden
            addLoadDisplay(jointLabel, jointMarkers[jointLabel].mesh.position);
            activeJoint = jointLabel;
            
            // Hide any other active displays
            Object.keys(loadDisplays).forEach(label => {
                if (label !== jointLabel) {
                    removeLoadDisplay(label);
                }
            });
        }
    }
    
    // Make joint marker draggable
    function makeJointDraggable(element, jointLabel) {
        let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
        
        element.onmousedown = dragMouseDown;
        
        function dragMouseDown(e) {
            e.preventDefault();
            e.stopPropagation();
            
            jointMarkers[jointLabel].isDragging = true;
            
            // Get the mouse cursor position at startup
            pos3 = e.clientX;
            pos4 = e.clientY;
            
            document.onmouseup = closeDragElement;
            document.onmousemove = elementDrag;
        }
        
        function elementDrag(e) {
            e.preventDefault();
            e.stopPropagation();
            
            // Calculate the new cursor position
            pos1 = pos3 - e.clientX;
            pos2 = pos4 - e.clientY;
            pos3 = e.clientX;
            pos4 = e.clientY;
            
            // Set the element's new position
            element.style.top = (element.offsetTop - pos2) + "px";
            element.style.left = (element.offsetLeft - pos1) + "px";
            
            // Update the 3D position
            update3DPositionFromScreen(jointLabel, parseInt(element.style.left), parseInt(element.style.top));
            
            // Update load display position if visible
            if (loadDisplays[jointLabel]) {
                updateLoadDisplayPosition(
                    loadDisplays[jointLabel].div, 
                    jointMarkers[jointLabel].mesh.position
                );
            }
        }

    
    function closeDragElement() {
            jointMarkers[jointLabel].isDragging = false;
            // Stop moving when mouse button is released
            document.onmouseup = null;
            document.onmousemove = null;
        }
    }
    
    // Update 3D position from screen coordinates
    function update3DPositionFromScreen(jointLabel, x, y) {
        const vector = new THREE.Vector3(
            (x / renderer.domElement.clientWidth) * 2 - 1,
            -(y / renderer.domElement.clientHeight) * 2 + 1,
            0.5
        );
        
        vector.unproject(camera);
        jointMarkers[jointLabel].mesh.position.copy(vector);
    }
    
    // Add load display for a joint
    function addLoadDisplay(jointLabel, position) {
        if (loadDisplays[jointLabel]) return; // Already exists
        
        const jointInfo = jointMarkers[jointLabel];
        if (!jointInfo) return;
        
        const displayDiv = document.createElement('div');
        displayDiv.className = 'load-display';
        displayDiv.dataset.jointLabel = jointLabel;
        displayDiv.style.position = 'absolute';
        displayDiv.style.pointerEvents = 'auto';
        
        displayDiv.innerHTML = `
            <div class="load-display-header">
                <span>${jointLabel}</span>
                <span class="close-btn" title="Remove">×</span>
            </div>
            <div class="load-display-content">
                <div>Vert: <span class="editable" data-field="vert">${jointInfo.loadData['Structure Loads Vert. (lbs)'] || '0'}</span> lbs</div>
                <div>Trans: <span class="editable" data-field="trans">${jointInfo.loadData['Structure Loads Trans. (lbs)'] || '0'}</span> lbs</div>
                <div>Long: <span class="editable" data-field="long">${jointInfo.loadData['Structure Loads Long. (lbs)'] || '0'}</span> lbs</div>
            </div>
            <div class="size-controls">
                <div class="size-btn" data-action="increase">+</div>
                <div class="size-btn" data-action="decrease">-</div>
            </div>
        `;
        
        document.getElementById('load-displays-container').appendChild(displayDiv);
        
        // Position the display
        updateLoadDisplayPosition(displayDiv, position);
        
        // Store reference
        loadDisplays[jointLabel] = {
            div: displayDiv,
            position: position
        };
        
        // Add close button event
        displayDiv.querySelector('.close-btn').addEventListener('click', function(e) {
            e.stopPropagation();
            removeJointMarker(jointLabel);
            removeLoadDisplay(jointLabel);
            
            // Uncheck the checkbox
            const checkbox = document.querySelector(`input[value="${jointLabel}"]`);
            if (checkbox) {
                checkbox.checked = false;
                selectedJoints.delete(jointLabel);
                updateTable(Array.from(selectedJoints));
            }
        });
        
        // Add size control events
        displayDiv.querySelector('[data-action="increase"]').addEventListener('click', function(e) {
            e.stopPropagation();
            jointMarkers[jointLabel].fontSize = Math.min(24, jointMarkers[jointLabel].fontSize + 1);
            jointMarkers[jointLabel].div.style.fontSize = `${jointMarkers[jointLabel].fontSize}px`;
        });
        
        displayDiv.querySelector('[data-action="decrease"]').addEventListener('click', function(e) {
            e.stopPropagation();
            jointMarkers[jointLabel].fontSize = Math.max(8, jointMarkers[jointLabel].fontSize - 1);
            jointMarkers[jointLabel].div.style.fontSize = `${jointMarkers[jointLabel].fontSize}px`;
        });
        
        // Add editable fields (same as before)
        displayDiv.querySelectorAll('.editable').forEach(el => {
            el.addEventListener('click', function(e) {
                e.stopPropagation();
                const field = this.dataset.field;
                const currentValue = this.textContent;
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'value-edit';
                input.value = currentValue;
                
                this.textContent = '';
                this.appendChild(input);
                input.focus();
                
                input.addEventListener('blur', function() {
                    const newValue = parseFloat(this.value) || 0;
                    const parent = this.parentElement;
                    parent.textContent = newValue;
                    parent.classList.add('editable');
                    
                    // Update the data
                    const jointLabel = parent.closest('.load-display').dataset.jointLabel;
                    const jointInfo = jointMarkers[jointLabel];
                    if (jointInfo) {
                        if (field === 'vert') {
                            jointInfo.loadData['Structure Loads Vert. (lbs)'] = newValue;
                        } else if (field === 'trans') {
                            jointInfo.loadData['Structure Loads Trans. (lbs)'] = newValue;
                        } else if (field === 'long') {
                            jointInfo.loadData['Structure Loads Long. (lbs)'] = newValue;
                        }
                    }
                    
                    // Update the table
                    updateTable(Array.from(selectedJoints));
                });
                
                input.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        this.blur();
                    }
                });
            });
        });
        
        // Make the display draggable
        makeDraggable(displayDiv, jointLabel);
    }
    
    // Make load display draggable
    function makeDraggable(element, jointLabel) {
        let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
        
        element.onmousedown = dragMouseDown;
        
        function dragMouseDown(e) {
            e = e || window.event;
            e.preventDefault();
            
            // Get the mouse cursor position at startup
            pos3 = e.clientX;
            pos4 = e.clientY;
            
            document.onmouseup = closeDragElement;
            document.onmousemove = elementDrag;
        }
        
        function elementDrag(e) {
            e = e || window.event;
            e.preventDefault();
            
            // Calculate the new cursor position
            pos1 = pos3 - e.clientX;
            pos2 = pos4 - e.clientY;
            pos3 = e.clientX;
            pos4 = e.clientY;
            
            // Set the element's new position
            element.style.top = (element.offsetTop - pos2) + "px";
            element.style.left = (element.offsetLeft - pos1) + "px";
            
            // Update the marker position reference
            if (loadDisplays[jointLabel]) {
                loadDisplays[jointLabel].position = getPositionFromScreen(
                    parseInt(element.style.left), 
                    parseInt(element.style.top)
                );
            }
        }
        
        function closeDragElement() {
            // Stop moving when mouse button is released
            document.onmouseup = null;
            document.onmousemove = null;
        }
    }
    
    // Convert screen coordinates to 3D position
    function getPositionFromScreen(x, y) {
        const vector = new THREE.Vector3(
            (x / renderer.domElement.clientWidth) * 2 - 1,
            -(y / renderer.domElement.clientHeight) * 2 + 1,
            0.5
        );
        
        vector.unproject(camera);
        return vector;
    }
    
    // Remove load display
    function removeLoadDisplay(jointLabel) {
        if (!loadDisplays[jointLabel]) return;
        
        document.getElementById('load-displays-container').removeChild(loadDisplays[jointLabel].div);
        delete loadDisplays[jointLabel];
    }
    
    // Update HTML marker position based on 3D position
    function updateMarkerPosition(mesh, div) {
        const vector = mesh.position.clone();
        vector.project(camera);
        
        const x = (vector.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
        const y = (-(vector.y * 0.5) + 0.5) * renderer.domElement.clientHeight;
        
        div.style.left = `${x}px`;
        div.style.top = `${y}px`;
    }
    
    // Update load display position based on 3D position
    function updateLoadDisplayPosition(div, position) {
        const vector = position.clone();
        vector.project(camera);
        
        const x = (vector.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
        const y = (-(vector.y * 0.5) + 0.5) * renderer.domElement.clientHeight;
        
        div.style.left = `${x + 20}px`; // Offset slightly from the marker
        div.style.top = `${y}px`;
    }
    
    // Remove a joint marker
    function removeJointMarker(jointLabel) {
        if (!jointMarkers[jointLabel]) return;
        
        scene.remove(jointMarkers[jointLabel].mesh);
        document.getElementById('joint-markers-container').removeChild(jointMarkers[jointLabel].div);
        delete jointMarkers[jointLabel];
    }
    
    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        
        // Update marker positions
        for (const jointLabel in jointMarkers) {
            updateMarkerPosition(jointMarkers[jointLabel].mesh, jointMarkers[jointLabel].div);
            
            // Update load display positions if they exist
            if (loadDisplays[jointLabel]) {
                updateLoadDisplayPosition(
                    loadDisplays[jointLabel].div, 
                    jointMarkers[jointLabel].mesh.position
                );
            }
        }
        
        renderer.render(scene, camera);
    }
    
    function onWindowResize() {
        const container = document.getElementById('model-viewer');
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    }
    
    // Clear table
    function clearTable() {
        document.getElementById('load-table').getElementsByTagName('tbody')[0].innerHTML = '';
    }


    function handleRecordSelection(e) {
    const index = parseInt(e.target.dataset.index);
    const record = allTableData[index];
    
    if (e.target.checked) {
        selectedRecords.add(record);
    } else {
        selectedRecords.delete(record);
    }
    
    updateSelectedCount();
}

function updateSelectedCount() {
    const selectedCount = document.getElementById('selected-count');
    const calculateBtn = document.getElementById('calculate-btn');
    
    selectedCount.textContent = `${selectedRecords.size} selected`;
    calculateBtn.disabled = selectedRecords.size === 0;
}

// Add event listener for calculate button
// Update the calculate button event listener
document.getElementById('calculate-btn').addEventListener('click', function() {
    if (selectedRecords.size > 0) {
        // Prepare data for calculation - convert Set to Array
        const calculationData = Array.from(selectedRecords);
        
        // Create a form to submit the data
        const form = document.createElement('form');
        form.method = 'GET';
        form.action = '/calculation/';
        form.target = '_blank';
        
        const input = document.createElement('input');
        input.type = 'hidden';
        input.name = 'calculation_data';
        input.value = JSON.stringify(calculationData);
        form.appendChild(input);
        
        document.body.appendChild(form);
        form.submit();
        document.body.removeChild(form);
    }
});
    
    // Update table with selected labels
function updateTable() {
    clearTable();
    const tbody = document.getElementById('load-table').getElementsByTagName('tbody')[0];
    
    // Get all column names from the table headers
    const columns = Array.from(document.querySelectorAll('#load-table thead th'))
        .map(th => th.textContent.trim())
        .filter(col => col !== 'Select'); // Exclude the Select column
    
    // Store all table data for later reference
    allTableData = [];
    
    // Add new rows from the filtered data
    loadData.forEach((item, index) => {
        const row = tbody.insertRow();
        allTableData.push(item); // Store reference to this data
        
        // Add checkbox cell
        const checkboxCell = row.insertCell();
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'record-checkbox';
        checkbox.dataset.index = index;
        checkbox.addEventListener('change', handleRecordSelection);
        checkboxCell.appendChild(checkbox);
        
        // Add cells for each column
        columns.forEach(column => {
            const cell = row.insertCell();
            cell.textContent = item[column] !== undefined ? item[column] : '';
        });
    });
    
    // Update selected count
    updateSelectedCount();

    // Only add joints if we're in joint labels mode and joints are selected
    {% if button_type == 'joint_labels' %}
    Array.from(selectedJoints).forEach(label => {
        const loadInfo = loadData.find(item => item['Attach. Joint Labels'] === label);
        if (loadInfo) {
            const newRow = tbody.insertRow();
            
            // Add cells for each column
            columns.forEach(column => {
                const cell = newRow.insertCell();
                cell.textContent = loadInfo[column] !== undefined ? loadInfo[column] : '';
            });
        }
    });
    {% endif %}
    
    // Only add sets if we're in set/phase mode and sets are selected
    {% if button_type == 'set_phase' %}
    Array.from(selectedSets).forEach(setNum => {
        // Find all rows with this set number
        const setData = loadData.filter(item => item['Set No.'] == setNum);
        
        if (setData.length > 0) {
            // Add a header row for the set
            const headerRow = tbody.insertRow();
            const headerCell = headerRow.insertCell();
            headerCell.colSpan = columns.length;
            headerCell.textContent = `Set ${setNum}`;
            headerCell.style.textAlign = 'center';
            headerCell.style.backgroundColor = '#e6f2ff';
            headerCell.style.fontWeight = 'bold';
            
            // Add all data rows for this set
            setData.forEach(item => {
                const row = tbody.insertRow();
                columns.forEach(column => {
                    const cell = row.insertCell();
                    cell.textContent = item[column] !== undefined ? item[column] : '';
                });
            });
        }
    });
    
    // Only add phases if we're in set/phase mode and phases are selected
    Array.from(selectedPhases).forEach(phaseNum => {
        // Find all rows with this phase number
        const phaseData = loadData.filter(item => item['Phase No.'] == phaseNum);
        
        if (phaseData.length > 0) {
            // Add a header row for the phase
            const headerRow = tbody.insertRow();
            const headerCell = headerRow.insertCell();
            headerCell.colSpan = columns.length;
            headerCell.textContent = `Phase ${phaseNum}`;
            headerCell.style.textAlign = 'center';
            headerCell.style.backgroundColor = '#e6ffe6';
            headerCell.style.fontWeight = 'bold';
            
            // Add all data rows for this phase
            phaseData.forEach(item => {
                const row = tbody.insertRow();
                columns.forEach(column => {
                    const cell = row.insertCell();
                    cell.textContent = item[column] !== undefined ? item[column] : '';
                });
            });
        }
    });
    {% endif %}
}

    
    // Set up event listeners
    function addMarker(itemType, itemValue) {
    if (itemType === 'joint') {
        if (jointMarkers[itemValue]) return;
        addJointMarker(itemValue);
    } 
    else if (itemType === 'set') {
        if (setMarkers[itemValue]) return;
        addSetMarker(itemValue);
    }
    else if (itemType === 'phase') {
        if (phaseMarkers[itemValue]) return;
        addPhaseMarker(itemValue);
    }
}

// Function to add a set marker
function addSetMarker(setNumber) {
    const geometry = new THREE.SphereGeometry(0.03, 16, 16);
    const material = new THREE.MeshBasicMaterial({ color: 0x0000ff }); // Blue for sets
    const sphere = new THREE.Mesh(geometry, material);
    
    // Position the marker
    sphere.position.set(
        (Math.random() - 0.5) * 2,
        Math.random() * 2,
        (Math.random() - 0.5) * 2
    );
    
    // Add label
    const markerDiv = document.createElement('div');
    markerDiv.className = 'set-marker';
    markerDiv.textContent = `Set ${setNumber}`;
    markerDiv.style.position = 'absolute';
    markerDiv.style.color = 'blue';
    markerDiv.dataset.setNumber = setNumber;
    document.getElementById('set-markers-container').appendChild(markerDiv);
    
    setMarkers[setNumber] = {
        mesh: sphere,
        div: markerDiv,
        isDragging: false
    };
    
    scene.add(sphere);
    updateMarkerPosition(sphere, markerDiv);
    makeDraggable(markerDiv, setNumber, 'set');
}

// Function to add a phase marker
function addPhaseMarker(phaseNumber) {
    const geometry = new THREE.SphereGeometry(0.03, 16, 16);
    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // Green for phases
    const sphere = new THREE.Mesh(geometry, material);
    
    // Position the marker
    sphere.position.set(
        (Math.random() - 0.5) * 2,
        Math.random() * 2,
        (Math.random() - 0.5) * 2
    );
    
    // Add label
    const markerDiv = document.createElement('div');
    markerDiv.className = 'phase-marker';
    markerDiv.textContent = `Phase ${phaseNumber}`;
    markerDiv.style.position = 'absolute';
    markerDiv.style.color = 'green';
    markerDiv.dataset.phaseNumber = phaseNumber;
    document.getElementById('phase-markers-container').appendChild(markerDiv);
    
    phaseMarkers[phaseNumber] = {
        mesh: sphere,
        div: markerDiv,
        isDragging: false
    };
    
    scene.add(sphere);
    updateMarkerPosition(sphere, markerDiv);
    makeDraggable(markerDiv, phaseNumber, 'phase');
}

    // Set up event listeners
    document.addEventListener('DOMContentLoaded', function() {
    // Initialize 3D viewer
    initModelViewer();
    updateTable();

    // Handle checkbox changes for all types
    ['joint', 'set', 'phase'].forEach(type => {
        const container = document.getElementById(`${type}-${type === 'joint' ? 'labels' : 'numbers'}`);
        if (container) {
            container.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    const itemValue = this.value;
                    
                    if (type === 'joint') {
                        if (this.checked) {
                            selectedJoints.add(itemValue);
                            addMarker('joint', itemValue);
                        } else {
                            selectedJoints.delete(itemValue);
                            removeJointMarker(itemValue);
                        }
                    } 
                    else if (type === 'set') {
                        if (this.checked) {
                            selectedSets.add(itemValue);
                            addMarker('set', itemValue);
                        } else {
                            selectedSets.delete(itemValue);
                            if (setMarkers[itemValue]) {
                                scene.remove(setMarkers[itemValue].mesh);
                                document.getElementById('set-markers-container').removeChild(setMarkers[itemValue].div);
                                delete setMarkers[itemValue];
                            }
                        }
                    }
                    else if (type === 'phase') {
                        if (this.checked) {
                            selectedPhases.add(itemValue);
                            addMarker('phase', itemValue);
                        } else {
                            selectedPhases.delete(itemValue);
                            if (phaseMarkers[itemValue]) {
                                scene.remove(phaseMarkers[itemValue].mesh);
                                document.getElementById('phase-markers-container').removeChild(phaseMarkers[itemValue].div);
                                delete phaseMarkers[itemValue];
                            }
                        }
                    }
                    
                    updateTable();
                });
            });
        }
    });


        
        // Make labels draggable
         document.querySelectorAll('.drag-item').forEach(item => {
        item.addEventListener('dragstart', function(e) {
            e.dataTransfer.setData('type', this.dataset.type);
            e.dataTransfer.setData('value', this.dataset.value);
            e.dataTransfer.effectAllowed = 'copy';
        });
    });
        
        // Set up drop zone on model viewer
        const modelCanvas = document.getElementById('model-canvas');
    modelCanvas.addEventListener('dragover', function(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'copy';
    });
    
    modelCanvas.addEventListener('drop', function(e) {
        e.preventDefault();
        const itemType = e.dataTransfer.getData('type');
        const itemValue = e.dataTransfer.getData('value');
        
        // Find the corresponding checkbox and check it
        let checkbox;
        if (itemType === 'joint') {
            checkbox = document.querySelector(`input[name="joint-labels"][value="${itemValue}"]`);
            if (checkbox && !checkbox.checked) {
                checkbox.checked = true;
                const event = new Event('change');
                checkbox.dispatchEvent(event);
            }
        }
        else if (itemType === 'set') {
            checkbox = document.querySelector(`input[name="set-numbers"][value="${itemValue}"]`);
            if (checkbox && !checkbox.checked) {
                checkbox.checked = true;
                const event = new Event('change');
                checkbox.dispatchEvent(event);
            }
        }
        else if (itemType === 'phase') {
            checkbox = document.querySelector(`input[name="phase-numbers"][value="${itemValue}"]`);
            if (checkbox && !checkbox.checked) {
                checkbox.checked = true;
                const event = new Event('change');
                checkbox.dispatchEvent(event);
            }
        }
    });
});
        
       
</script>


{% comment %} this js is for header bar  {% endcomment %}
   
<script>
document.addEventListener('DOMContentLoaded', function() {
    const searchInput = document.getElementById('searchInput');
    const searchIcon = document.querySelector('.search-icon');
    
    // Debounce function to limit search frequency
    function debounce(func, wait) {
        let timeout;
        return function() {
            const context = this, args = arguments;
            clearTimeout(timeout);
            timeout = setTimeout(() => {
                func.apply(context, args);
            }, wait);
        };
    }
    
    // Function to search and highlight only matching text
    function searchCurrentPage(term) {
        // Remove all previous highlights
        removeHighlights();
        
        if (!term.trim()) return;
        
        // Get only the main content area (exclude header and sidebar)
        const mainContent = document.querySelector('.main-content');
        
        // Create a regular expression for case-insensitive matching
        const regex = new RegExp(term, 'gi');
        
        // Walk through all text nodes in main content
        const walker = document.createTreeWalker(
            mainContent,
            NodeFilter.SHOW_TEXT,
            null,
            false
        );
        
        let node;
        let found = false;
        
        while (node = walker.nextNode()) {
            // Skip empty nodes or nodes in script/style elements
            if (!node.nodeValue.trim() || 
                node.parentNode.tagName === 'SCRIPT' || 
                node.parentNode.tagName === 'STYLE') {
                continue;
            }
            
            const matches = node.nodeValue.match(regex);
            if (matches) {
                const span = document.createElement('span');
                span.className = 'search-highlight';
                
                // Replace each match with a highlighted span
                const newText = node.nodeValue.replace(regex, match => 
                    `<span class="search-highlight">${match}</span>`
                );
                
                // Create a temporary element to parse the HTML
                const temp = document.createElement('div');
                temp.innerHTML = newText;
                
                // Replace the text node with the new content
                const parent = node.parentNode;
                while (temp.firstChild) {
                    parent.insertBefore(temp.firstChild, node);
                }
                parent.removeChild(node);
                
                if (!found) {
                    // Scroll to first match
                    const firstHighlight = document.querySelector('.search-highlight');
                    if (firstHighlight) {
                        firstHighlight.scrollIntoView({
                            behavior: 'smooth',
                            block: 'center',
                            inline: 'nearest'
                        });
                        found = true;
                    }
                }
            }
        }
        
        if (!found && term.length > 0) {
            showNoResultsMessage(term);
        }
    }
    
    // Remove all highlights and restore original text
    function removeHighlights() {
        const highlights = document.querySelectorAll('.search-highlight');
        highlights.forEach(highlight => {
            const parent = highlight.parentNode;
            parent.replaceChild(
                document.createTextNode(highlight.textContent),
                highlight
            );
            // Normalize to merge adjacent text nodes
            parent.normalize();
        });
        
        // Remove any existing "no results" message
        const existingMessage = document.getElementById('search-no-results');
        if (existingMessage) existingMessage.remove();
    }
    
    // Show temporary "no results" message
    function showNoResultsMessage(term) {
        const message = document.createElement('div');
        message.id = 'search-no-results';
        message.textContent = `No results found for "${term}"`;
        message.style.position = 'fixed';
        message.style.bottom = '20px';
        message.style.right = '20px';
        message.style.backgroundColor = 'var(--error)';
        message.style.color = 'white';
        message.style.padding = '10px 20px';
        message.style.borderRadius = 'var(--radius-md)';
        message.style.boxShadow = 'var(--shadow-md)';
        message.style.zIndex = '2000';
        message.style.animation = 'fadeIn 0.3s ease';
        
        document.body.appendChild(message);
        
        // Remove message after 3 seconds
        setTimeout(() => {
            message.style.animation = 'fadeOut 0.3s ease';
            setTimeout(() => message.remove(), 300);
        }, 3000);
    }
    
    // Add styles for highlighting
    const style = document.createElement('style');
    style.textContent = `
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        .search-highlight {
            background-color: rgba(255, 193, 7, 0.5);
            border-radius: 2px;
            padding: 0 2px;
            color: #000;
        }
    `;
    document.head.appendChild(style);
    
    // Event listener with debounce
    searchInput.addEventListener('input', debounce(function(e) {
        const term = e.target.value.trim();
        searchCurrentPage(term);
        
        // Optional: If you want to also search server-side:
        if (term.length > 2) {
            fetch('/search/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'X-CSRFToken': '{{ csrf_token }}',
                },
                body: `search_term=${encodeURIComponent(term)}`
            })
            .then(response => response.json())
            .then(data => {
                console.log('Server results:', data.results);
                // Handle server results if needed
            });
        }
    }, 300));
    
    // Click on search icon to focus input
    searchIcon.addEventListener('click', function() {
        searchInput.focus();
    });
    
    // Clear search when clicking Escape
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            searchInput.value = '';
            removeHighlights();
        }
    });
});
</script>"

this is views 
"def hdata1(request):
    # Get selected values from session
    selected_values = request.session.get('selected_values', {})
    structure_id = selected_values.get('structure_id')
    button_type = selected_values.get('button_type', '')
    selected_load_cases = selected_values.get('load_cases', [])
    
    # If coming directly from buttons without specific filters
    if not structure_id and 'go_button' in request.POST:
        structure_id = request.POST.get('structure_id')
        button_type = request.POST.get('go_button')
        load_case_values = request.POST.get('load_case_values', '')
        
        # Convert comma-separated string to list
        if load_case_values:
            selected_load_cases = [case.strip() for case in load_case_values.split(',') if case.strip()]
        else:
            selected_load_cases = []
            
        if structure_id:
            selected_values = {
                'structure_id': structure_id,
                'button_type': button_type,
                'load_cases': selected_load_cases
            }
            request.session['selected_values'] = selected_values
    
    if structure_id:
        try:
            structure = ListOfStructure.objects.get(id=structure_id)
            latest_file = hUploadedFile1.objects.filter(structure=structure).latest('uploaded_at')
            df = pd.read_excel(latest_file.file.path, engine='openpyxl')

            # Filter by selected load cases if any are selected
            if selected_load_cases and 'Load Case Description' in df.columns:
                print(f"Filtering by load cases: {selected_load_cases}")  # Debug print
                # Filter the dataframe to include only selected load cases
                df = df[df['Load Case Description'].isin(selected_load_cases)]
                print(f"Filtered dataframe shape: {df.shape}")  # Debug print

            # Prepare complete data for table display - include ALL columns
            load_data = []
            for _, row in df.iterrows():
                row_data = {}
                # Add all columns from the dataframe
                for col in df.columns:
                    if pd.notna(row[col]):
                        # Convert numeric values to appropriate types
                        if pd.api.types.is_numeric_dtype(df[col]):
                            row_data[col] = float(row[col])
                        else:
                            row_data[col] = str(row[col])
                    else:
                        row_data[col] = '' if pd.api.types.is_string_dtype(df[col]) else 0
                load_data.append(row_data)

            # Get unique values for display based on filtered data
            joint_labels = [str(label) for label in df['Attach. Joint Labels'].unique()] if 'Attach. Joint Labels' in df.columns else []
            set_numbers = [str(num) for num in df['Set No.'].dropna().unique()] if 'Set No.' in df.columns else []
            phase_numbers = [str(num) for num in df['Phase No.'].dropna().unique()] if 'Phase No.' in df.columns else []

        except Exception as e:
            joint_labels = []
            set_numbers = []
            phase_numbers = []
            load_data = []
            print(f"Error processing Excel file: {str(e)}")
    else:
        joint_labels = []
        set_numbers = []
        phase_numbers = []
        load_data = []

    return render(request, 'app1/hdata1.html', {
        'joint_labels': joint_labels,
        'set_numbers': set_numbers,
        'phase_numbers': phase_numbers,
        'load_data': load_data,
        'load_data_json': json.dumps(load_data),
        'selected_values': selected_values,
        'all_columns': list(df.columns) if structure_id and 'df' in locals() else [],
        'button_type': button_type
    })
    
def calculation_view(request):
    if request.method == 'GET':
        # Get calculation data from request parameters
        calculation_data_json = request.GET.get('calculation_data')
        
        if calculation_data_json:
            try:
                calculation_data = json.loads(calculation_data_json)
                
                # Add resultant calculation to each record
                for record in calculation_data:
                    vert = float(record.get('Structure Loads Vert. (lbs)', 0) or 0)
                    trans = float(record.get('Structure Loads Trans. (lbs)', 0) or 0)
                    long = float(record.get('Structure Loads Long. (lbs)', 0) or 0)
                    
                    # Calculate SQRT(Vert² + Trans² + Long²) for each record
                    resultant = math.sqrt(vert**2 + trans**2 + long**2)
                    record['Resultant (lbs)'] = round(resultant, 2)
                
                # Group data by Set No. (for display purposes)
                grouped_data = {}
                for record in calculation_data:
                    set_no = record.get('Set No.', 'Unknown')
                    if set_no not in grouped_data:
                        grouped_data[set_no] = []
                    grouped_data[set_no].append(record)
                
                # Calculate max values for each set and flag max resultant rows
                set_max_values = {}
                max_resultant_values = {}  # Store the actual values that created the max resultant
                max_resultant_indexes = {}  # Store indexes for JavaScript approach
                
                for set_no, records in grouped_data.items():
                    vert_values = [float(record.get('Structure Loads Vert. (lbs)', 0) or 0) for record in records]
                    trans_values = [float(record.get('Structure Loads Trans. (lbs)', 0) or 0) for record in records]
                    long_values = [float(record.get('Structure Loads Long. (lbs)', 0) or 0) for record in records]
                    resultant_values = [record['Resultant (lbs)'] for record in records]
                    
                    # Find the maximum resultant value
                    max_resultant = max(resultant_values)
                    max_index = resultant_values.index(max_resultant)
                    
                    # Store the actual values that created the max resultant
                    max_resultant_values[set_no] = {
                        'vert': vert_values[max_index],
                        'trans': trans_values[max_index],
                        'long': long_values[max_index],
                        'resultant': max_resultant
                    }
                    
                    # Store index for JavaScript approach
                    max_resultant_indexes[set_no] = max_index
                    
                    # Add a simple flag to each record (as a string to avoid underscore issues)
                    for i, record in enumerate(records):
                        if resultant_values[i] == max_resultant:
                            record['max_resultant_flag'] = 'yes'
                        else:
                            record['max_resultant_flag'] = 'no'
                    
                    set_max_values[set_no] = {
                        'max_vert': max(vert_values),
                        'max_trans': max(trans_values),
                        'max_long': max(long_values),
                        'max_resultant': max_resultant,
                        'count': len(records)
                    }
                
                # Calculate combined values across all sets using the actual values that created max resultants
                combined_vert = sum([values['vert'] for values in max_resultant_values.values()])
                combined_trans = sum([values['trans'] for values in max_resultant_values.values()])
                combined_long = sum([values['long'] for values in max_resultant_values.values()])
                
                # Calculate the SQRT formula for combined values
                combined_sqrt = math.sqrt(combined_vert**2 + combined_trans**2 + combined_long**2)
                
                # Prepare context for template
                context = {
                    'grouped_data': grouped_data,
                    'set_max_values': set_max_values,
                    'max_resultant_values': max_resultant_values,  # Add this for displaying actual values
                    'combined_vert': combined_vert,
                    'combined_trans': combined_trans,
                    'combined_long': combined_long,
                    'combined_sqrt': combined_sqrt,
                    'calculation_data': calculation_data,
                    'max_resultant_indexes': max_resultant_indexes  # Add this for JavaScript
                }
                
                return render(request, 'app1/calculation.html', context)
                
            except json.JSONDecodeError:
                error = 'Invalid calculation data format'
        else:
            error = 'No calculation data provided'
    
    return render(request, 'app1/calculation.html', {'error': error or 'An error occurred during calculation'})
"




************************************************************************************************************

