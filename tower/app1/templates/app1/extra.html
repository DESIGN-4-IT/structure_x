
Please read the complete code carefully and act as an experienced developer.

On the hdata1 page, when I create a Set / Phase combination and click the ‚ÄúGo To Load Cases Selection‚Äù button, the application correctly redirects to the Load Cases page and displays the selected combination, for example:

Combinations (1 total): Set 10 ‚Äì Phase 2

However, when I select Attachment ‚Üí Joint Labels values and click the same ‚ÄúGo To Load Cases Selection‚Äù button, the Load Cases page only shows:

Active filters: Joint Labels (2)

The selected Joint Label values are not displayed, unlike the Set / Phase combinations.

Because of this, data filtering on the Load Cases page works correctly for Set / Phase, but does not work correctly for Attachment ‚Üí Joint Labels.

Please:

Review the complete code flow

Ensure selected Attachment ‚Üí Joint Labels values are passed correctly during redirection

Display the selected Joint Label values on the Load Cases page in the same way as Set / Phase combinations

Update the filtering logic so Load Cases data is filtered correctly based on Attachment selections as well

Modify the implementation accordingly and keep existing Set / Phase functionality unchanged.


this is views 
"@require_http_methods(["POST"])
@csrf_exempt
def store_set_phase_combinations(request):
    try:
        # Load the JSON data sent from the frontend
        data = json.loads(request.body)
        
        # The data should contain the list of combinations and the status
        combinations_to_add = data.get('combinations', [])
        status = data.get('status')  # 'Ahead' or 'Back' only now
        
        print(f"DEBUG store_set_phase_combinations: Received {len(combinations_to_add)} combinations: {combinations_to_add}")
        print(f"DEBUG: Status: {status}")
        
        # MODIFIED: Remove 'Both' from valid status options
        if not combinations_to_add or status not in ['Ahead', 'Back']:
            return JsonResponse({'status': 'error', 'message': 'Invalid data provided.'}, status=400)

        # Get the current active combinations from the session
        selected_values = request.session.get('selected_values', {})
        active_combinations = selected_values.get('active_combinations', [])
        
        print(f"DEBUG: Existing active_combinations before extend: {len(active_combinations)} items")
        
        # Process the new combinations: Add the status
        new_active_combinations = []
        for combo in combinations_to_add:
            combo_with_status = f"{combo}-{status}"
            if combo_with_status not in active_combinations:  # Prevent duplicates
                new_active_combinations.append(combo_with_status)
            else:
                print(f"DEBUG: Skipped duplicate combination: {combo_with_status}")
        
        active_combinations.extend(new_active_combinations)
        
        print(f"DEBUG: Added {len(new_active_combinations)} new combinations. Total active_combinations: {len(active_combinations)}")
        print(f"DEBUG: Final active_combinations: {active_combinations}")
        
        # Update the session
        request.session['selected_values']['active_combinations'] = active_combinations
        request.session.modified = True
        
        return JsonResponse({
            'status': 'success', 
            'message': f'Successfully stored {len(new_active_combinations)} new combinations as {status}.',
            'new_combinations': new_active_combinations
        })
    except json.JSONDecodeError:
        print("DEBUG: JSON decode error")
        return JsonResponse({'status': 'error', 'message': 'Invalid JSON format.'}, status=400)
    except Exception as e:
        print(f"Error storing combinations: {e}")
        return JsonResponse({'status': 'error', 'message': str(e)}, status=500)

def debug_session_selections(session_data):
    """Helper to debug session data"""
    print("\nüîç SESSION DATA DEBUG:")
    print(f"Structure Type: {session_data.get('selected_structure_type')}")
    
    popup_selections = session_data.get('popup_selections', {})
    print(f"Popup Selections: {popup_selections}")
    
    circuit_def = session_data.get('circuit_definition', {})
    print(f"Circuit Definition: {circuit_def}")
    
    # Print all stored models for reference
    from .models import TowerModel
    all_models = TowerModel.objects.all()
    print(f"\nüì¶ AVAILABLE MODELS IN DATABASE ({all_models.count()} total):")
    for model in all_models:
        print(f"  - {model.name}: {model.structure_type}/{model.attachment_points}/{model.configuration}/{model.circuit_type}")

def find_matching_model(session_data):
    """
    Find a 3D model that matches ALL session selections including complete circuit definition
    """
    from .models import TowerModel
    
    # Extract data from session
    structure_type = session_data.get('selected_structure_type')
    popup_selections = session_data.get('popup_selections', {})
    circuit_definition = session_data.get('circuit_definition', {})
    
    # Get attachment points and configuration from popups
    attachment_points = popup_selections.get('attachment_points')
    configuration = popup_selections.get('configuration')
    
    # DEBUG: Print all selection data
    print(f"\nüéØ DEBUG [find_matching_model] - User Selections:")
    print(f"  Structure Type: {structure_type}")
    print(f"  Attachment Points: {attachment_points}")
    print(f"  Configuration: {configuration}")
    print(f"  Circuit Definition: {circuit_definition}")
    
    # Convert to integers safely
    num_3_phase = 0
    num_1_phase = 0
    
    try:
        num_3_phase = int(circuit_definition.get('num_3_phase_circuits', 0) or 0)
    except (ValueError, TypeError):
        num_3_phase = 0
        
    try:
        num_1_phase = int(circuit_definition.get('num_1_phase_circuits', 0) or 0)
    except (ValueError, TypeError):
        num_1_phase = 0
    
    # CORRECT CIRCUIT TYPE CALCULATION FOR TRANSMISSION LINE STRUCTURES:
    # Priority: 3-Phase Circuits > 1-Phase Circuits
    # Shield wires and comm cables typically don't count as separate circuits
    
    if num_3_phase >= 3:
        circuit_type = 'tc'  # Triple Circuit
    elif num_3_phase == 2:
        circuit_type = 'dc'  # Double Circuit
    elif num_3_phase == 1:
        circuit_type = 'sc'  # Single Circuit
    elif num_1_phase >= 3:
        circuit_type = 'tc'  # Triple Circuit (1-phase bundles)
    elif num_1_phase == 2:
        circuit_type = 'dc'  # Double Circuit (1-phase bundles)
    elif num_1_phase == 1:
        circuit_type = 'sc'  # Single Circuit (1-phase bundle)
    else:
        circuit_type = 'sc'  # Default to Single Circuit
    
    print(f"  Calculated Circuit Type: {circuit_type}")
    print(f"    Based on: 3-Phase Circuits={num_3_phase}, 1-Phase Circuits={num_1_phase}")
    
    # Try to find EXACT match first
    matching_model = TowerModel.objects.filter(
        structure_type=structure_type,
        attachment_points=attachment_points,
        configuration=configuration,
        circuit_type=circuit_type
    ).first()
    
    if matching_model:
        print(f"  ‚úì Found EXACT match: {matching_model.name}")
        return matching_model
    
    print(f"  ‚ö† No exact match found, trying naming convention...")
    
    # FIXED NAMING CONVENTION MAPPING:
    # Structure type prefix
    if structure_type == 'hframes':
        prefix = "HFrame"
    elif structure_type == 'towers':
        prefix = "Tower"
    elif structure_type == 'monopoles':
        prefix = "MP"
    else:
        prefix = structure_type.capitalize() if structure_type else ""
    
    # FIXED: Attachment points mapping (DE vs Tan)
    if attachment_points == 'deadend':
        attachment_code = "DE"
    elif attachment_points == 'tangent':
        attachment_code = "Tan"
    else:
        attachment_code = ""
    
    # FIXED: Configuration mapping (Vert vs Horiz)
    if configuration == 'vertical':
        config_code = "Vert"
    elif configuration == 'horizontal':
        config_code = "Horiz"
    elif configuration == 'delta':
        config_code = "Delta"
    elif configuration == 'hetic':
        config_code = "Hetic"
    else:
        config_code = configuration.capitalize() if configuration else ""
    
    # Circuit type code
    circuit_code = circuit_type.upper()  # SC, DC, TC
    
    # Generate the expected name based on your naming pattern
    expected_name = f"{prefix}_{attachment_code}_{config_code}_{circuit_code}"
    print(f"  Looking for model with name pattern: {expected_name}")
    
    # FIRST: Try to find by exact name
    exact_name_match = TowerModel.objects.filter(name__iexact=expected_name).first()
    if exact_name_match:
        print(f"  ‚úì Found EXACT name match: {exact_name_match.name}")
        return exact_name_match
    
    # SECOND: Try to find by name containing all parts
    name_query = TowerModel.objects.all()
    
    # Add filters based on name parts
    if prefix:
        name_query = name_query.filter(name__icontains=prefix)
    if attachment_code:
        name_query = name_query.filter(name__icontains=attachment_code)
    if config_code:
        name_query = name_query.filter(name__icontains=config_code)
    if circuit_code:
        name_query = name_query.filter(name__icontains=circuit_code)
    
    # Get all matching by name
    name_matches = list(name_query)
    
    if name_matches:
        print(f"  Found {len(name_matches)} name matches:")
        for match in name_matches:
            print(f"    - {match.name} ({match.structure_type}/{match.attachment_points}/{match.configuration}/{match.circuit_type})")
        return name_matches[0]
    
    # THIRD: Try fuzzy matching
    print(f"  Trying fuzzy matching...")
    all_models = TowerModel.objects.all()
    best_match = None
    best_score = 0
    
    for model in all_models:
        score = 0
        
        # Check structure type (most important - 30 points)
        if model.structure_type == structure_type:
            score += 30
        
        # Check attachment points (25 points)
        if model.attachment_points == attachment_points:
            score += 25
        
        # Check configuration (25 points)
        if model.configuration == configuration:
            score += 25
        
        # Check circuit type (20 points)
        if model.circuit_type == circuit_type:
            score += 20
        
        # Check name contains expected parts
        model_name_upper = model.name.upper()
        expected_parts = [prefix.upper(), attachment_code.upper(), config_code.upper(), circuit_code]
        for part in expected_parts:
            if part and part in model_name_upper:
                score += 5
        
        if score > best_score:
            best_score = score
            best_match = model
    
    if best_match and best_score >= 50:
        print(f"  ‚úì Found BEST fuzzy match: {best_match.name} (score: {best_score})")
        print(f"    Details: {best_match.structure_type}/{best_match.attachment_points}/{best_match.configuration}/{best_match.circuit_type}")
        return best_match
    
    # FINAL FALLBACK: Get first model of the correct structure type
    print(f"  ‚ö† Falling back to first {structure_type} model")
    fallback = TowerModel.objects.filter(structure_type=structure_type).first()
    if fallback:
        print(f"  Using: {fallback.name}")
    return fallback

def hdata1(request):
    # DEBUG: Print all session data at the start of hdata1
    debug_session_selections(request.session)
    
    print(f"\nüìä DEBUG [hdata1 Page] - Detailed session data:")
    print(f"  1. Home Page Data:")
    print(f"     Structure Type: {request.session.get('selected_structure_type')}")
    print(f"     Structure ID: {request.session.get('selected_structure_id')}")
    print(f"     Active Popups: {request.session.get('active_popups', [])}")
    print(f"     Popup Selections: {request.session.get('popup_selections', {})}")
    
    print(f"  2. Circuit Definition Data:")
    circuit_definition = request.session.get('circuit_definition', {})
    print(f"     Num 3-Phase Circuits: {circuit_definition.get('num_3_phase_circuits')}")
    print(f"     Num Shield Wires: {circuit_definition.get('num_shield_wires')}")
    print(f"     Num 1-Phase Circuits: {circuit_definition.get('num_1_phase_circuits')}")
    print(f"     Num Communication Cables: {circuit_definition.get('num_communication_cables')}")
    print(f"     Circuit Model: {circuit_definition.get('circuit_model')}")
    print(f"     Circuit ID: {circuit_definition.get('circuit_id')}")
    
    print(f"  3. Selection Values:")
    print(f"     Selected Values: {request.session.get('selected_values', {})}")
    
    # ================== FIX 1: ADD TYPE CHECK FOR selected_values ==================
    # Get selected values from session - ensure it's always a dictionary
    selected_values = request.session.get('selected_values', {})
    
    # FIX: Ensure selected_values is a dictionary, not a list
    if isinstance(selected_values, list):
        print(f"‚ö†Ô∏è WARNING: selected_values is a list with {len(selected_values)} items, converting to dict")
        print(f"   List content: {selected_values}")
        request.session['selected_values'] = {}
        selected_values = {}
    # ===============================================================================
    
    # Find matching model based on all selections
    matching_model = find_matching_model(request.session)
    print(f"\nüîç DEBUG [hdata1] - Matching Results:")
    if matching_model:
        print(f"  ‚úì Found matching model: {matching_model.name}")
        print(f"    ID: {matching_model.id}")
        print(f"    Type: {matching_model.structure_type}")
        print(f"    Attachment: {matching_model.attachment_points}")
        print(f"    Configuration: {matching_model.configuration}")
        print(f"    Circuit: {matching_model.circuit_type}")
    else:
        print(f"  ‚ö† No matching model found")

    available_models = TowerModel.objects.all().order_by('name')
    selected_model_id = request.session.get('selected_model_id')
    
    # AUTO-SELECT matched model if available
    if matching_model:
        selected_model_id = matching_model.id
        request.session['selected_model_id'] = selected_model_id
        request.session['matched_model_id'] = matching_model.id
        print(f"  üéØ AUTO-SELECTING matched model ID: {selected_model_id} ({matching_model.name})")
    elif selected_model_id:
        # Keep existing selection if no match found
        print(f"  üîÑ Keeping existing selection ID: {selected_model_id}")
    
    # Handle POST requests for model selection
    if request.method == 'POST':
        # Handle manual model selection
        if 'selected_model' in request.POST:
            selected_model_id = request.POST.get('selected_model')
            if selected_model_id:
                request.session['selected_model_id'] = selected_model_id
                print(f"  üîÑ User manually selected model ID: {selected_model_id}")
                
                # Clear matched model flag since user made manual choice
                if 'matched_model_id' in request.session:
                    del request.session['matched_model_id']
            else:
                # Clear selection if "None" is selected
                request.session.pop('selected_model_id', None)
                # If user cleared selection, revert to matched model
                if matching_model:
                    selected_model_id = matching_model.id
                    request.session['selected_model_id'] = selected_model_id
                    request.session['matched_model_id'] = matching_model.id
                    print(f"  üîÑ User cleared selection, reverting to matched model")
        
        # Handle new model upload
        if 'tower_model_file' in request.FILES:
            model_name = request.POST.get('model_name', 'Unnamed Model')
            model_file = request.FILES['tower_model_file']
            
            # Validate file type
            if model_file.name.endswith(('.glb', '.gltf')):
                # Get categorization from form
                structure_type = request.POST.get('structure_type')
                attachment_points = request.POST.get('attachment_points')
                configuration = request.POST.get('configuration')
                circuit_type = request.POST.get('circuit_type')
                
                new_model = TowerModel.objects.create(
                    name=model_name,
                    model_file=model_file,
                    structure_type=structure_type,
                    attachment_points=attachment_points,
                    configuration=configuration,
                    circuit_type=circuit_type
                )
                
                # Optionally select the newly uploaded model
                request.session['selected_model_id'] = new_model.id
                selected_model_id = new_model.id
                print(f"  üì§ New model uploaded and selected: {new_model.name} (ID: {new_model.id})")
    
    # Get selected model if any
    selected_model = None
    if selected_model_id:
        try:
            selected_model = TowerModel.objects.get(id=selected_model_id)
            print(f"  üìä Current selected model: {selected_model.name} (ID: {selected_model.id})")
            print(f"    Details: {selected_model.structure_type}/{selected_model.attachment_points}/{selected_model.configuration}/{selected_model.circuit_type}")
        except TowerModel.DoesNotExist:
            print(f"  ‚ùå Selected model ID {selected_model_id} not found")
            selected_model = None
            
    # ENSURE we always have a selected model
    if not selected_model:
        if matching_model:
            selected_model = matching_model
            print(f"  üÜò Fallback to matching model: {selected_model.name}")
        elif available_models.exists():
            selected_model = available_models.first()
            print(f"  ‚ö† No match found, selecting first available: {selected_model.name}")
        else:
            print(f"  ‚ö† No models available in database")
    
    # Store model info in session for frontend
    if selected_model:
        request.session['selected_model_url'] = selected_model.get_file_url()
        request.session['selected_model_name'] = selected_model.name
        request.session['selected_model_details'] = {
            'structure_type': selected_model.structure_type,
            'attachment_points': selected_model.attachment_points,
            'configuration': selected_model.configuration,
            'circuit_type': selected_model.circuit_type
        }
    
    # Get all session data to pass to template - UPDATED with type check
    # Note: selected_values is already defined above with type checking
    active_combinations = selected_values.get('active_combinations', [])
    structure_id = selected_values.get('structure_id')
    button_type = selected_values.get('button_type', '')
    
    # Get circuit definition data from session
    circuit_definition = request.session.get('circuit_definition', {})
    
    # Process structure data if structure_id exists
    joint_labels = []
    set_numbers = []
    phase_numbers = []
    load_data = []
    df_columns = []
    
    if structure_id:
        try:
            structure = ListOfStructure.objects.get(id=structure_id)
            
            # Try to get the latest file from different models
            latest_file = None
            file_models = [
                tUploadedFile6, hUploadedFile1, tUploadedFile1, tUploadedFile2,
                tUploadedFile3, tUploadedFile4, tUploadedFile5, hUploadedFile2,
                hUploadedFile3, hUploadedFile4, tUploadedFile7, tUploadedFile8,
                tUploadedFile9, tUploadedFile10, tUploadedFile11, UploadedFile1,
                UploadedFile22, mUploadedFile5, mUploadedFile6, mUploadedFile7,
                mUploadedFile8, mUploadedFile9, mUploadedFile10, mUploadedFile11
            ]
            
            for model in file_models:
                if model.objects.filter(structure=structure).exists():
                    latest_file = model.objects.filter(structure=structure).latest('uploaded_at')
                    break
            
            if not latest_file:
                raise Exception("No uploaded file found for this structure")
                
            df = pd.read_excel(latest_file.file.path, engine='openpyxl')
            df_columns = list(df.columns)

            # Get selected load cases from session to filter data
            selected_load_cases = selected_values.get('load_cases', [])
            if selected_load_cases and 'Load Case Description' in df.columns:
                df = df[df['Load Case Description'].isin(selected_load_cases)]

            # Prepare complete data for table display
            load_data = []
            for _, row in df.iterrows():
                row_data = {}
                for col in df.columns:
                    if pd.notna(row[col]):
                        if pd.api.types.is_numeric_dtype(df[col]):
                            row_data[col] = float(row[col])
                        else:
                            row_data[col] = str(row[col])
                    else:
                        row_data[col] = '' if pd.api.types.is_string_dtype(df[col]) else 0
                load_data.append(row_data)

            # Get unique values for display
            joint_labels = [str(label) for label in df['Attach. Joint Labels'].unique()] if 'Attach. Joint Labels' in df.columns else []
            set_numbers = [str(num) for num in df['Set No.'].dropna().unique()] if 'Set No.' in df.columns else []
            phase_numbers = [str(num) for num in df['Phase No.'].dropna().unique()] if 'Phase No.' in df.columns else []

        except Exception as e:
            joint_labels = []
            set_numbers = []
            phase_numbers = []
            load_data = []
            df_columns = []
            print(f"Error processing Excel file: {str(e)}")
    
    # ================== FIX 2: ENSURE selected_values IS A DICT ==================
    # Initialize session storage for selections
    if 'selected_values' not in request.session:
        request.session['selected_values'] = {}
    
    # FIX: Ensure selected_values is always a dictionary
    if not isinstance(request.session.get('selected_values'), dict):
        print(f"‚ö†Ô∏è WARNING: selected_values in session is not a dict, resetting")
        request.session['selected_values'] = {}
    # =============================================================================
    
    # Initialize empty arrays if they don't exist
    if 'selected_joints' not in request.session['selected_values']:
        request.session['selected_values']['selected_joints'] = []
    
    if 'active_combinations' not in request.session['selected_values']:
        request.session['selected_values']['active_combinations'] = []
    
    # Get current selections from session
    selected_joints = request.session['selected_values'].get('selected_joints', [])
    active_combinations = request.session['selected_values'].get('active_combinations', [])
    
    # Build filter criteria
    filter_criteria = {}

    # Store joint labels if any are selected
    if selected_joints:
        filter_criteria['joint_labels'] = selected_joints

    # Store set-phase combinations if any are active - UPDATED to always use dicts
    set_phase_pairs = []
    if active_combinations:
        for combo in active_combinations:
            if isinstance(combo, str):
                # Format: "1-2-Ahead" -> extract set and phase
                parts = combo.split('-')
                if len(parts) >= 2:
                    set_phase_pairs.append({'set': parts[0], 'phase': parts[1]})
            elif isinstance(combo, dict):
                # Handle dictionary format (normalize values to strings)
                set_val = str(combo.get('set', ''))
                phase_val = str(combo.get('phase', ''))
                if set_val and phase_val:
                    set_phase_pairs.append({'set': set_val, 'phase': phase_val})

    if set_phase_pairs:
        filter_criteria['set_phase_combinations'] = set_phase_pairs
    
    # Store filter criteria in session
    request.session['selected_values']['filter_criteria'] = filter_criteria
    request.session.modified = True

    # Calculate total circuits for display
    total_circuits = 0
    if circuit_definition:
        num_3_phase = int(circuit_definition.get('num_3_phase_circuits', 0) or 0)
        num_1_phase = int(circuit_definition.get('num_1_phase_circuits', 0) or 0)
        total_circuits = num_3_phase + num_1_phase

    # Prepare context data including all session information
    context = {
        # Model selection context
        'available_models': available_models,
        'selected_model': selected_model,
        'matching_model': matching_model,
        
        # Structure data context
        'joint_labels': joint_labels,
        'set_numbers': set_numbers,
        'phase_numbers': phase_numbers,
        'load_data': load_data,
        'load_data_json': json.dumps(load_data),
        'all_columns': df_columns,
        
        # Selection context
        'selected_values': selected_values,  # This is now guaranteed to be a dict
        'button_type': button_type,
        'structure_id': structure_id,
        'filter_criteria': filter_criteria,
        'selected_joints': selected_joints,
        'active_combinations': active_combinations,
        
        # Session data from Home Page and Circuit Definition
        'session_structure_type': request.session.get('selected_structure_type', ''),
        'session_structure_id': request.session.get('selected_structure_id', ''),
        'session_active_popups': request.session.get('active_popups', []),
        'session_popup_selections': request.session.get('popup_selections', {}),
        'session_circuit_definition': circuit_definition,
        'session_total_circuits': total_circuits,
        
        # Model matching info
        'matched_model_info': {
            'structure_type': matching_model.structure_type if matching_model else None,
            'attachment_points': matching_model.attachment_points if matching_model else None,
            'configuration': matching_model.configuration if matching_model else None,
            'circuit_type': matching_model.circuit_type if matching_model else None,
        } if matching_model else None,
        
        # Selection comparison for debugging
        'selection_comparison': {
            'user_structure': request.session.get('selected_structure_type'),
            'user_attachment': request.session.get('popup_selections', {}).get('attachment_points'),
            'user_configuration': request.session.get('popup_selections', {}).get('configuration'),
            'model_structure': selected_model.structure_type if selected_model else None,
            'model_attachment': selected_model.attachment_points if selected_model else None,
            'model_configuration': selected_model.configuration if selected_model else None,
            'is_matched': selected_model == matching_model if selected_model and matching_model else False
        } if selected_model else {}
    }
    
    print(f"\n‚úÖ [hdata1] Context prepared:")
    print(f"  Selected Model: {selected_model.name if selected_model else 'None'}")
    print(f"  Matching Model: {matching_model.name if matching_model else 'None'}")
    print(f"  Models Match: {selected_model == matching_model if selected_model and matching_model else False}")
    print(f"  selected_values type: {type(selected_values)}")
    print(f"  selected_values content: {selected_values}")
    
    return render(request, 'app1/hdata1.html', context)

# Add this function to your views.py
def update_selection_session(request):
    if request.headers.get('x-requested-with') == 'XMLHttpRequest':
        if request.method == 'POST':
            selected_joints = request.POST.getlist('selected_joints[]')
            active_combinations_json = request.POST.get('active_combinations', '[]')
            
            try:
                active_combinations = json.loads(active_combinations_json)
            except json.JSONDecodeError:
                active_combinations = []
            
            print(f"DEBUG update_selection_session: Received {len(active_combinations)} raw combinations: {active_combinations}")  # NEW: Log raw input
            
            # Normalize combinations for consistent filtering
            normalized_combinations = []
            for combo in active_combinations:
                normalized_combo = {}
                for key, value in combo.items():
                    if isinstance(value, (int, float)):
                        if value == int(value):
                            normalized_combo[key] = str(int(value))
                        else:
                            normalized_combo[key] = str(value)
                    else:
                        normalized_combo[key] = str(value).strip()
                normalized_combinations.append(normalized_combo)
            
            print(f"DEBUG: Normalized to {len(normalized_combinations)} combinations: {normalized_combinations}")  # NEW: Log normalized output
            
            if 'selected_values' not in request.session:
                request.session['selected_values'] = {}
            
            request.session['selected_values']['selected_joints'] = selected_joints
            request.session['selected_values']['active_combinations'] = normalized_combinations  # Note: This overwrites with dicts
            
            # Build filter criteria
            filter_criteria = {}
            if selected_joints:
                filter_criteria['joint_labels'] = selected_joints
            if normalized_combinations:
                filter_criteria['set_phase_combinations'] = normalized_combinations
            
            request.session['selected_values']['filter_criteria'] = filter_criteria
            request.session.modified = True
            
            print(f"DEBUG: Updated session with {len(normalized_combinations)} combinations. Filter criteria: {filter_criteria}")  # NEW: Log final session update
            
            return JsonResponse({
                'success': True,
                'selected_joints': selected_joints,
                'active_combinations': normalized_combinations,
                'filter_criteria': filter_criteria
            })
    
    return JsonResponse({'success': False, 'error': 'Invalid request'})


def apply_previous_selection_filter(structure_id, filter_criteria, selected_load_cases=None):
    """Apply filter criteria and return data with grouping support"""
    try:
        structure = ListOfStructure.objects.get(id=structure_id)
        
        # Try to get the latest file
        latest_file = None
        file_models = [
            tUploadedFile6, hUploadedFile1, tUploadedFile1, tUploadedFile2,
            tUploadedFile3, tUploadedFile4, tUploadedFile5, hUploadedFile2,
            hUploadedFile3, hUploadedFile4, tUploadedFile7, tUploadedFile8,
            tUploadedFile9, tUploadedFile10, tUploadedFile11, UploadedFile1,
            UploadedFile22, mUploadedFile5, mUploadedFile6, mUploadedFile7,
            mUploadedFile8, mUploadedFile9, mUploadedFile10, mUploadedFile11
        ]
        
        for model in file_models:
            if model.objects.filter(structure=structure).exists():
                latest_file = model.objects.filter(structure=structure).latest('uploaded_at')
                break
        
        if not latest_file:
            print("DEBUG: No file found for structure")
            return []
        
        df = pd.read_excel(latest_file.file.path, engine='openpyxl')
        
        # Apply filter criteria
        filtered_df = df.copy()
        
        print(f"DEBUG: Original DataFrame shape: {df.shape}")
        print(f"DEBUG: Filter criteria: {filter_criteria}")
        print(f"DEBUG: Selected load cases: {selected_load_cases}")
        
        # NEW: Debug what values actually exist in the DataFrame
        if 'Set No.' in df.columns and 'Phase No.' in df.columns:
            unique_sets = df['Set No.'].dropna().unique()
            unique_phases = df['Phase No.'].dropna().unique()
            print(f"DEBUG: Unique Set values in data: {sorted([str(x) for x in unique_sets])}")
            print(f"DEBUG: Unique Phase values in data: {sorted([str(x) for x in unique_phases])}")
        
        if 'Load Case Description' in df.columns:
            unique_load_cases = df['Load Case Description'].dropna().unique()
            print(f"DEBUG: Unique Load Cases in data: {sorted([str(x) for x in unique_load_cases])}")
        
        # If no filter criteria and no selected load cases, return all data
        if not filter_criteria and not selected_load_cases:
            print("DEBUG: No filters applied, returning all data")
            # Convert to list of dictionaries
            result_data = []
            for _, row in filtered_df.iterrows():
                row_data = {}
                for col in filtered_df.columns:
                    if pd.notna(row[col]):
                        if pd.api.types.is_numeric_dtype(filtered_df[col]):
                            row_data[col] = float(row[col])
                        else:
                            row_data[col] = str(row[col])
                    else:
                        row_data[col] = '' if pd.api.types.is_string_dtype(filtered_df[col]) else 0
                result_data.append(row_data)
            return result_data
        
        # Filter by joint labels if present
        if filter_criteria and 'joint_labels' in filter_criteria and filter_criteria['joint_labels']:
            if 'Joint Label' in df.columns:
                # Convert joint labels to strings for comparison
                joint_labels = [str(label) for label in filter_criteria['joint_labels']]
                print(f"DEBUG: Filtering by joint labels: {joint_labels}")
                filtered_df = filtered_df[filtered_df['Joint Label'].astype(str).isin(joint_labels)]
                print(f"DEBUG: After joint filter: {filtered_df.shape}")
        
        # Filter by set+phase combinations if present - FIXED VERSION
        if filter_criteria and 'set_phase_combinations' in filter_criteria and filter_criteria['set_phase_combinations']:
            if 'Set No.' in df.columns and 'Phase No.' in df.columns:
                print(f"DEBUG: Filtering by {len(filter_criteria['set_phase_combinations'])} set+phase combinations")
                
                # Create a list to store filtered dataframes
                filtered_dfs = []
                
                for i, combo in enumerate(filter_criteria['set_phase_combinations']):
                    # Convert filter values to handle both integer and float representations
                    set_value = str(combo.get('set', ''))
                    phase_value = str(combo.get('phase', ''))
                    
                    # NEW: Handle float values in Excel data (e.g., '9' should match '9.0')
                    # Try to convert to float and then compare both string representations
                    try:
                        set_float = float(set_value)
                        phase_float = float(phase_value)
                        
                        # Create multiple comparison options
                        set_match = (
                            (filtered_df['Set No.'].astype(str) == set_value) |  # Exact string match
                            (filtered_df['Set No.'].astype(str) == str(set_float)) |  # Float string match
                            (filtered_df['Set No.'].astype(float) == set_float)  # Numeric match
                        )
                        
                        phase_match = (
                            (filtered_df['Phase No.'].astype(str) == phase_value) |  # Exact string match
                            (filtered_df['Phase No.'].astype(str) == str(phase_float)) |  # Float string match
                            (filtered_df['Phase No.'].astype(float) == phase_float)  # Numeric match
                        )
                        
                    except (ValueError, TypeError):
                        # If conversion fails, use string comparison only
                        set_match = (filtered_df['Set No.'].astype(str) == set_value)
                        phase_match = (filtered_df['Phase No.'].astype(str) == phase_value)
                    
                    print(f"DEBUG: Combination {i}: Looking for Set='{set_value}' (also trying as float), Phase='{phase_value}' (also trying as float)")
                    
                    # Filter for this specific combination
                    combo_filtered = filtered_df[set_match & phase_match]
                    
                    print(f"DEBUG: Found {len(combo_filtered)} records for this combination")
                    
                    if not combo_filtered.empty:
                        filtered_dfs.append(combo_filtered)
                        # Show sample of what was found
                        sample = combo_filtered[['Set No.', 'Phase No.', 'Load Case Description']].head(3)
                        print(f"DEBUG: Sample of found records:\n{sample.to_string()}")
                
                # Combine all filtered dataframes
                if filtered_dfs:
                    filtered_df = pd.concat(filtered_dfs, ignore_index=True)
                    print(f"DEBUG: After set+phase filter: {filtered_df.shape}")
                    
                    # Show final sample
                    if 'Set No.' in filtered_df.columns and 'Phase No.' in filtered_df.columns and 'Load Case Description' in filtered_df.columns:
                        sample_data = filtered_df[['Set No.', 'Phase No.', 'Load Case Description']].head(5)
                        print(f"DEBUG: Final sample of filtered data:\n{sample_data.to_string()}")
                else:
                    filtered_df = filtered_df.iloc[0:0]  # Empty dataframe
                    print(f"DEBUG: No matches found for any set+phase combinations")
        
        # Filter by selected load cases if provided
        if selected_load_cases and 'Load Case Description' in filtered_df.columns:
            print(f"DEBUG: Filtering by {len(selected_load_cases)} selected load cases: {selected_load_cases}")
            
            # Check which load cases actually exist in the current filtered data
            existing_load_cases = filtered_df['Load Case Description'].unique()
            print(f"DEBUG: Load cases in current filtered data: {sorted([str(x) for x in existing_load_cases])}")
            
            filtered_df = filtered_df[filtered_df['Load Case Description'].isin(selected_load_cases)]
            print(f"DEBUG: After load cases filter: {filtered_df.shape}")
        
        # Convert to list of dictionaries
        result_data = []
        for _, row in filtered_df.iterrows():
            row_data = {}
            for col in filtered_df.columns:
                if pd.notna(row[col]):
                    if pd.api.types.is_numeric_dtype(filtered_df[col]):
                        row_data[col] = float(row[col])
                    else:
                        row_data[col] = str(row[col])
                else:
                    row_data[col] = '' if pd.api.types.is_string_dtype(filtered_df[col]) else 0
            result_data.append(row_data)
        
        print(f"DEBUG: Final result data: {len(result_data)} records")
        return result_data
        
    except Exception as e:
        print(f"Error in apply_previous_selection_filter: {str(e)}")
        import traceback
        print(f"DEBUG: Traceback: {traceback.format_exc()}")
        return []
    
    
def get_filtered_grouped_data(structure_id, filter_criteria, selected_load_cases, selection_source, selected_groups=None):  # NEW: Add selected_groups param
    """Get filtered data with grouping structure"""
    try:
        structure = ListOfStructure.objects.get(id=structure_id)
        
        print(f"DEBUG get_filtered_grouped_data: structure_id={structure_id}")
        print(f"DEBUG get_filtered_grouped_data: filter_criteria={filter_criteria}")
        print(f"DEBUG get_filtered_grouped_data: selected_load_cases={selected_load_cases}")
        print(f"DEBUG get_filtered_grouped_data: selection_source={selection_source}")
        print(f"DEBUG get_filtered_grouped_data: selected_groups={selected_groups}") 
        
        # Get the filtered data
        filtered_data = apply_previous_selection_filter(structure_id, filter_criteria, selected_load_cases)
        
        print(f"DEBUG get_filtered_grouped_data: filtered_data count = {len(filtered_data)}")
        
        if not filtered_data:
            return {'grouped_data': {}, 'all_columns': [], 'record_count': 0, 'is_grouped': True}
        
        # Convert back to DataFrame for grouping
        import pandas as pd
        df = pd.DataFrame(filtered_data)
        
        # Get all columns
        all_columns = list(df.columns) if not df.empty else []
        
        grouped_data = {}
        
        if selection_source == 'group':
            # Group by prefix for group load cases
            for record in filtered_data:
                if 'Load Case Description' in record:
                    case_name = record['Load Case Description']
                    if ' ' in case_name:
                        group_name = case_name.split(' ')[0]
                    else:
                        group_name = case_name
                    
                    if group_name not in grouped_data:
                        grouped_data[group_name] = []
                    grouped_data[group_name].append(record)
        
        elif selection_source == 'custom':
            # NEW: If no groups selected, return empty
            if not selected_groups:
                print("DEBUG: No custom groups selected, returning empty grouped data")
                return {'grouped_data': {}, 'all_columns': all_columns, 'record_count': 0, 'is_grouped': True}
            
            # Group by custom group names
            custom_groups = LoadCaseGroup.objects.filter(
                structure=structure, 
                is_custom=True
            ).prefetch_related('load_cases')
            
            for group in custom_groups:
                group_name = group.name
                # Only include if group is in selected_groups
                if group_name not in selected_groups:
                    continue
                
                group_cases = [case.name for case in group.load_cases.all()]
                grouped_data[group_name] = []
                
                # Find records that belong to this custom group
                for record in filtered_data:
                    if 'Load Case Description' in record and record['Load Case Description'] in group_cases:
                        grouped_data[group.name].append(record)
                
                # Remove empty groups
                if not grouped_data[group.name]:
                    del grouped_data[group.name]
        
        else:  # imported - use flat structure but still group by load case for consistency
            for record in filtered_data:
                if 'Load Case Description' in record:
                    case_name = record['Load Case Description']
                    if case_name not in grouped_data:
                        grouped_data[case_name] = []
                    grouped_data[case_name].append(record)
        
        # Calculate total record count
        total_records = sum(len(records) for records in grouped_data.values())
        
        print(f"DEBUG get_filtered_grouped_data: Final grouped data - {total_records} records in {len(grouped_data)} groups")
        
        return {
            'grouped_data': grouped_data,
            'all_columns': all_columns,
            'record_count': total_records,
            'is_grouped': True
        }
        
    except Exception as e:
        print(f"Error in get_filtered_grouped_data: {str(e)}")
        import traceback
        print(f"DEBUG: Traceback: {traceback.format_exc()}")
        return {'grouped_data': {}, 'all_columns': [], 'record_count': 0, 'is_grouped': True}
    
def load_cases_page(request):
    """New dedicated page for Load Cases Selection and Load Values"""
    # Get selected values from session
    selected_values = request.session.get('selected_values', {})
    if isinstance(selected_values, list):
        print(f"‚ö†Ô∏è DEBUG load_cases_page: selected_values was a list, converting to dict")
        request.session['selected_values'] = {}
        selected_values = {}

    structure_id = selected_values.get('structure_id')
    selected_load_cases = selected_values.get('load_cases', [])
    
    # NEW: Get filter criteria from previous page
    filter_criteria = selected_values.get('filter_criteria', {})
    
    print(f"DEBUG load_cases_page: Session selected_values = {selected_values}")
    print(f"DEBUG: Filter criteria from session: {filter_criteria}")
    if 'set_phase_combinations' in filter_criteria:
        print(f"DEBUG: Number of combinations in filter_criteria: {len(filter_criteria['set_phase_combinations'])}")
        for i, combo in enumerate(filter_criteria['set_phase_combinations']):
            print(f"DEBUG: Combination {i}: Set={combo.get('set')}, Phase={combo.get('phase')}")
    
    # Handle load cases selection via AJAX only
    if request.method == 'POST' and 'load_cases_selection' in request.POST:
        if request.headers.get('x-requested-with') == 'XMLHttpRequest':
            selected_load_cases = request.POST.getlist('selected_load_cases')
            # Store selected load cases in session
            if 'selected_values' not in request.session:
                request.session['selected_values'] = {}
            request.session['selected_values']['load_cases'] = selected_load_cases
            request.session.modified = True
            
            # Return JSON response for AJAX requests
            return JsonResponse({'success': True, 'selected_cases': selected_load_cases})
    
    # NEW: Handle filter by previous selection
    if request.method == 'POST' and 'filter_by_previous' in request.POST:
        if request.headers.get('x-requested-with') == 'XMLHttpRequest':
            print(f"DEBUG: Filtering by previous selection")
            print(f"DEBUG: Session selected_values: {request.session.get('selected_values', {})}")
            
            # Get filter criteria directly from session
            session_values = request.session.get('selected_values', {})
            # NEW: Add this type check/conversion here
            if isinstance(session_values, list):
                print(f"‚ö†Ô∏è DEBUG load_cases_page (filter_by_previous): session_values was a list, converting to dict")
                request.session['selected_values'] = {}
                session_values = {}
            
            filter_criteria = session_values.get('filter_criteria', {})
            selected_load_cases = session_values.get('load_cases', [])
            
            selected_groups = request.POST.getlist('selected_groups') or []
            
            print(f"DEBUG: Filter criteria from session: {filter_criteria}")
            print(f"DEBUG: Selected load cases from session: {selected_load_cases}")
            print(f"DEBUG: Selected groups: {selected_groups}")
            
            # NEW: Determine selection source from the request
            selection_source = request.POST.get('selection_source', 'imported')
            print(f"DEBUG: Selection source for filtering: {selection_source}")
            
            # Apply filter criteria with grouping
            filtered_result = get_filtered_grouped_data(
                structure_id, 
                filter_criteria, 
                selected_load_cases,
                selection_source,
                selected_groups
            )
            
            print(f"DEBUG: Filtered grouped data - {filtered_result['record_count']} records in {len(filtered_result['grouped_data'])} groups")
            
            return JsonResponse({
                'success': True, 
                'grouped_data': filtered_result['grouped_data'],
                'all_columns': filtered_result['all_columns'],
                'record_count': filtered_result['record_count'],
                'is_grouped': True,
                'current_selected_cases': selected_load_cases,
                'selection_source': selection_source,
                'filter_criteria': filter_criteria  # Return filter criteria for frontend display
            })
    
    # AJAX handlers (moved from hdata1)
    if request.headers.get('x-requested-with') == 'XMLHttpRequest':
        return handle_load_cases_ajax(request)
    
    # Data processing for Load Values display
    load_data = []
    available_load_cases = []
    all_columns = []
    
    if structure_id:
        try:
            structure = ListOfStructure.objects.get(id=structure_id)
            
            # Try to get the latest file from different models
            latest_file = None
            file_models = [
                tUploadedFile6, hUploadedFile1, tUploadedFile1, tUploadedFile2,
                tUploadedFile3, tUploadedFile4, tUploadedFile5, hUploadedFile2,
                hUploadedFile3, hUploadedFile4, tUploadedFile7, tUploadedFile8,
                tUploadedFile9, tUploadedFile10, tUploadedFile11, UploadedFile1,
                UploadedFile22, mUploadedFile5, mUploadedFile6, mUploadedFile7,
                mUploadedFile8, mUploadedFile9, mUploadedFile10, mUploadedFile11
            ]
            
            for model in file_models:
                if model.objects.filter(structure=structure).exists():
                    latest_file = model.objects.filter(structure=structure).latest('uploaded_at')
                    break
            
            if latest_file:
                df = pd.read_excel(latest_file.file.path, engine='openpyxl')

                # Get available load cases for selection
                if 'Load Case Description' in df.columns:
                    available_load_cases = df['Load Case Description'].dropna().unique().tolist()

                # NEW: Apply filter criteria if available and no specific load cases selected
                if not selected_load_cases and filter_criteria:
                    filtered_load_cases = apply_previous_selection_filter(structure_id, filter_criteria)
                    if filtered_load_cases and 'Load Case Description' in df.columns:
                        df = df[df['Load Case Description'].isin(filtered_load_cases)]
                # Existing: Filter by selected load cases if any are selected
                elif selected_load_cases and 'Load Case Description' in df.columns:
                    df = df[df['Load Case Description'].isin(selected_load_cases)]

                # Prepare complete data for table display
                for _, row in df.iterrows():
                    row_data = {}
                    for col in df.columns:
                        if pd.notna(row[col]):
                            if pd.api.types.is_numeric_dtype(df[col]):
                                row_data[col] = float(row[col])
                            else:
                                row_data[col] = str(row[col])
                        else:
                            row_data[col] = '' if pd.api.types.is_string_dtype(df[col]) else 0
                    load_data.append(row_data)

                all_columns = list(df.columns)

        except Exception as e:
            print(f"Error processing Excel file: {str(e)}")

    # Handle calculation request
    if request.method == 'GET' and 'calculation_data' in request.GET:
        try:
            calculation_data = json.loads(request.GET.get('calculation_data', '[]'))
            return render(request, 'app1/calculation_results.html', {
                'calculation_data': calculation_data,
                'structure_id': structure_id
            })
        except json.JSONDecodeError:
            pass

    return render(request, 'app1/load_cases.html', {
        'load_data': load_data,
        'load_data_json': json.dumps(load_data),
        'selected_values': selected_values,
        'all_columns': all_columns,
        'available_load_cases': available_load_cases,
        'selected_load_cases': selected_load_cases,
        'structure_id': structure_id,
        'filter_criteria': filter_criteria,  # NEW: Pass filter criteria to template
    })
    
def get_filtered_load_data(request):
    """Get filtered load data based on selected load cases with grouping support"""
    if request.headers.get('x-requested-with') != 'XMLHttpRequest':
        return JsonResponse({'error': 'Invalid request'}, status=400)
    
    structure_id = request.GET.get('structure_id')
    selected_load_cases = request.GET.getlist('selected_load_cases') or []
    selected_groups = request.GET.getlist('selected_groups') or []
    selection_source = request.GET.get('selection_source', 'imported')  # NEW: Get selection source
    
    if not structure_id:
        return JsonResponse({'error': 'Structure ID is required'}, status=400)
    
    try:
        structure = ListOfStructure.objects.get(id=structure_id)
        
        # Try to get the latest file from different models
        latest_file = None
        file_models = [
            tUploadedFile6, hUploadedFile1, tUploadedFile1, tUploadedFile2,
            tUploadedFile3, tUploadedFile4, tUploadedFile5, hUploadedFile2,
            hUploadedFile3, hUploadedFile4, tUploadedFile7, tUploadedFile8,
            tUploadedFile9, tUploadedFile10, tUploadedFile11, UploadedFile1,
            UploadedFile22, mUploadedFile5, mUploadedFile6, mUploadedFile7,
            mUploadedFile8, mUploadedFile9, mUploadedFile10, mUploadedFile11
        ]
        
        for model in file_models:
            if model.objects.filter(structure=structure).exists():
                latest_file = model.objects.filter(structure=structure).latest('uploaded_at')
                break
        
        if latest_file:
            df = pd.read_excel(latest_file.file.path, engine='openpyxl')

            # Filter by selected load cases if any are selected
            if selected_load_cases and 'Load Case Description' in df.columns:
                df = df[df['Load Case Description'].isin(selected_load_cases)]

            # NEW: Handle grouped response for group/custom selection sources
            if selection_source in ['group', 'custom'] and selected_load_cases:
                return get_grouped_response(df, selected_load_cases, selection_source, structure, selected_groups)
            
            # Existing flat list response for imported source
            load_data = []
            all_columns = []
            
            # Prepare complete data for table display
            for _, row in df.iterrows():
                row_data = {}
                for col in df.columns:
                    if pd.notna(row[col]):
                        if pd.api.types.is_numeric_dtype(df[col]):
                            row_data[col] = float(row[col])
                        else:
                            row_data[col] = str(row[col])
                    else:
                        row_data[col] = '' if pd.api.types.is_string_dtype(df[col]) else 0
                load_data.append(row_data)

            all_columns = list(df.columns)
            
            return JsonResponse({
                'load_data': load_data,
                'all_columns': all_columns,
                'record_count': len(load_data),
                'is_grouped': False  # NEW: Indicate this is flat data
            })
        else:
            return JsonResponse({'error': 'No file found for this structure'}, status=404)
            
    except ListOfStructure.DoesNotExist:
        return JsonResponse({'error': 'Structure not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

# NEW: Function to create grouped response
def get_grouped_response(df, selected_load_cases, selection_source, structure, selected_groups=None):  # NEW: Add selected_groups param
    """Create grouped response for group/custom selection sources"""
    grouped_data = {}
    all_columns = list(df.columns)
    
    if selection_source == 'group':
        # Group by prefix for group load cases
        for case_name in selected_load_cases:
            if ' ' in case_name:
                group_name = case_name.split(' ')[0]
            else:
                group_name = case_name
                
            if group_name not in grouped_data:
                grouped_data[group_name] = []
            
            # Find matching rows for this load case
            case_rows = df[df['Load Case Description'] == case_name]
            for _, row in case_rows.iterrows():
                row_data = {}
                for col in df.columns:
                    if pd.notna(row[col]):
                        if pd.api.types.is_numeric_dtype(df[col]):
                            row_data[col] = float(row[col])
                        else:
                            row_data[col] = str(row[col])
                    else:
                        row_data[col] = '' if pd.api.types.is_string_dtype(df[col]) else 0
                grouped_data[group_name].append(row_data)
    
    elif selection_source == 'custom':
        # Group by custom group names
        custom_groups = LoadCaseGroup.objects.filter(
            structure=structure, 
            is_custom=True
        ).prefetch_related('load_cases')
        
        for group in custom_groups:
            group_name = group.name
            # NEW: Only include if group is in selected_groups
            if selected_groups and group_name not in selected_groups:
                continue
            
            group_cases = [case.name for case in group.load_cases.all()]
            # Check if any cases from this group are selected
            selected_group_cases = set(group_cases) & set(selected_load_cases)
            
            if selected_group_cases:
                grouped_data[group_name] = []
                for case_name in selected_group_cases:
                    # Find matching rows for this load case
                    case_rows = df[df['Load Case Description'] == case_name]
                    for _, row in case_rows.iterrows():
                        row_data = {}
                        for col in df.columns:
                            if pd.notna(row[col]):
                                if pd.api.types.is_numeric_dtype(df[col]):
                                    row_data[col] = float(row[col])
                                else:
                                    row_data[col] = str(row[col])
                            else:
                                row_data[col] = '' if pd.api.types.is_string_dtype(df[col]) else 0
                        grouped_data[group_name].append(row_data)
    
    # Calculate total record count
    total_records = sum(len(records) for records in grouped_data.values())
    
    return JsonResponse({
        'grouped_data': grouped_data,
        'all_columns': all_columns,
        'record_count': total_records,
        'is_grouped': True  # NEW: Indicate this is grouped data
    })
    
def get_all_load_cases(structure):
    """Get all available load cases from the database"""
    try:
        # Get all unique load case names from LoadCase model for this structure
        all_load_cases = LoadCase.objects.filter(
            structure=structure
        ).values_list('name', flat=True).distinct()
        
        return JsonResponse({'values': list(all_load_cases)})
        
    except Exception as e:
        return JsonResponse({'error': str(e)})

def handle_load_cases_ajax(request):
    """Handle all AJAX requests for load cases (moved from hdata1)"""
    structure_id = request.GET.get('structure_id') or request.POST.get('structure_id')
    
    if not structure_id:
        return JsonResponse({'error': 'Structure ID is required'}, status=400)
        
    try:
        structure = ListOfStructure.objects.get(id=structure_id)
        
        # Handle custom group creation
        if request.method == 'POST' and 'create_custom_group' in request.POST:
            group_name = request.POST.get('group_name')
            selected_cases = request.POST.getlist('selected_cases')
            
            if group_name and selected_cases:
                custom_group = LoadCaseGroup.objects.create(
                    name=group_name,
                    structure=structure,
                    is_custom=True
                )
                
                for case_name in selected_cases:
                    LoadCase.objects.create(
                        name=case_name,
                        group=custom_group,
                        structure=structure
                    )
                
                return JsonResponse({'success': True})
            return JsonResponse({'success': False, 'error': 'Group name and cases are required'})
        
        # Handle custom group deletion
        elif request.method == 'POST' and 'delete_custom_group' in request.POST:
            group_name = request.POST.get('group_name')
            
            if group_name:
                LoadCaseGroup.objects.filter(
                    structure=structure, 
                    name=group_name, 
                    is_custom=True
                ).delete()
                return JsonResponse({'success': True})
            return JsonResponse({'success': False, 'error': 'Group name is required'})
        
        # Handle custom group update
        elif request.method == 'POST' and 'update_custom_group' in request.POST:
            old_group_name = request.POST.get('old_group_name')
            new_group_name = request.POST.get('new_group_name')
            
            if old_group_name and new_group_name:
                groups = LoadCaseGroup.objects.filter(
                    structure=structure,
                    name=old_group_name,
                    is_custom=True
                )
                
                if not groups.exists():
                    return JsonResponse({'success': False, 'error': f'Group "{old_group_name}" not found'})
                
                for group in groups:
                    group.name = new_group_name
                    group.save()
                
                return JsonResponse({'success': True})
            return JsonResponse({'success': False, 'error': 'Old and new group names are required'})
        
        elif request.method == 'POST' and 'edit_custom_group' in request.POST:
            group_name = request.POST.get('group_name')
            selected_cases = request.POST.getlist('selected_cases[]')
            
            if group_name and selected_cases is not None:
                try:
                    # Get the custom group
                    group = LoadCaseGroup.objects.get(
                        structure=structure,
                        name=group_name,
                        is_custom=True
                    )
                    
                    # Clear existing load cases
                    group.load_cases.all().delete()
                    
                    # Add new load cases
                    for case_name in selected_cases:
                        LoadCase.objects.create(
                            name=case_name,
                            group=group,
                            structure=structure
                        )
                    
                    return JsonResponse({'success': True})
                    
                except LoadCaseGroup.DoesNotExist:
                    return JsonResponse({'success': False, 'error': f'Group "{group_name}" not found'})
                except Exception as e:
                    return JsonResponse({'success': False, 'error': str(e)})
            
            return JsonResponse({'success': False, 'error': 'Group name and cases are required'})
        
        # Handle GET requests for load case data
        elif request.method == 'GET':
            # Get filtered load data for table
            if request.GET.get('get_filtered_load_data'):
                return get_filtered_load_data(request)
            
            # Get imported load cases
            elif request.GET.get('get_load_cases'):
                return get_imported_load_cases(structure)
            
            # Get grouped load cases
            elif request.GET.get('get_grouped_load_cases'):
                return get_grouped_load_cases(structure)
            
            # Get custom groups
            elif request.GET.get('get_custom_groups_for_selection'):
                structure_id = request.GET.get('structure_id')
                print(f"DEBUG: Handling get_custom_groups_for_selection for structure_id: {structure_id}")  # NEW: Debug log
                if not structure_id:
                    return JsonResponse({'error': 'Structure ID is required'}, status=400)
                
                try:
                    structure = ListOfStructure.objects.get(id=structure_id)
                    return get_custom_groups(structure)
                except ListOfStructure.DoesNotExist:
                    print(f"DEBUG: Structure with ID {structure_id} not found")  # NEW: Debug log
                    return JsonResponse({'error': 'Structure not found'}, status=404)
            
            elif request.GET.get('get_all_load_cases'):
                return get_all_load_cases(structure)

    
    except ListOfStructure.DoesNotExist:
        return JsonResponse({'error': 'Structure not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)
    
    return JsonResponse({'error': 'Invalid request'}, status=400)"

this is hdata1.html 
" <div class="container">
        <h3>OVERHEAD LOAD DESIGN CRITERIA</h3>
        
        <div class="row">
            <!-- Left side - Selection Options (reduced width) -->
            <div class="col-md-4">
                {% if button_type == 'joint_labels' %}
                <!-- Show only joint labels section when joint labels button was clicked -->
                <div class="form-group">
                    <label for="joint-labels">Attachment Joint Labels:</label>
                    <div class="checkbox-list" id="joint-labels">
                        {% for label in joint_labels %}
                            <label draggable="true" class="drag-item" data-type="joint" data-value="{{ label }}">
                                <input type="checkbox" name="joint-labels" value="{{ label }}"> {{ label }}
                            </label>
                        {% endfor %}
                    </div>
                </div>
                {% elif button_type == 'set_phase' %}
                <!-- Show only set/phase sections when set/phase button was clicked -->
                <div class="form-group">
                    <label for="set-select">Set No.:</label>
                    <select id="set-select" class="form-control" multiple size="4">
                        {% for num in set_numbers %}
                            <option value="{{ num|floatformat:0 }}">{{ num|floatformat:0 }}</option>
                        {% endfor %}
                    </select>
                    <small class="form-text text-muted">Hold Ctrl/Cmd to select multiple sets</small>
                </div>

                <div class="form-group">
                    <label for="phase-select">Phase No.:</label>
                    <select id="phase-select" class="form-control" multiple size="4">
                        {% for num in phase_numbers %}
                            <option value="{{ num|floatformat:0 }}">{{ num|floatformat:0 }}</option>
                        {% endfor %}
                    </select>
                    <small class="form-text text-muted">Hold Ctrl/Cmd to select multiple phases</small>
                </div>
                <!-- Combination Builder Section -->
                <div class="form-group">
                    <label>Create Set-Phase Combinations:</label>
                    <div class="combination-builder">
                        <div class="selected-items mb-2">
                            <strong>Selected Sets:</strong> 
                            <span id="selected-sets-display">None</span>
                        </div>
                        <div class="selected-items mb-2">
                            <strong>Selected Phases:</strong> 
                            <span id="selected-phases-display">None</span>
                        </div>
                        <button id="create-all-combinations" class="btn btn-primary btn-sm">
                            Create All Combinations
                        </button>
                        <button id="create-single-combination" class="btn btn-success btn-sm">
                            Create Single Combination
                        </button>
                        <button id="clear-combinations" class="btn btn-secondary btn-sm">
                            Clear All
                        </button>
                    </div>
                </div>

                <!-- Active Combinations Display -->
                <div class="form-group">
                    <label>Active Combinations:</label>
                    <div id="active-combinations" class="active-combinations-list">
                        <!-- Combinations will be displayed here -->
                    </div>
                </div>
                {% endif %}
            </div>
            
            <!-- Right side - 3D Model Viewer (increased width) -->
            <div class="col-md-8">
                <div class="model-viewer-container">
                    <div style="position: absolute; top: 10px; right: 10px; z-index: 100;">
                        <button id="grid-toggle-btn" class="btn btn-warning btn-sm">
                            Hide Grid
                        </button>
                        <!-- Enhanced Control Panel -->
                        <div class="movement-controls-panel">
                        <h6 style="margin: 0 0 10px 0; color: #333;">Movement Controls</h6>

                        {% comment %} <!-- Drop Mode Selection -->
                            <div style="margin-bottom: 15px;">
                                <label style="display: block; font-size: 12px; margin-bottom: 5px; font-weight: bold;">Drop Mode:</label>
                                <select id="drop-mode" style="width: 100%; padding: 5px; font-size: 12px;">
                                    <option value="precise">Precise Placement</option>
                                    <option value="free">Free Placement</option>
                                </select>
                            </div>

                            <!-- Grid Snapping -->
                            <div style="margin-bottom: 15px;">
                                <label style="display: block; font-size: 12px; margin-bottom: 5px; font-weight: bold;">Grid Snapping:</label>
                                <select id="grid-snap" style="width: 100%; padding: 5px; font-size: 12px;">
                                    <option value="0.1">Fine (0.1)</option>
                                    <option value="0.25" selected>Medium (0.25)</option>
                                    <option value="0.5">Coarse (0.5)</option>
                                    <option value="0">Off</option>
                                </select>
                            </div> {% endcomment %}
                        
                        <!-- Movement Controls -->
                        <div style="margin-bottom: 10px;">
                            <label style="display: block; font-size: 12px; margin-bottom: 8px; font-weight: bold;">Arrow Movement:</label>
                            
                            <!-- Up/Down Controls -->
                            <div style="display: flex; justify-content: center; margin-bottom: 5px;">
                                <button class="movement-btn" data-axis="y" data-direction="1" style="margin: 0 5px;">‚Üë</button>
                            </div>
                            
                            <!-- Left/Right/Front/Back Controls -->
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <button class="movement-btn" data-axis="x" data-direction="-1" style="margin: 0 2px;">‚Üê</button>
                                
                                <div style="display: flex; flex-direction: column; align-items: center;">
                                    <button class="movement-btn" data-axis="z" data-direction="-1" style="margin: 2px 0; font-size: 10px;">Front</button>
                                    <button class="movement-btn" data-axis="z" data-direction="1" style="margin: 2px 0; font-size: 10px;">Back</button>
                                </div>
                                
                                <button class="movement-btn" data-axis="x" data-direction="1" style="margin: 0 2px;">‚Üí</button>
                            </div>
                            
                            <!-- Down Control -->
                            <div style="display: flex; justify-content: center; margin-top: 5px;">
                                <button class="movement-btn" data-axis="y" data-direction="-1" style="margin: 0 5px;">‚Üì</button>
                            </div>
                        </div>

                        <!-- Step Size -->
                        <div style="margin-bottom: 10px;">
                            <label style="display: block; font-size: 12px; margin-bottom: 5px; font-weight: bold;">Step Size:</label>
                            <input type="range" id="step-size" min="0.05" max="1" step="0.05" value="0.25" style="width: 100%;">
                            <span id="step-size-value" style="font-size: 11px; text-align: center; display: block;">0.25 units</span>
                        </div>

                        <!-- Selected Object Info -->
                        <div id="selected-info" style="font-size: 11px; color: #666; margin-top: 10px; padding-top: 10px; border-top: 1px solid #ddd;">
                            No object selected
                        </div>
                    </div>
                </div>
                    <canvas id="model-canvas"></canvas>
                    <div id="joint-markers-container"></div>
                    <div id="set-markers-container"></div>
                    <div id="phase-markers-container"></div>
                    <div id="load-displays-container"></div>
                </div>
            </div>
        </div>

        <div class="mb-3">
            <a href="{% url 'load_cases' %}" class="btn btn-outline-primary">
                ‚ö° Go to Load Cases Selection
            </a>
        </div>

        <!-- NEW: Compact Model Selection & Upload Section -->
        <div class="model-controls-container">
            <!-- Model Selection Card -->
            <div class="model-control-card">
                <div class="model-control-header">
                    <h6>Select 3D Tower Model</h6>
                </div>
                <div class="model-control-body">
                <form method="post" class="compact-form">
                    {% csrf_token %}
                    <div class="form-group-compact">
                        <label for="model-select">Model:</label>
                        <select name="selected_model" id="model-select" class="form-control-sm" onchange="this.form.submit()">
                            <option value="">-- Default Model --</option>
                            {% for model in available_models %}
                                <option value="{{ model.id }}" 
                                    {% if selected_model and selected_model.id == model.id %}selected{% endif %}>
                                    {{ model.name }}
                                </option>
                            {% endfor %}
                        </select>
                    </div>
                    <div class="model-status">
                        {% if selected_model %}
                            Currently viewing: <strong>{{ selected_model.name }}</strong>
                            {% if matching_model and selected_model.id == matching_model.id %}
                                <span class="badge badge-success ml-2">Auto-Matched</span>
                            {% else %}
                                <span class="badge badge-info ml-2">Manually Selected</span>
                            {% endif %}
                        {% else %}
                            Using default tower model
                        {% endif %}
                    </div>
                </form>
            </div>

            </div>

            <!-- Model Upload Card -->
            <div class="model-control-card">
    <div class="model-control-header">
        <h6>Upload New 3D Tower Model</h6>
    </div>
    <div class="model-control-body">
        <form method="post" enctype="multipart/form-data" class="compact-form">
            {% csrf_token %}
            <div class="form-row">
                <div class="form-group-compact">
                    <label for="model_name">Model Name:</label>
                    <input type="text" name="model_name" id="model_name" class="form-control-sm" placeholder="Enter model name" required>
                </div>
                <div class="form-group-compact">
                    <label for="tower_model_file">3D Model File:</label>
                    <div class="file-input-wrapper">
                        <input type="file" name="tower_model_file" id="tower_model_file" accept=".glb,.gltf" required>
                        <div class="file-input-display">
                            <span>Choose file...</span>
                            <span class="file-input-icon">üìÅ</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- ADD THESE FIELDS FOR CATEGORIZATION -->
            <div class="form-row">
                <div class="form-group-compact">
                    <label for="structure_type">Structure Type:</label>
                    <select name="structure_type" id="structure_type" class="form-control-sm" required>
                        <option value="">Select...</option>
                        <option value="towers">Towers</option>
                        <option value="hframes">H-Frames</option>
                        <option value="monopoles">Monopoles</option>
                    </select>
                </div>
                <div class="form-group-compact">
                    <label for="attachment_points">Attachment Points:</label>
                    <select name="attachment_points" id="attachment_points" class="form-control-sm" required>
                        <option value="">Select...</option>
                        <option value="deadend">Deadend</option>
                        <option value="tangent">Tangent</option>
                    </select>
                </div>
            </div>
            
            <div class="form-row">
                <div class="form-group-compact">
                    <label for="configuration">Configuration:</label>
                    <select name="configuration" id="configuration" class="form-control-sm" required>
                        <option value="">Select...</option>
                        <option value="vertical">Vertical</option>
                        <option value="horizontal">Horizontal</option>
                        <option value="delta">Delta</option>
                        <option value="hetic">Hetic</option>
                    </select>
                </div>
                <div class="form-group-compact">
                    <label for="circuit_type">Circuit Type:</label>
                    <select name="circuit_type" id="circuit_type" class="form-control-sm" required>
                        <option value="">Select...</option>
                        <option value="sc">Single Circuit</option>
                        <option value="dc">Double Circuit</option>
                        <option value="tc">Triple Circuit</option>
                    </select>
                </div>
            </div>
            
            <div class="form-group-compact">
                <button type="submit" class="btn-sm-compact btn-success-sm">Upload</button>
            </div>
            
            <div class="form-text">
                <small class="text-muted">Supported formats: .glb, .gltf (Max file size: 10MB)</small>
            </div>
        </form>
    </div>
</div>

        </div>
        
        <!-- Load Display Table - now placed below and full width -->
        <div id="load-display">
            <h5>Load Values</h5>
            <div class="btn-container">
                <button id="calculate-btn" class="calculation-btn" disabled>
                    <span>Calculate Selected Records</span>
                </button>
                <span id="selected-count" class="selected-count">0 selected</span>
            </div>

            <div class="table-container">
                <table class="table table-bordered" id="load-table">
                    <thead>
                        <tr>
                            <th>Select</th>
                            {% for column in all_columns %}
                                <th>{{ column }}</th>
                            {% endfor %}
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </div>

    <div class="modal fade" id="aheadBackModal" tabindex="-1" role="dialog" aria-labelledby="aheadBackModalLabel" aria-hidden="true">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="aheadBackModalLabel">Select Combination Direction</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">
                <p>Please select the direction for the following newly created Set-Phase combinations:</p>
                <ul id="new-combinations-list" class="list-group mb-3">
                    <!-- Combinations will be listed here -->
                </ul>
            </div>
            <div class="modal-footer">
                <!-- MODIFIED: Added Both button and updated styling -->
                <button type="button" class="btn btn-success" id="btn-ahead" data-dismiss="modal">Ahead</button>
                <button type="button" class="btn btn-warning" id="btn-back" data-dismiss="modal">Back</button>
            </div>
        </div>
    </div>
</div>
<div class="model-matching-info" style="background-color: #e8f5e8; padding: 15px; margin: 10px 0; border-radius: 5px; border-left: 4px solid #4CAF50;">
    <h5>üéØ 3D Model Matching</h5>
    
    <div class="row">
        <div class="col-md-6">
        <h6>User Selections:</h6>
        <ul>
            <li><strong>Structure Type:</strong> {{ session_structure_type|default:"Not set" }}</li>
            <li><strong>Attachment Points:</strong> {{ session_popup_selections.attachment_points|default:"Not set" }}</li>
            <li><strong>Configuration:</strong> {{ session_popup_selections.configuration|default:"Not set" }}</li>
            <li><strong>3-Phase Circuits:</strong> {{ session_circuit_definition.num_3_phase_circuits|default:"0" }}</li>
            <li><strong>Shield Wires:</strong> {{ session_circuit_definition.num_shield_wires|default:"0" }}</li>
            <li><strong>1-Phase Circuits:</strong> {{ session_circuit_definition.num_1_phase_circuits|default:"0" }}</li>
            <li><strong>Communication Cables:</strong> {{ session_circuit_definition.num_communication_cables|default:"0" }}</li>
            <li><strong>Total Circuits:</strong> 
                {% with num_3_phase=session_circuit_definition.num_3_phase_circuits|default:0|add:0 num_1_phase=session_circuit_definition.num_1_phase_circuits|default:0|add:0 num_comm=session_circuit_definition.num_communication_cables|default:0|add:0 %}
                    {{ num_3_phase|add:num_1_phase|add:num_comm }}
                {% endwith %}
            </li>
        </ul>
    </div>
        
        <div class="col-md-6">
            <h6>Matched 3D Model:</h6>
            {% if matching_model %}
                <div class="alert alert-success">
                    <strong>‚úì Model Found!</strong><br>
                    <strong>Name:</strong> {{ matching_model.name }}<br>
                    <strong>Type:</strong> {{ matching_model.get_structure_type_display }}<br>
                    <strong>Attachment:</strong> {{ matching_model.get_attachment_points_display|default:"-" }}<br>
                    <strong>Configuration:</strong> {{ matching_model.get_configuration_display|default:"-" }}<br>
                    <strong>Circuit:</strong> {{ matching_model.get_circuit_type_display|default:"-" }}
                </div>
            {% else %}
                <div class="alert alert-warning">
                    <strong>‚ö† No Exact Match Found</strong><br>
                    Using default model or manually selected model.
                </div>
            {% endif %}
        </div>
    </div>
</div>
<div class="session-debug" style="background-color: #e8f4f8; padding: 15px; margin: 10px 0; border-radius: 5px; border-left: 4px solid #2196F3;">
    <h5>üìä Session Data Summary</h5>
    
    <div class="row">
        <div class="col-md-6">
            <h6>Home Page Data:</h6>
            <ul>
               
                <li><strong>Active Popups:</strong> 
                    {% if session_active_popups %}
                        {{ session_active_popups|join:", " }}
                    {% else %}
                        None
                    {% endif %}
                </li>
            </ul>
            
            <h6>Popup Selections:</h6>
            <ul>
                {% for key, value in session_popup_selections.items %}
                    <li><strong>{{ key }}:</strong> {{ value }}</li>
                {% empty %}
                    <li>No popup selections</li>
                {% endfor %}
            </ul>
        </div>
        
        <div class="col-md-6">
            <h6>Circuit Definition Data:</h6>
            {% if session_circuit_definition %}
                <ul>
                    <li><strong>3-Phase Circuits:</strong> {{ session_circuit_definition.num_3_phase_circuits|default:"Not set" }}</li>
                    <li><strong>Shield Wires:</strong> {{ session_circuit_definition.num_shield_wires|default:"Not set" }}</li>
                    <li><strong>1-Phase Circuits:</strong> {{ session_circuit_definition.num_1_phase_circuits|default:"Not set" }}</li>
                    <li><strong>Communication Cables:</strong> {{ session_circuit_definition.num_communication_cables|default:"Not set" }}</li>
                  
                </ul>
            {% else %}
                <p>No circuit definition data available</p>
            {% endif %}
        </div>
    </div>
</div>

<script>
    // Load data passed from Django
    const loadData = JSON.parse('{{ load_data_json|escapejs }}');
    
    // Three.js variables
    let scene, camera, renderer, model, controls, raycaster, mouse;
    const jointMarkers = {};
    const selectedJoints = new Set();
    const loadDisplays = {};
    const setMarkers = {};
    const phaseMarkers = {};
    const selectedSets = new Set();
    const selectedPhases = new Set();
    let activeJoint = null;
    const selectedRecords = new Set();
    let allTableData = [];
    const setPhaseCombinations = new Map(); // Track all active combinations
    let combinationCounter = 0; // Counter to make each combination unique
    const activeCombinations = new Map();
    let currentDroppingItem = null; // Stores data of the label being dragged from the sidebar
    let combinationsToConfirm = []; 
    const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value;
    let gridHelpers = []; // Array to store all grid helpers
    let isGridVisible = true;
    let transformControls;
    let selectedObject = null;

    // NEW: Enhanced movement and drag variables
    let isDragging = false;
    let dragStartPosition = new THREE.Vector3();
    let currentDragObject = null;
    let dropMode = 'precise'; // 'precise' or 'free'
    let gridSnapValue = 0.25;
    let movementStep = 0.25;
    let isDragOverCanvas = false;
    
    document.addEventListener('DOMContentLoaded', function() {
    // Ensure the canvas container is visible and properly sized
    const canvasContainer = document.querySelector('.model-viewer-container');
    const canvas = document.getElementById('model-canvas');
    
    if (canvasContainer && canvas) {
        // Force the container to be visible and properly sized
        canvasContainer.style.display = 'block';
        canvas.style.display = 'block';
        
        // Initialize the model viewer regardless of button type
        initModelViewer();
        updateTable();
        
        // Initialize the appropriate selection based on button type
        {% if button_type == 'set_phase' %}
            initSetPhaseSelection();
        {% elif button_type == 'joint_labels' %}
            // Ensure joint labels functionality is initialized
            initJointLabelsSelection();
        {% endif %}
    }
});

// Add this function if it doesn't exist
function initJointLabelsSelection() {
    const jointContainer = document.getElementById('joint-labels');
    if (jointContainer) {
        jointContainer.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
            checkbox.addEventListener('change', function() {
                const jointValue = this.value;
                if (this.checked) {
                    selectedJoints.add(jointValue);
                    if (!jointMarkers[jointValue]) {
                        addJointMarker(jointValue);
                    }
                } else {
                    selectedJoints.delete(jointValue);
                    removeJointMarker(jointValue);
                }
                updateTable();
                syncSelectionsWithSession();
            });
        });
    }
}
    // Initialize the 3D model viewer
        // Initialize the 3D model viewer
    function initModelViewer() {
        // Existing scene setup code remains the same until after renderer creation...
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);

        const axesHelper = new THREE.AxesHelper(5);
        scene.add(axesHelper);

        const canvasContainer = document.querySelector('.model-viewer-container');
        camera = new THREE.PerspectiveCamera(75, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 1000);
        camera.position.set(5, 5, 5);

        const canvas = document.getElementById('model-canvas');
        renderer = new THREE.WebGLRenderer({
            canvas,
            antialias: true,
            alpha: true
        });

        updateRendererSize();
        initTransformControls();

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight2.position.set(-1, -1, -1);
        scene.add(directionalLight2);

        // Load GLB model
        const loader = new THREE.GLTFLoader();
        function loadTowerModel(modelUrl) {
    // Remove existing model if any
    if (model) {
        scene.remove(model);
        model = null;
    }
    
    loader.load(
        modelUrl,
        function (gltf) {
            model = gltf.scene;
            scene.add(model);
            console.log('‚úÖ Model loaded successfully:', modelUrl);
            
            // Center and scale model
            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            model.position.sub(center);
            
            create3DGridCage(box);
            model.rotation.y = Math.PI / 4;
            
            // Initialize event listeners
            initEnhancedEventListeners();
            animate();
        },
        undefined,
        function (error) {
            console.error('‚ùå Error loading model:', error);
            console.log('Trying to load fallback model...');
            
            // Try to load any available model as fallback
            {% if available_models and available_models.0 %}
                const fallbackUrl = "{{ available_models.0.get_file_url }}";
                console.log('Loading fallback model:', fallbackUrl);
                loadTowerModel(fallbackUrl);
            {% else %}
                // Ultimate fallback
                const defaultModelUrl = "{% static 'app1/images/powerTransmissionTower.glb' %}";
                console.log('Loading ultimate fallback model:', defaultModelUrl);
                loadTowerModel(defaultModelUrl);
            {% endif %}
        }
    );
}

{% if matching_model %}
    // Get URLs for both matched and selected models
    const matchedModelUrl = "{{ matching_model.get_file_url }}";
    const selectedModelUrl = "{{ selected_model.get_file_url|default:'' }}";
    
    console.log('üîç Model Loading Analysis:');
    console.log('  Matched Model:', "{{ matching_model.name }}", matchedModelUrl);
    console.log('  Selected Model:', "{{ selected_model.name|default:'None' }}", selectedModelUrl);
    
    // Verify they're the same
    if (selectedModelUrl && matchedModelUrl === selectedModelUrl) {
        console.log('‚úÖ Matched and selected models are the same');
        console.log('üéØ Auto-loading matched model:', matchedModelUrl);
        console.log('Model details:', {
            name: "{{ matching_model.name }}",
            type: "{{ matching_model.structure_type }}",
            attachment: "{{ matching_model.attachment_points }}",
            config: "{{ matching_model.configuration }}",
            circuit: "{{ matching_model.circuit_type }}"
        });
        loadTowerModel(matchedModelUrl);
    } else if (selectedModelUrl && selectedModelUrl !== matchedModelUrl) {
        console.log('‚ö†Ô∏è Matched and selected models differ!');
        console.log('Loading selected model (user choice overrides match):', selectedModelUrl);
        loadTowerModel(selectedModelUrl);
    } else {
        // No selected model, use matched model
        console.log('üéØ Auto-loading matched model:', matchedModelUrl);
        console.log('Model details:', {
            name: "{{ matching_model.name }}",
            type: "{{ matching_model.structure_type }}",
            attachment: "{{ matching_model.attachment_points }}",
            config: "{{ matching_model.configuration }}",
            circuit: "{{ matching_model.circuit_type }}"
        });
        loadTowerModel(matchedModelUrl);
    }
{% else %}
    // No matching model found, use selected or default
    {% if selected_model %}
        const selectedModelUrl = "{{ selected_model.get_file_url }}";
        console.log('üìå Loading manually selected model:', selectedModelUrl);
        loadTowerModel(selectedModelUrl);
    {% else %}
        const defaultModelUrl = "{% static 'app1/images/powerTransmissionTower.glb' %}";
        console.log('‚öô Loading default model:', defaultModelUrl);
        loadTowerModel(defaultModelUrl);
    {% endif %}
{% endif %}

// Function to load default model
function loadDefaultModel() {
    loader.load(
       modelUrl,
        function (gltf) {
            model = gltf.scene;
            scene.add(model);

            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            model.position.sub(center);

            create3DGridCage(box);
            model.rotation.y = Math.PI / 4;

            initEnhancedEventListeners();
            animate();
        },
        undefined,
        function (error) {
            console.error('Error loading default model:', error);
        }
    );
}


        window.addEventListener('resize', onWindowResize);
        renderer.domElement.addEventListener('click', onCanvasClick);
        
        // NEW: Add enhanced mouse event listeners for smooth dragging
        initEnhancedDragListeners();
    }

    function initEnhancedEventListeners() {
        // Drop mode selection
        const dropModeSelect = document.getElementById('drop-mode');
        if (dropModeSelect) {
            dropModeSelect.addEventListener('change', function(e) {
                dropMode = e.target.value;
            });
        }

        // Grid snapping
        const gridSnapSelect = document.getElementById('grid-snap');
        if (gridSnapSelect) {
            gridSnapSelect.addEventListener('change', function(e) {
                gridSnapValue = parseFloat(e.target.value);
            });
        }

        // Step size control
        const stepSizeInput = document.getElementById('step-size');
        const stepSizeValue = document.getElementById('step-size-value');
        if (stepSizeInput && stepSizeValue) {
            stepSizeInput.addEventListener('input', function(e) {
                movementStep = parseFloat(e.target.value);
                stepSizeValue.textContent = movementStep.toFixed(2) + ' units';
            });
        }

        // Movement buttons
        document.querySelectorAll('.movement-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                if (selectedObject) {
                    const axis = this.dataset.axis;
                    const direction = parseInt(this.dataset.direction);
                    moveSelectedObject(axis, direction * movementStep);
                }
            });
        });

        // Keyboard arrow key support
        document.addEventListener('keydown', function(event) {
            if (!selectedObject) return;
            
            const step = movementStep;
            switch(event.key) {
                case 'ArrowUp':
                    event.preventDefault();
                    moveSelectedObject('y', step);
                    break;
                case 'ArrowDown':
                    event.preventDefault();
                    moveSelectedObject('y', -step);
                    break;
                case 'ArrowLeft':
                    event.preventDefault();
                    moveSelectedObject('x', -step);
                    break;
                case 'ArrowRight':
                    event.preventDefault();
                    moveSelectedObject('x', step);
                    break;
                case 'PageUp':
                    event.preventDefault();
                    moveSelectedObject('z', step);
                    break;
                case 'PageDown':
                    event.preventDefault();
                    moveSelectedObject('z', -step);
                    break;
            }
        });
    }

    // NEW: Enhanced drag listeners for smooth dragging
    function initEnhancedDragListeners() {
        const canvas = renderer.domElement;
        
        // Improved drag start for markers
        document.addEventListener('mousedown', function(e) {
            if (e.target.classList.contains('value-marker')) {
                startMarkerDrag(e);
            }
        });

        // Enhanced canvas drag events
        canvas.addEventListener('dragover', function(e) {
            e.preventDefault();
            isDragOverCanvas = true;
            canvas.classList.add('drag-over');
            
            if (currentDroppingItem && dropMode === 'free') {
                // Update visual feedback for free placement
                updateDragPosition(e);
            }
        });

        canvas.addEventListener('dragleave', function() {
            isDragOverCanvas = false;
            canvas.classList.remove('drag-over');
        });

        canvas.addEventListener('drop', function(e) {
            e.preventDefault();
            isDragOverCanvas = false;
            canvas.classList.remove('drag-over');
            
            handleCanvasDrop(e);
        });
    }

    // NEW: Start dragging marker
    function startMarkerDrag(e) {
        const marker = e.target;
        const jointLabel = marker.dataset.jointLabel;
        const combinedId = marker.dataset.combinedId;
        
        if (jointLabel && jointMarkers[jointLabel]) {
            currentDragObject = jointMarkers[jointLabel].mesh;
        } else if (combinedId && setMarkers[combinedId]) {
            currentDragObject = setMarkers[combinedId].mesh;
        }
        
        if (currentDragObject) {
            isDragging = true;
            dragStartPosition.copy(currentDragObject.position);
            marker.classList.add('dragging');
            
            document.addEventListener('mousemove', onMarkerDrag);
            document.addEventListener('mouseup', stopMarkerDrag);
        }
    }

    // NEW: Handle marker dragging
    function onMarkerDrag(e) {
        if (!isDragging || !currentDragObject) return;
        
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        
        raycaster.setFromCamera(mouse, camera);
        
        // Create a plane at the object's current height for smooth dragging
        const dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -currentDragObject.position.y);
        const intersectionPoint = new THREE.Vector3();
        raycaster.ray.intersectPlane(dragPlane, intersectionPoint);
        
        if (intersectionPoint) {
            // Apply grid snapping if enabled
            if (gridSnapValue > 0) {
                intersectionPoint.x = Math.round(intersectionPoint.x / gridSnapValue) * gridSnapValue;
                intersectionPoint.y = Math.round(intersectionPoint.y / gridSnapValue) * gridSnapValue;
                intersectionPoint.z = Math.round(intersectionPoint.z / gridSnapValue) * gridSnapValue;
            }
            
            currentDragObject.position.copy(intersectionPoint);
        }
    }

    // NEW: Stop marker dragging
    function stopMarkerDrag() {
        isDragging = false;
        currentDragObject = null;
        
        document.querySelectorAll('.value-marker').forEach(marker => {
            marker.classList.remove('dragging');
        });
        
        document.removeEventListener('mousemove', onMarkerDrag);
        document.removeEventListener('mouseup', stopMarkerDrag);
    }

    // NEW: Move selected object with arrow controls
    function moveSelectedObject(axis, distance) {
        if (!selectedObject) return;
        
        const newPosition = selectedObject.object.position.clone();
        
        switch(axis) {
            case 'x':
                newPosition.x += distance;
                break;
            case 'y':
                newPosition.y += distance;
                break;
            case 'z':
                newPosition.z += distance;
                break;
        }
        
        // Apply grid snapping
        if (gridSnapValue > 0) {
            newPosition.x = Math.round(newPosition.x / gridSnapValue) * gridSnapValue;
            newPosition.y = Math.round(newPosition.y / gridSnapValue) * gridSnapValue;
            newPosition.z = Math.round(newPosition.z / gridSnapValue) * gridSnapValue;
        }
        
        selectedObject.object.position.copy(newPosition);
        
        // Update associated HTML elements
        updateObjectUI(selectedObject);
    }

    // NEW: Update UI when object moves
    function updateObjectUI(selectedObj) {
        const object = selectedObj.object;
        const value = selectedObj.value;
        const type = selectedObj.type;
        
        if (type === 'joint' && jointMarkers[value]) {
            updateMarkerPosition(object, jointMarkers[value].div);
            if (loadDisplays[value]) {
                updateLoadDisplayPosition(loadDisplays[value].div, object.position);
            }
        } else if (type === 'set-phase' && setMarkers[value]) {
            updateMarkerPosition(object, setMarkers[value].div);
        }
        
        updateSelectedInfo(selectedObj);
    }

    // NEW: Update selected object info panel
    function updateSelectedInfo(selectedObj) {
        const infoDiv = document.getElementById('selected-info');
        if (!infoDiv) return;
        
        const pos = selectedObj.object.position;
        infoDiv.innerHTML = `
            <strong>Selected:</strong> ${selectedObj.value}<br>
            <strong>Position:</strong><br>
            X: ${pos.x.toFixed(2)}<br>
            Y: ${pos.y.toFixed(2)}<br>
            Z: ${pos.z.toFixed(2)}
        `;
    }

    // NEW: Enhanced canvas drop handler
    function handleCanvasDrop(e) {
        let droppedData;
        try {
            droppedData = JSON.parse(e.dataTransfer.getData('text/plain'));
        } catch (error) {
            console.error('Error parsing dropped data:', error);
            return;
        }
        
        if (!droppedData) return;
        
        const itemType = droppedData.type;
        const itemValue = droppedData.value;
        
        if (dropMode === 'precise') {
            // Original precise placement logic
            handlePrecisePlacement(e, itemType, itemValue);
        } else {
            // NEW: Free placement logic
            handleFreePlacement(e, itemType, itemValue);
        }
        
        currentDroppingItem = null;
        renderer.domElement.style.cursor = 'grab';
    }

    // NEW: Handle free placement
    function handleFreePlacement(e, itemType, itemValue) {
        const rect = renderer.domElement.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        // Convert screen coordinates to 3D position
        const position = screenToWorldPosition(mouseX, mouseY);
        
        if (position) {
            placeItemAtPosition(itemType, itemValue, position);
            checkAndSelectSource(itemType, itemValue);
        }
    }

    // NEW: Convert screen coordinates to 3D world position
    function screenToWorldPosition(screenX, screenY) {
        const vector = new THREE.Vector3(
            (screenX / renderer.domElement.clientWidth) * 2 - 1,
            -(screenY / renderer.domElement.clientHeight) * 2 + 1,
            0.5
        );
        
        vector.unproject(camera);
        
        // Create a plane at a reasonable height for new objects
        const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        const direction = vector.sub(camera.position).normalize();
        const raycaster = new THREE.Raycaster(camera.position, direction);
        const intersectionPoint = new THREE.Vector3();
        
        if (raycaster.ray.intersectPlane(groundPlane, intersectionPoint)) {
            return intersectionPoint;
        }
        
        return null;
    }

    // NEW: Update drag position visual feedback
    function updateDragPosition(e) {
        // This can be enhanced to show a preview of where the item will be placed
        const rect = renderer.domElement.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        // Could add a temporary preview object here
    }

    // NEW: Generic function to place items at specific positions
    function placeItemAtPosition(itemType, itemValue, position) {
        if (itemType === 'joint') {
            addJointMarker(itemValue, position);
        } else if (itemType === 'set' || itemType === 'phase') {
            if (selectedSets.size === 0 || selectedPhases.size === 0) {
                showSelectionRequiredMessage();
                return;
            }
            const currentSet = Array.from(selectedSets).pop();
            const currentPhase = Array.from(selectedPhases).pop();
            addSetPhaseMarker(currentSet, currentPhase, position);
        }
    }

    // NEW: Check and select source checkbox
    function checkAndSelectSource(itemType, itemValue) {
        const checkbox = document.querySelector(`input[name="${getCheckboxName(itemType)}"][value="${itemValue}"]`);
        if (checkbox && !checkbox.checked) {
            checkbox.checked = true;
            const changeEvent = new Event('change');
            checkbox.dispatchEvent(changeEvent);
        }
    }

    // NEW: Helper function to get checkbox name
    function getCheckboxName(itemType) {
        switch(itemType) {
            case 'joint': return 'joint-labels';
            case 'set': return 'set-numbers';
            case 'phase': return 'phase-numbers';
            default: return '';
        }
    }

    function initTransformControls() {
        // Create transform controls
        transformControls = new THREE.TransformControls(camera, renderer.domElement);
        transformControls.setSize(0.8);
        transformControls.addEventListener('dragging-changed', function(event) {
            controls.enabled = !event.value;
        });
        
        // Hide initially
        transformControls.visible = false;
        scene.add(transformControls);
    }

    function toggleGrid() {
        isGridVisible = !isGridVisible;
        
        gridHelpers.forEach(grid => {
            grid.visible = isGridVisible;
        });
        
        // Update button text
        const gridToggleBtn = document.getElementById('grid-toggle-btn');
        if (gridToggleBtn) {
            gridToggleBtn.textContent = isGridVisible ? 'Hide Grid' : 'Show Grid';
            gridToggleBtn.className = isGridVisible ? 'btn btn-warning btn-sm' : 'btn btn-success btn-sm';
        }
    }

    // Function to clear all grids
    function clearAllGrids() {
        gridHelpers.forEach(grid => {
            scene.remove(grid);
        });
        gridHelpers = [];
    }

    // Function to create 3D grid cage
    function create3DGridCage(boundingBox) {
        const size = boundingBox.getSize(new THREE.Vector3());
        const center = boundingBox.getCenter(new THREE.Vector3());
        
        // Make grid slightly larger than model
        const gridSize = Math.max(size.x, size.y, size.z) * 1.2;
        const gridDivisions = 20;
        
        // Clear any existing grids
        clearAllGrids();
        
        // Create grids on different planes
        
        // XY Plane (front/back)
        const gridXY1 = new THREE.GridHelper(gridSize, gridDivisions, 0xff4444, 0xff8888);
        gridXY1.position.set(center.x, center.y, boundingBox.min.z - 1);
        gridXY1.rotation.x = Math.PI / 2;
        scene.add(gridXY1);
        gridHelpers.push(gridXY1);
        
        const gridXY2 = new THREE.GridHelper(gridSize, gridDivisions, 0xff4444, 0xff8888);
        gridXY2.position.set(center.x, center.y, boundingBox.max.z + 1);
        gridXY2.rotation.x = Math.PI / 2;
        scene.add(gridXY2);
        gridHelpers.push(gridXY2);
        
        // XZ Plane (ground/top)
        const gridXZ1 = new THREE.GridHelper(gridSize, gridDivisions, 0x44ff44, 0x88ff88);
        gridXZ1.position.set(center.x, boundingBox.min.y - 1, center.z);
        scene.add(gridXZ1);
        gridHelpers.push(gridXZ1);
        
        const gridXZ2 = new THREE.GridHelper(gridSize, gridDivisions, 0x44ff44, 0x88ff88);
        gridXZ2.position.set(center.x, boundingBox.max.y + 1, center.z);
        scene.add(gridXZ2);
        gridHelpers.push(gridXZ2);
        
        // YZ Plane (left/right)
        const gridYZ1 = new THREE.GridHelper(gridSize, gridDivisions, 0x4444ff, 0x8888ff);
        gridYZ1.position.set(boundingBox.min.x - 1, center.y, center.z);
        gridYZ1.rotation.z = Math.PI / 2;
        scene.add(gridYZ1);
        gridHelpers.push(gridYZ1);
        
        const gridYZ2 = new THREE.GridHelper(gridSize, gridDivisions, 0x4444ff, 0x8888ff);
        gridYZ2.position.set(boundingBox.max.x + 1, center.y, center.z);
        gridYZ2.rotation.z = Math.PI / 2;
        scene.add(gridYZ2);
        gridHelpers.push(gridYZ2);
        
        isGridVisible = true;
    }
    

        // NEW: Handle clicks on the 3D canvas for assigning labels
    function onCanvasClick(event) {
        event.preventDefault();

        // If we're using transform controls, don't process other clicks
        if (transformControls.dragging) return;

        const canvas = renderer.domElement;
        const rect = canvas.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        // If a label is being dropped from sidebar, place it
        if (currentDroppingItem) {
            const intersects = raycaster.intersectObjects(scene.children, true);

            if (intersects.length > 0) {
                const intersection = intersects[0];
                const point = intersection.point;

                const itemType = currentDroppingItem.type;
                const itemValue = currentDroppingItem.value;

                if (itemType === 'joint') {
                    addJointMarker(itemValue, point);
                } else if (itemType === 'set' || itemType === 'phase') {
                    if (selectedSets.size === 0 || selectedPhases.size === 0) {
                        showSelectionRequiredMessage();
                        return;
                    }
                    const currentSet = Array.from(selectedSets).pop();
                    const currentPhase = Array.from(selectedPhases).pop();
                    addSetPhaseMarker(currentSet, currentPhase, point);
                }

                // Check the source checkbox after dropping
                const checkbox = document.querySelector(`input[name="${itemType === 'joint' ? 'joint-labels' : (itemType === 'set' ? 'set-numbers' : 'phase-numbers')}"][value="${itemValue}"]`);
                if (checkbox) {
                    checkbox.checked = true;
                    const changeEvent = new Event('change');
                    checkbox.dispatchEvent(changeEvent);
                }

                currentDroppingItem = null;
                renderer.domElement.style.cursor = 'grab';
            }
            return;
        }

        // Handle selection of markers for transform controls
        const intersects = raycaster.intersectObjects(scene.children, true);
        
        // First, check if we clicked on transform controls
        const transformControlIntersects = raycaster.intersectObject(transformControls, true);
        if (transformControlIntersects.length > 0) {
            return; // Let transform controls handle the click
        }

        // Then check if we clicked on a marker
        let foundMarker = false;
        
        // Check joint markers
        Object.keys(jointMarkers).forEach(label => {
            if (jointMarkers[label].mesh === intersects[0]?.object) {
                selectObjectForTransform(jointMarkers[label].mesh, label, 'joint');
                foundMarker = true;
                return;
            }
        });
        
        // Check set-phase markers
        if (!foundMarker) {
            Object.keys(setMarkers).forEach(id => {
                if (setMarkers[id].mesh === intersects[0]?.object) {
                    selectObjectForTransform(setMarkers[id].mesh, id, 'set-phase');
                    foundMarker = true;
                    return;
                }
            });
        }

        // If clicked on empty space, deselect
        if (!foundMarker && intersects.length > 0) {
            deselectObject();
        }
    }

    function deselectObject() {
        if (selectedObject) {
            transformControls.detach();
            transformControls.visible = false;
            hideSelectionHighlight(selectedObject.object);
            selectedObject = null;
        }
    }

    // NEW: Show selection highlight
    function showSelectionHighlight(object) {
        // You can add visual feedback here, like changing color or adding outline
        if (object.material) {
            object.userData.originalColor = object.material.color.clone();
            object.material.color.set(0xffff00); // Yellow highlight
        }
    }

    // NEW: Hide selection highlight
    function hideSelectionHighlight(object) {
            if (object.material && object.userData.originalColor) {
                object.material.color.copy(object.userData.originalColor);
            }
        }

        // NEW: Select object for transform controls
        function selectObjectForTransform(object, value, type) {
        deselectObject();
        
        selectedObject = { object, value, type };
        transformControls.attach(object);
        transformControls.visible = true;
        
        transformControls.addEventListener('change', function() {
            updateObjectUI(selectedObject);
        });
        
        showSelectionHighlight(object);
        updateSelectedInfo(selectedObject);
    }
    
   

    // Setup part selection for the tower model
    function updateRendererSize() {
        const canvasContainer = document.querySelector('.model-viewer-container');
        if (canvasContainer && renderer) {
            const width = canvasContainer.clientWidth;
            const height = canvasContainer.clientHeight;
            console.log('Canvas container size:', width, height); // Add this line

            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        }
    }

        // Add a marker for a joint on the 3D model
    function addJointMarker(jointLabel, position = null) {
        if (jointMarkers[jointLabel]) return;

        const geometry = new THREE.SphereGeometry(0.06, 16, 16); // Same size as set/phase markers
        const material = new THREE.MeshBasicMaterial({ 
            color: 0xff0000, // Red color for joints
            transparent: true,
            opacity: 0.7
        });
        const sphere = new THREE.Mesh(geometry, material);

        if (position) {
            sphere.position.copy(position);
        } else {
            // Improved default positioning
            const markerCount = Object.keys(jointMarkers).length;
            const gridSize = Math.ceil(Math.sqrt(markerCount + 1));
            const row = Math.floor(markerCount / gridSize);
            const col = markerCount % gridSize;

            sphere.position.set(
                (col - gridSize / 2) * 0.8,
                2 + row * 0.4,
                (row - gridSize / 2) * 0.4
            );
        }

        // Create marker div - similar to set/phase markers
        const markerDiv = document.createElement('div');
        markerDiv.className = 'value-marker joint-marker';
        markerDiv.textContent = jointLabel;
        markerDiv.style.position = 'absolute';
        markerDiv.style.color = 'black';
        markerDiv.style.padding = '2px 5px';
        markerDiv.style.cursor = 'pointer';
        markerDiv.style.fontWeight = 'bold';
        markerDiv.style.pointerEvents = 'auto';
        markerDiv.dataset.jointLabel = jointLabel;
        document.getElementById('joint-markers-container').appendChild(markerDiv);

        // Click handler for selection - same as set/phase markers
        markerDiv.addEventListener('click', function(e) {
            e.stopPropagation();
            selectObjectForTransform(sphere, jointLabel, 'joint');
        });

        jointMarkers[jointLabel] = {
            mesh: sphere,
            div: markerDiv,
            originalScale: 1
        };

        scene.add(sphere);
        updateMarkerPosition(sphere, markerDiv);
    }

    // MODIFIED: addSetPhaseMarker - add selection capability
    function addSetPhaseMarker(setNumber, phaseNumber, position = null) {
    const combination = Array.from(activeCombinations.values()).find(comb => 
        comb.set === setNumber && comb.phase === phaseNumber
    );
    
    if (!combination) return null;

    const uniqueId = `${combination.id}_${Date.now()}`;
    
    // Your existing marker creation code here (keep the same)
    const geometry = new THREE.SphereGeometry(0.06, 16, 16);
    const material = new THREE.MeshBasicMaterial({ 
        color: 0x0000ff,
        transparent: true,
        opacity: 0.7
    });
    const sphere = new THREE.Mesh(geometry, material);

    if (position) {
        sphere.position.copy(position);
    } else {
        const markerCount = Object.keys(setMarkers).length;
        const gridSize = Math.ceil(Math.sqrt(markerCount + 1));
        const row = Math.floor(markerCount / gridSize);
        const col = markerCount % gridSize;

        sphere.position.set(
            (col - gridSize / 2) * 0.8,
            2 + row * 0.4,
            (row - gridSize / 2) * 0.4
        );
    }

    // Create HTML marker (your existing code)
    const markerDiv = document.createElement('div');
    markerDiv.className = 'value-marker set-phase-marker';
    markerDiv.textContent = `${setNumber}:${phaseNumber}`;
    markerDiv.style.position = 'absolute';
    markerDiv.style.color = 'black';
    markerDiv.style.padding = '2px 5px';
    markerDiv.style.cursor = 'pointer';
    markerDiv.style.fontWeight = 'bold';
    markerDiv.style.pointerEvents = 'auto';
    markerDiv.dataset.combinedId = uniqueId;
    markerDiv.dataset.baseCombination = `${setNumber}:${phaseNumber}`;
    document.getElementById('set-markers-container').appendChild(markerDiv);

    markerDiv.addEventListener('click', function(e) {
        e.stopPropagation();
        selectObjectForTransform(sphere, uniqueId, 'set-phase');
    });

    // Store the marker
    setMarkers[uniqueId] = {
        mesh: sphere,
        div: markerDiv,
        setNumber: setNumber,
        phaseNumber: phaseNumber,
        baseCombination: `${setNumber}:${phaseNumber}`,
        uniqueId: uniqueId,
        combinationId: combination.id,
        originalScale: 1
    };

    scene.add(sphere);
    updateMarkerPosition(sphere, markerDiv);
    
    return uniqueId;
}

    // Add CSS for better cursor feedback
    const style = document.createElement('style');
    style.textContent = `
        .value-marker:hover {
            transform: scale(1.1);
            transition: transform 0.2s ease;
        }
        
        #model-canvas.grabbing {
            cursor: grabbing !important;
        }
    `;
    document.head.appendChild(style);

    // Function to show combination created message
    function showCombinationCreatedMessage(combination) {
        let messageDiv = document.getElementById('combination-created-message');
        if (!messageDiv) {
            messageDiv = document.createElement('div');
            messageDiv.id = 'combination-created-message';
            messageDiv.style.position = 'fixed';
            messageDiv.style.top = '20px';
            messageDiv.style.right = '20px';
            messageDiv.style.background = '#e8f5e8';
            messageDiv.style.color = '#2e7d32';
            messageDiv.style.padding = '12px 18px';
            messageDiv.style.border = '2px solid #4caf50';
            messageDiv.style.borderRadius = '6px';
            messageDiv.style.zIndex = '1000';
            messageDiv.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
            messageDiv.style.fontWeight = 'bold';
            document.body.appendChild(messageDiv);
        }
        
        messageDiv.innerHTML = `‚úÖ Created combination: ${combination}`;
        messageDiv.style.display = 'block';
        
        setTimeout(() => {
            messageDiv.style.display = 'none';
        }, 2000);
    }

    // Function to remove a set:phase marker
    function removeSetPhaseMarker(uniqueId) {
        if (!setMarkers[uniqueId]) return;
        
        scene.remove(setMarkers[uniqueId].mesh);
        if (setMarkers[uniqueId].div && setMarkers[uniqueId].div.parentNode) {
            document.getElementById('set-markers-container').removeChild(setMarkers[uniqueId].div);
        }
        delete setMarkers[uniqueId];
        updateTable(); // Refresh the table after removal
    }

    // Function to create new set:phase combination
    function createSetPhaseCombination() {
        if (selectedSets.size === 0 || selectedPhases.size === 0) {
            showSelectionRequiredMessage();
            return;
        }
        
        // Get the currently selected set and phase
        const currentSet = Array.from(selectedSets).pop();
        const currentPhase = Array.from(selectedPhases).pop();
        
        if (currentSet && currentPhase) {
            // Always create new combination, even if same set:phase exists
            addSetPhaseMarker(currentSet, currentPhase);
            
            // Don't clear phase selection - allow creating multiple of same combination
            updateTable();
        }
    }

    // Function to show selection required message
    function showSelectionRequiredMessage() {
        let messageDiv = document.getElementById('selection-required-message');
        if (!messageDiv) {
            messageDiv = document.createElement('div');
            messageDiv.id = 'selection-required-message';
            messageDiv.style.position = 'fixed';
            messageDiv.style.top = '20px';
            messageDiv.style.right = '20px';
            messageDiv.style.background = '#fff3e0';
            messageDiv.style.color = '#ef6c00';
            messageDiv.style.padding = '12px 18px';
            messageDiv.style.border = '2px solid #ff9800';
            messageDiv.style.borderRadius = '6px';
            messageDiv.style.zIndex = '1000';
            messageDiv.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
            messageDiv.style.fontWeight = 'bold';
            document.body.appendChild(messageDiv);
        }
        
        messageDiv.innerHTML = "‚ö†Ô∏è Please select both a Set and a Phase first";
        messageDiv.style.display = 'block';
        
        setTimeout(() => {
            messageDiv.style.display = 'none';
        }, 3000);
    }

    // Clear all set:phase combinations
    function clearAllSetPhaseCombinations() {
        Object.keys(setMarkers).forEach(uniqueId => {
            removeSetPhaseMarker(uniqueId);
        });
        combinationCounter = 0; // Reset counter
    }

    // Get combinations by base type (for table display)
    function getCombinationsByBaseType() {
        const combinationsByType = {};
        
        Object.values(setMarkers).forEach(marker => {
            const baseCombination = marker.baseCombination;
            if (!combinationsByType[baseCombination]) {
                combinationsByType[baseCombination] = [];
            }
            combinationsByType[baseCombination].push(marker);
        });
        
        return combinationsByType;
    }


    
    // Update HTML marker position based on 3D position
    function updateMarkerPosition(mesh, div) {
        // Get the marker reference (either joint or set-phase)
        const isJoint = div.classList.contains('joint-marker');
        const markerRef = isJoint ? jointMarkers[div.dataset.jointLabel] : setMarkers[div.dataset.combinedId];
        if (!markerRef) return;

        const vector = mesh.position.clone();
        vector.project(camera);

        const x = (vector.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
        const y = (-(vector.y * 0.5) + 0.5) * renderer.domElement.clientHeight;

        div.style.left = `${x}px`;
        div.style.top = `${y}px`;
        div.style.transform = 'translate(-50%, -50%)'; // This is crucial


        // NEW: Implement scaling based on distance from camera
        const distance = camera.position.distanceTo(mesh.position);
        // This factor needs tuning based on your scene scale and desired visual
        // A smaller factor means labels scale less dramatically with distance
        const scaleFactor = 100 / distance; // Inverse distance for scaling
        const baseFontSize = markerRef.fontSize || 12; // Use stored fontSize or default
        div.style.fontSize = `${baseFontSize * scaleFactor}px`;

        // Optional: adjust opacity based on distance or if it's behind the camera
        // if (vector.z > 1) { // Behind the camera
        //     div.style.display = 'none';
        // } else {
        //     div.style.display = 'block';
        // }
    }

    // Update load display position based on 3D position
    function updateLoadDisplayPosition(div, position) {
        const vector = position.clone();
        vector.project(camera);
        
        const x = (vector.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
        const y = (-(vector.y * 0.5) + 0.5) * renderer.domElement.clientHeight;
        
        div.style.left = `${x + 20}px`; // Offset slightly from the marker
        div.style.top = `${y}px`;
    }

    function removeJointMarker(jointLabel) {
        if (!jointMarkers[jointLabel]) return;
        
        scene.remove(jointMarkers[jointLabel].mesh);
        document.getElementById('joint-markers-container').removeChild(jointMarkers[jointLabel].div);
        delete jointMarkers[jointLabel];
    }

    
    function animate() {
        requestAnimationFrame(animate);
        
        if (!transformControls.dragging) {
            controls.update();
        }

        // Update marker positions - only markers, no load displays
        for (const jointLabel in jointMarkers) {
            updateMarkerPosition(jointMarkers[jointLabel].mesh, jointMarkers[jointLabel].div);
        }

        for (const combinedId in setMarkers) {
            updateMarkerPosition(setMarkers[combinedId].mesh, setMarkers[combinedId].div);
        }

        renderer.render(scene, camera);
    }

    document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape') {
            deselectObject();
        }
    });
    
    function onWindowResize() {
    updateRendererSize();

    // Update all marker positions
    for (const label in jointMarkers) {
        updateMarkerPosition(jointMarkers[label].mesh, jointMarkers[label].div);
    }
    for (const combinedId in setMarkers) {
        updateMarkerPosition(setMarkers[combinedId].mesh, setMarkers[combinedId].div);
    }

    }
    
    // Clear table
    function clearTable() {
        document.getElementById('load-table').getElementsByTagName('tbody')[0].innerHTML = '';
    }


    function handleRecordSelection(e) {
    const index = parseInt(e.target.dataset.index);
    const record = allTableData[index];
    
    if (e.target.checked) {
        selectedRecords.add(record);
    } else {
        selectedRecords.delete(record);
    }
    
    updateSelectedCount();
}

function updateSelectedCount() {
    const selectedCount = document.getElementById('selected-count');
    const calculateBtn = document.getElementById('calculate-btn');
    
    selectedCount.textContent = `${selectedRecords.size} selected`;
    calculateBtn.disabled = selectedRecords.size === 0;
}

// Add event listener for calculate button
// Update the calculate button event listener
document.getElementById('calculate-btn').addEventListener('click', function() {
    if (selectedRecords.size > 0) {
        // Prepare data for calculation - convert Set to Array
        const calculationData = Array.from(selectedRecords);
        
        // Create a form to submit the data via POST (FIX for 414 error)
        const form = document.createElement('form');
        form.method = 'POST';
        form.action = "{% url 'calculation' %}";  // Make sure this matches your URL name
        form.target = '_blank';
        form.style.display = 'none';
        
        // Add CSRF token for Django POST requests
        const csrfToken = document.createElement('input');
        csrfToken.type = 'hidden';
        csrfToken.name = 'csrfmiddlewaretoken';
        csrfToken.value = '{{ csrf_token }}';
        form.appendChild(csrfToken);
        
        // Add calculation data
        const input = document.createElement('input');
        input.type = 'hidden';
        input.name = 'calculation_data';
        input.value = JSON.stringify(calculationData);
        form.appendChild(input);
        
        document.body.appendChild(form);
        form.submit();
        document.body.removeChild(form);
    }
});

    
    
// Update table with selected labels
function updateTable() {
    clearTable();
    const tbody = document.getElementById('load-table').getElementsByTagName('tbody')[0];
    
    const columns = Array.from(document.querySelectorAll('#load-table thead th'))
        .map(th => th.textContent.trim())
        .filter(col => col !== 'Select');
    
    allTableData = [];
    
    // SECTION 1: Show all load cases records
    loadData.forEach((item, index) => {
        const row = tbody.insertRow();
        const dataIndex = allTableData.length;
        allTableData.push(item);
        
        const checkboxCell = row.insertCell();
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'record-checkbox';
        checkbox.dataset.index = dataIndex;
        checkbox.addEventListener('change', handleRecordSelection);
        checkboxCell.appendChild(checkbox);
        
        columns.forEach(column => {
            const cell = row.insertCell();
            cell.textContent = item[column] !== undefined ? item[column] : '';
        });
    });
    
    // SECTION 2: Show created set:phase combinations from activeCombinations
    {% if button_type == 'set_phase' %}
        if (activeCombinations.size > 0) {
            console.log('=== PROCESSING COMBINATIONS ===');
            console.log('Total active combinations:', activeCombinations.size);
            console.log('Active combinations:', Array.from(activeCombinations.values()));
            
            const separatorRow = tbody.insertRow();
            const separatorCell = separatorRow.insertCell();
            separatorCell.colSpan = columns.length + 1;
            separatorCell.innerHTML = '<hr style="margin: 20px 0; border-color: #ccc;">';
            separatorCell.style.backgroundColor = '#f8f9fa';
            
            const headerRow = tbody.insertRow();
            const headerCell = headerRow.insertCell();
            headerCell.colSpan = columns.length + 1;
            headerCell.textContent = 'CREATED COMBINATIONS';
            headerCell.style.textAlign = 'center';
            headerCell.style.backgroundColor = '#007bff';
            headerCell.style.color = 'white';
            headerCell.style.fontWeight = 'bold';
            headerCell.style.fontSize = '16px';
            
            // Convert activeCombinations to array to ensure we process ALL
            const combinationsArray = Array.from(activeCombinations.values());
            let displayedCombinationCount = 0;
            
            console.log('Processing combinations array:', combinationsArray);
            
            // Process EACH combination individually
            combinationsArray.forEach((combination, index) => {
                const setNum = combination.set;
                const phaseNum = combination.phase;
                const combinationId = combination.id;
                const combinationDisplay = combination.displayText;
                
                console.log(`Processing combination ${index + 1}: ${combinationDisplay} (ID: ${combinationId})`);
                
                // Find ALL matching records for this specific set/phase combination
                const matchingRecords = loadData.filter(item => {
                    const itemSet = item['Set No.'] !== undefined ? String(item['Set No.']) : '';
                    const itemPhase = item['Phase No.'] !== undefined ? String(item['Phase No.']) : '';
                    
                    const matches = itemSet === String(setNum) && itemPhase === String(phaseNum);
                    
                    if (matches) {
                        console.log(`‚úì Found match for ${combinationDisplay}:`, {
                            set: itemSet,
                            phase: itemPhase,
                            loadCase: item['Load Case Description']
                        });
                    }
                    
                    return matches;
                });
                
                console.log(`Records found for ${combinationDisplay}: ${matchingRecords.length}`);
                
                if (matchingRecords.length > 0) {
                    displayedCombinationCount++;
                    
                    // Group records by Load Case for this specific combination
                    const recordsByLoadCase = {};
                    
                    matchingRecords.forEach(record => {
                        const loadCase = record['Load Case Description'] || 'Uncategorized';
                        if (!recordsByLoadCase[loadCase]) {
                            recordsByLoadCase[loadCase] = [];
                        }
                        recordsByLoadCase[loadCase].push(record);
                    });
                    
                    // Create combination header
                    const combHeaderRow = tbody.insertRow();
                    const combHeaderCell = combHeaderRow.insertCell();
                    combHeaderCell.colSpan = columns.length + 1;
                    combHeaderCell.style.backgroundColor = '#e3f2fd';
                    combHeaderCell.style.borderLeft = '4px solid #1976d2';
                    combHeaderCell.style.padding = '10px';
                    combHeaderCell.style.fontWeight = 'bold';
                    combHeaderCell.style.fontSize = '14px';
                    
                    const combCheckbox = document.createElement('input');
                    combCheckbox.type = 'checkbox';
                    combCheckbox.className = 'combination-checkbox';
                    combCheckbox.dataset.combinationId = combinationId;
                    combCheckbox.checked = true;
                    combCheckbox.addEventListener('change', function(e) {
                        toggleCombinationSelection(combinationId, e.target.checked);
                    });
                    
                    const combLabel = document.createElement('span');
                    combLabel.style.marginLeft = '8px';
                    combLabel.textContent = `Combination ${displayedCombinationCount}: Set ${setNum} - Phase ${phaseNum}`;
                    
                    combHeaderCell.appendChild(combCheckbox);
                    combHeaderCell.appendChild(combLabel);
                    
                    // Display records for each load case in this combination
                    Object.keys(recordsByLoadCase).forEach(loadCase => {
                        const loadCaseRecords = recordsByLoadCase[loadCase];
                        
                        // Load Case sub-header
                        const loadCaseHeaderRow = tbody.insertRow();
                        const loadCaseHeaderCell = loadCaseHeaderRow.insertCell();
                        loadCaseHeaderCell.colSpan = columns.length + 1;
                        loadCaseHeaderCell.style.backgroundColor = '#f5f5f5';
                        loadCaseHeaderCell.style.padding = '8px 12px';
                        loadCaseHeaderCell.style.fontWeight = 'bold';
                        loadCaseHeaderCell.style.fontSize = '13px';
                        
                        const loadCaseCheckbox = document.createElement('input');
                        loadCaseCheckbox.type = 'checkbox';
                        loadCaseCheckbox.className = 'loadcase-checkbox';
                        loadCaseCheckbox.dataset.combinationId = combinationId;
                        loadCaseCheckbox.dataset.loadCase = loadCase;
                        loadCaseCheckbox.checked = true;
                        loadCaseCheckbox.addEventListener('change', function(e) {
                            toggleLoadCaseSelection(combinationId, loadCase, e.target.checked);
                        });
                        
                        const loadCaseLabel = document.createElement('span');
                        loadCaseLabel.style.marginLeft = '8px';
                        loadCaseLabel.textContent = `Load Case: ${loadCase}`;
                        
                        loadCaseHeaderCell.appendChild(loadCaseCheckbox);
                        loadCaseHeaderCell.appendChild(loadCaseLabel);
                        
                        // Display individual records
                        loadCaseRecords.forEach(record => {
                            const row = tbody.insertRow();
                            const dataIndex = allTableData.length;
                            allTableData.push(record);
                            
                            const checkboxCell = row.insertCell();
                            const checkbox = document.createElement('input');
                            checkbox.type = 'checkbox';
                            checkbox.className = 'record-checkbox';
                            checkbox.dataset.index = dataIndex;
                            checkbox.dataset.combinationId = combinationId;
                            checkbox.dataset.loadCase = loadCase;
                            checkbox.checked = true;
                            checkbox.addEventListener('change', handleRecordSelection);
                            checkboxCell.appendChild(checkbox);
                            
                            columns.forEach(column => {
                                const cell = row.insertCell();
                                // Highlight combination info
                                if (column === 'Set No.' || column === 'Phase No.') {
                                    cell.style.fontWeight = 'bold';
                                    cell.style.backgroundColor = '#f0f8ff';
                                }
                                cell.textContent = record[column] !== undefined ? record[column] : '';
                            });
                            
                            // Auto-select this record
                            selectedRecords.add(record);
                        });
                    });
                    
                    // Add small spacer between combinations
                    if (index < combinationsArray.length - 1) {
                        const spacerRow = tbody.insertRow();
                        const spacerCell = spacerRow.insertCell();
                        spacerCell.colSpan = columns.length + 1;
                        spacerCell.style.padding = '10px';
                        spacerCell.style.backgroundColor = '#f8f9fa';
                    }
                } else {
                    console.log(`‚ùå No records found for ${combinationDisplay}`);
                    
                    // Show combination with no data message
                    const noDataRow = tbody.insertRow();
                    const noDataCell = noDataRow.insertCell();
                    noDataCell.colSpan = columns.length + 1;
                    noDataCell.style.backgroundColor = '#fff3cd';
                    noDataCell.style.padding = '10px';
                    noDataCell.style.color = '#856404';
                    noDataCell.style.fontStyle = 'italic';
                    noDataCell.textContent = `Combination: Set ${setNum} - Phase ${phaseNum} - No matching records found in data`;
                }
            });
            
            console.log(`=== DISPLAYED ${displayedCombinationCount} COMBINATIONS ===`);
            
            // If no combinations had data at all
            if (displayedCombinationCount === 0) {
                const noDataRow = tbody.insertRow();
                const noDataCell = noDataRow.insertCell();
                noDataCell.colSpan = columns.length + 1;
                noDataCell.textContent = 'No matching records found in the data for any created combinations.';
                noDataCell.style.textAlign = 'center';
                noDataCell.style.color = '#666';
                noDataCell.style.fontStyle = 'italic';
                noDataCell.style.padding = '20px';
            }
        } else {
            console.log('No active combinations found');
        }
    {% endif %}
    
    // SECTION 3: Show attachment joint label records in combinations (for both modes)
    const selectedJointLabels = Array.from(selectedJoints);
    if (selectedJointLabels.length > 0) {
        // Add a separator row
        const separatorRow = tbody.insertRow();
        const separatorCell = separatorRow.insertCell();
        separatorCell.colSpan = columns.length + 1;
        separatorCell.innerHTML = '<hr style="margin: 20px 0; border-color: #ccc;">';
        separatorCell.style.backgroundColor = '#f8f9fa';
        
        // Add joint labels section header
        const headerRow = tbody.insertRow();
        const headerCell = headerRow.insertCell();
        headerCell.colSpan = columns.length + 1;
        headerCell.textContent = 'ATTACHMENT JOINT LABELS';
        headerCell.style.textAlign = 'center';
        headerCell.style.backgroundColor = '#28a745';
        headerCell.style.color = 'white';
        headerCell.style.fontWeight = 'bold';
        headerCell.style.fontSize = '16px';
        
        // Show records for each selected joint label
        selectedJointLabels.forEach(label => {
            const matchingRecords = loadData.filter(item => 
                String(item['Attach. Joint Labels']) === String(label)
            );
            
            if (matchingRecords.length > 0) {
                // Add a sub-header row for the joint label
                const jointHeaderRow = tbody.insertRow();
                const jointHeaderCell = jointHeaderRow.insertCell();
                jointHeaderCell.colSpan = columns.length + 1;
                jointHeaderCell.textContent = `Joint Label: ${label}`;
                jointHeaderCell.style.textAlign = 'center';
                jointHeaderCell.style.backgroundColor = '#e6ffe6';
                jointHeaderCell.style.fontWeight = 'bold';
                
                // Add each matching record as a row with checkbox
                matchingRecords.forEach((item, index) => {
                    const row = tbody.insertRow();
                    const dataIndex = allTableData.length;
                    allTableData.push(item);
                    
                    // Add checkbox cell
                    const checkboxCell = row.insertCell();
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'record-checkbox';
                    checkbox.dataset.index = dataIndex;
                    checkbox.addEventListener('change', handleRecordSelection);
                    checkboxCell.appendChild(checkbox);
                    
                    // Add cells for each column
                    columns.forEach(column => {
                        const cell = row.insertCell();
                        cell.textContent = item[column] !== undefined ? item[column] : '';
                    });
                });
            }
        });
    }
    
    // Update selected count
    updateSelectedCount();
}


    
function toggleCombinationGroupSelection(loadCase, isChecked) {
    // Find all combination records in this load case group
    document.querySelectorAll('.record-checkbox[data-combination-type="created"]').forEach(checkbox => {
        if (checkbox.dataset.loadCase === loadCase) {
            checkbox.checked = isChecked;
            const index = parseInt(checkbox.dataset.index);
            const record = allTableData[index];
            
            if (isChecked) {
                selectedRecords.add(record);
            } else {
                selectedRecords.delete(record);
            }
        }
    });
    
    updateSelectedCount();
}

// Initialize Set-Phase selection
function initSetPhaseSelection() {
    const setSelect = document.getElementById('set-select');
    const phaseSelect = document.getElementById('phase-select');
    
    if (setSelect) {
        setSelect.addEventListener('change', function() {
            updateSelectedSets();
            updateSelectionDisplay();
        });
    }
    
    if (phaseSelect) {
        phaseSelect.addEventListener('change', function() {
            updateSelectedPhases();
            updateSelectionDisplay();
        });
    }
    
    // Combination creation buttons
    document.getElementById('create-all-combinations')?.addEventListener('click', createAllCombinations);
    document.getElementById('create-single-combination')?.addEventListener('click', createSingleCombination);
    document.getElementById('clear-combinations')?.addEventListener('click', clearAllCombinations);
}

// Update selected sets from multi-select
function updateSelectedSets() {
    const setSelect = document.getElementById('set-select');
    selectedSets.clear();
    
    Array.from(setSelect.selectedOptions).forEach(option => {
        selectedSets.add(option.value);
    });
}

// Update selected phases from multi-select
function updateSelectedPhases() {
    const phaseSelect = document.getElementById('phase-select');
    selectedPhases.clear();
    
    Array.from(phaseSelect.selectedOptions).forEach(option => {
        selectedPhases.add(option.value);
    });
}

// Update the selection display
function updateSelectionDisplay() {
    document.getElementById('selected-sets-display').textContent = 
        selectedSets.size > 0 ? Array.from(selectedSets).join(', ') : 'None';
    
    document.getElementById('selected-phases-display').textContent = 
        selectedPhases.size > 0 ? Array.from(selectedPhases).join(', ') : 'None';
}

// Create all possible combinations from selected sets and phases
function createAllCombinations() {
    if (selectedSets.size === 0 || selectedPhases.size === 0) {
        showSelectionRequiredMessage();
        return;
    }
    
    console.log('Creating ALL combinations from:', {
        sets: Array.from(selectedSets),
        phases: Array.from(selectedPhases)
    });
    
    selectedSets.forEach(set => {
        selectedPhases.forEach(phase => {
            createCombination(set, phase);
        });
    });
    
    console.log('Total combinations after creation:', activeCombinations.size);
    updateActiveCombinationsDisplay();
    updateTable();
}

// Create a single combination
function createSingleCombination() {
    if (selectedSets.size === 0 || selectedPhases.size === 0) {
        showSelectionRequiredMessage();
        return;
    }
    
    // Use the first selected set and phase
    const set = Array.from(selectedSets)[0];
    const phase = Array.from(selectedPhases)[0];
    
    console.log('Creating single combination:', { set, phase });
    
    createCombination(set, phase);
    updateActiveCombinationsDisplay();
    updateTable();
}

// Create individual combination
function createCombination(set, phase) {
    const combinationId = `comb_${combinationCounter++}_${Date.now()}`;
    const combination = {
        id: combinationId,
        set: set,
        phase: phase,
        displayText: `Set ${set} - Phase ${phase}`,
        marker: null
    };
    
    activeCombinations.set(combinationId, combination);
    
    console.log(`Created combination: ${combination.displayText} (ID: ${combinationId})`);
    
    // Add to 3D scene if needed
    addSetPhaseMarker(set, phase);
    
    showCombinationCreatedMessage(combination.displayText);
    
    syncSelectionsWithSession(); // NEW: Sync with session
    return combinationId;
}

// Function to generate combinations (Keep this logic, but decouple storage)
function generateCombinations(mode) {
    const selectedSets = Array.from(document.getElementById('set-select').selectedOptions).map(opt => opt.value);
    const selectedPhases = Array.from(document.getElementById('phase-select').selectedOptions).map(opt => opt.value);
    
    let generatedCombinations = [];

    if (mode === 'all') {
        if (selectedSets.length === 0 || selectedPhases.length === 0) {
            alert('Please select at least one Set and one Phase for "Create All Combinations".');
            return [];
        }
        for (const set of selectedSets) {
            for (const phase of selectedPhases) {
                generatedCombinations.push(`${set}-${phase}`);
            }
        }
    } else if (mode === 'single') {
        if (selectedSets.length !== 1 || selectedPhases.length !== 1) {
            alert('Please select exactly one Set and one Phase for "Create Single Combination".');
            return [];
        }
        generatedCombinations.push(`${selectedSets[0]}-${selectedPhases[0]}`);
    }

    
    return generatedCombinations;
}

// Update the active combinations display
function updateActiveCombinationsDisplay() {
    const displayElement = document.getElementById('active-combinations');
    displayElement.innerHTML = '';

    // Load from the session data passed by Django (which now includes status)
    const activeCombinationsList = JSON.parse('{{ active_combinations|safe|escapejs }}');

    if (activeCombinationsList.length === 0) {
        displayElement.innerHTML = '<p class="text-muted">No combinations active.</p>';
        return;
    }

    activeCombinationsList.forEach(combo => {
        // combo will be like "1-2-Ahead" or "1-2-Back" (Both is no longer possible)
        const parts = combo.split('-');
        const set = parts[0];
        const phase = parts[1];
        const status = parts[2];
        
        // Determine badge class based on status (Both is removed)
        let badgeClass;
        if (status === 'Ahead') {
            badgeClass = 'badge-success';
        } else if (status === 'Back') {
            badgeClass = 'badge-warning';
        } else {
            badgeClass = 'badge-secondary'; // Fallback for any legacy data
        }
        
        const item = document.createElement('span');
        item.className = 'badge badge-primary mr-1 mb-1';
        item.innerHTML = `Set ${set}, Phase ${phase} <span class="badge ${badgeClass}">${status}</span>`;
        item.dataset.set = set;
        item.dataset.phase = phase;
        item.dataset.status = status;
        displayElement.appendChild(item);
    });
}

async function storeCombinations(status) {
    if (combinationsToConfirm.length === 0) return;

    try {
        const response = await fetch('{% url "store_set_phase_combinations" %}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken 
            },
            body: JSON.stringify({
                combinations: combinationsToConfirm,
                status: status
            })
        });

        const result = await response.json();

        if (response.ok) {
            console.log(result.message);
            
            // Use the data returned from the server to update the display
            updateActiveCombinationsDisplayFromResponse(result.new_combinations);
            updateTable();
            
            // Optionally show success message
            showSuccessMessage(`Combinations stored as ${status}`);
        } else {
            alert('Error storing combinations: ' + result.message);
        }
    } catch (error) {
        console.error('Network or other error:', error);
        alert('An unexpected error occurred. Check console.');
    } finally {
        combinationsToConfirm = [];
    }
}

// Update the function that displays combinations to handle "Both" status
function updateActiveCombinationsDisplayFromResponse(newCombinations) {
    const displayElement = document.getElementById('active-combinations');
    displayElement.innerHTML = '';

    if (!newCombinations || newCombinations.length === 0) {
        displayElement.innerHTML = '<p class="text-muted">No combinations active.</p>';
        return;
    }

    newCombinations.forEach(combo => {
        // combo will be like "1-2-Ahead" or "1-2-Back" (Both is removed)
        const parts = combo.split('-');
        const set = parts[0];
        const phase = parts[1];
        const status = parts[2]; // This could be Ahead or Back only now
        
        // Determine badge class based on status (Both is removed)
        let badgeClass;
        if (status === 'Ahead') {
            badgeClass = 'badge-success';
        } else if (status === 'Back') {
            badgeClass = 'badge-warning';
        } else {
            badgeClass = 'badge-secondary'; // Fallback
        }
        
        const item = document.createElement('span');
        item.className = 'badge badge-primary mr-1 mb-1';
        item.innerHTML = `Set ${set}, Phase ${phase} <span class="badge ${badgeClass}">${status}</span>`;
        item.dataset.set = set;
        item.dataset.phase = phase;
        item.dataset.status = status;
        displayElement.appendChild(item);
    });
}

function showSuccessMessage(message) {
    // You can use a toast library or simple alert
    const toast = document.createElement('div');
    toast.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #4CAF50;
        color: white;
        padding: 12px 20px;
        border-radius: 4px;
        z-index: 10000;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    `;
    toast.textContent = message;
    document.body.appendChild(toast);
    
    setTimeout(() => {
        document.body.removeChild(toast);
    }, 3000);
}

// Event Listeners for Create Buttons
document.getElementById('create-all-combinations').addEventListener('click', function() {
    const newCombinations = generateCombinations('all');
    if (newCombinations.length > 0) {
        combinationsToConfirm = newCombinations;
        showAheadBackModal();
    }
});

document.getElementById('create-single-combination').addEventListener('click', function() {
    const newCombinations = generateCombinations('single');
    if (newCombinations.length > 0) {
        combinationsToConfirm = newCombinations;
        showAheadBackModal();
    }
});


function showAheadBackModal() {
    const ul = document.getElementById('new-combinations-list');
    ul.innerHTML = ''; // Clear previous list
    
    if (combinationsToConfirm.length === 0) {
        return; // Should not happen if called correctly
    }

    combinationsToConfirm.forEach(combo => {
        const li = document.createElement('li');
        li.className = 'list-group-item list-group-item-info';
        const [set, phase] = combo.split('-');
        li.textContent = `Set: ${set}, Phase: ${phase}`;
        ul.appendChild(li);
    });

    // Show the Bootstrap modal
    $('#aheadBackModal').modal('show');
}

// Event listeners for Modal Buttons
document.getElementById('btn-ahead').addEventListener('click', function() {
    storeCombinations('Ahead');
});

document.getElementById('btn-back').addEventListener('click', function() {
    storeCombinations('Back');
});

document.getElementById('btn-both').addEventListener('click', function() {
    storeCombinations('Both');
});

// Call the display function on page load
document.addEventListener('DOMContentLoaded', updateActiveCombinationsDisplay);

// Remove a specific combination
function removeCombination(combinationId) {
    if (activeCombinations.has(combinationId)) {
        const comb = activeCombinations.get(combinationId);
        
        // Remove from 3D scene
        removeSetPhaseMarkerByCombination(comb.set, comb.phase, combinationId);
        
        // Remove from active combinations
        activeCombinations.delete(combinationId);
        
        updateActiveCombinationsDisplay();
        updateTable();
        syncSelectionsWithSession(); // NEW: Sync with session
    }
}


// Clear all combinations
function clearAllCombinations() {
    activeCombinations.clear();
    
    // Clear all set-phase markers from 3D scene
    Object.keys(setMarkers).forEach(uniqueId => {
        removeSetPhaseMarker(uniqueId);
    });
    
    updateActiveCombinationsDisplay();
    updateTable();
    syncSelectionsWithSession(); // NEW: Sync with session
}


// Helper function to remove set-phase marker by combination
function removeSetPhaseMarkerByCombination(set, phase, combinationId) {
    Object.keys(setMarkers).forEach(uniqueId => {
        const marker = setMarkers[uniqueId];
        if (marker.setNumber === set && marker.phaseNumber === phase && 
            uniqueId.includes(combinationId)) {
            removeSetPhaseMarker(uniqueId);
        }
    });
}

function syncSelectionsWithSession() {
    const selectedJointsArray = Array.from(selectedJoints);
    const activeCombinationsArray = Array.from(activeCombinations.values());
    
    const formData = new FormData();
    selectedJointsArray.forEach(joint => formData.append('selected_joints[]', joint));
    formData.append('active_combinations', JSON.stringify(activeCombinationsArray));
    
    fetch('/update-selection-session/', {
        method: 'POST',
        headers: {
            'X-Requested-With': 'XMLHttpRequest',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            console.log('Selections synced with session:', data);
        }
    })
    .catch(error => {
        console.error('Error syncing selections:', error);
    });
}

// Helper function to get CSRF token
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

    // Set up event listeners
    document.addEventListener('DOMContentLoaded', function() {
        initModelViewer();
        updateTable();
        initSetPhaseSelection(); // Initialize the new Set-Phase selection


        // Set selection - allow multiple sets
        const setContainer = document.getElementById('set-numbers');
            if (setContainer) {
                setContainer.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                    checkbox.addEventListener('change', function() {
                        const setValue = this.value;

                        if (this.checked) {
                            selectedSets.add(setValue);
                        } else {
                            selectedSets.delete(setValue);
                            // Remove any combinations using this set
                            Object.keys(setMarkers).forEach(combinedId => {
                                if (setMarkers[combinedId].setNumber === setValue) {
                                    removeSetPhaseMarker(combinedId);
                                }
                            });
                        }
                        updateTable();
                    });
                });
            }

        const gridToggleBtn = document.getElementById('grid-toggle-btn');
            if (gridToggleBtn) {
                gridToggleBtn.addEventListener('click', toggleGrid);
            }

        // Phase selection - allow multiple phases but create combination when selected
        const phaseContainer = document.getElementById('phase-numbers');
            if (phaseContainer) {
                phaseContainer.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                    checkbox.addEventListener('change', function() {
                        const phaseValue = this.value;

                        if (this.checked) {
                            selectedPhases.add(phaseValue);
                            // Automatically create combination if we have a set selected
                            if (selectedSets.size > 0) {
                                createSetPhaseCombination();
                            }
                        } else {
                            selectedPhases.delete(phaseValue);
                            // Remove any combinations using this phase
                            Object.keys(setMarkers).forEach(combinedId => {
                                if (setMarkers[combinedId].phaseNumber === phaseValue) {
                                    removeSetPhaseMarker(combinedId);
                                }
                            });
                        }
                        updateTable();
                    });
                });
            }

        // Add combination creation button
        const addCombinationBtn = document.createElement('button');
        addCombinationBtn.textContent = 'Create Set:Phase Combination';
        addCombinationBtn.className = 'btn btn-primary btn-sm';
        addCombinationBtn.style.marginTop = '10px';
        addCombinationBtn.addEventListener('click', createSetPhaseCombination);

        // Add clear button
        const clearCombinationsBtn = document.createElement('button');
        clearCombinationsBtn.textContent = 'Clear All Combinations';
        clearCombinationsBtn.className = 'btn btn-secondary btn-sm';
        clearCombinationsBtn.style.marginTop = '10px';
        clearCombinationsBtn.style.marginLeft = '10px';
        clearCombinationsBtn.addEventListener('click', clearAllSetPhaseCombinations);

        // Insert buttons after phase numbers
        const phaseFormGroup = document.querySelector('.form-group:has(#phase-numbers)');
        if (phaseFormGroup) {
            phaseFormGroup.appendChild(addCombinationBtn);
            phaseFormGroup.appendChild(clearCombinationsBtn);
        }

        // Joint selection (keep existing)
        const jointContainer = document.getElementById('joint-labels');
            if (jointContainer) {
                jointContainer.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                    checkbox.addEventListener('change', function() {
                        const jointValue = this.value;

                        if (this.checked) {
                            selectedJoints.add(jointValue);
                            // Add marker if it doesn't exist
                            if (!jointMarkers[jointValue]) {
                                addJointMarker(jointValue);
                            }
                        } else {
                            selectedJoints.delete(jointValue);
                            removeJointMarker(jointValue);
                        }
                        updateTable();
                        syncSelectionsWithSession(); // NEW: Sync with session
                    });
                });
            }



    document.querySelectorAll('.drag-item').forEach(item => {
            item.addEventListener('dragstart', function(e) {
                currentDroppingItem = {
                    type: this.dataset.type,
                    value: this.dataset.value
                };
                e.dataTransfer.setData('text/plain', JSON.stringify(currentDroppingItem));
                e.dataTransfer.effectAllowed = 'copy';
                this.classList.add('dragging');
                renderer.domElement.style.cursor = 'copy';
            });

            // NEW: Add dragend to reset currentDroppingItem if drag is cancelled or finishes elsewhere
            item.addEventListener('dragend', function() {
            currentDroppingItem = null;
            this.classList.remove('dragging');
            renderer.domElement.style.cursor = 'grab';
        });
        
        });
    
    // Set up drop zone on model viewer
        const modelCanvas = document.getElementById('model-canvas');

        modelCanvas.addEventListener('dragover', function(e) {
            e.preventDefault(); // Essential to allow dropping
            e.dataTransfer.dropEffect = 'copy';
        });
    
        modelCanvas.addEventListener('drop', function(e) {
        e.preventDefault();
        
        // Get the dropped data correctly
        let droppedData;
        try {
            droppedData = JSON.parse(e.dataTransfer.getData('text/plain'));
        } catch (error) {
            console.error('Error parsing dropped data:', error);
            return;
        }
        
        if (!droppedData) return;
        
        const itemType = droppedData.type;
        const itemValue = droppedData.value;
        
        // Find the corresponding checkbox and check it
        let checkbox;
        if (itemType === 'joint') {
            checkbox = document.querySelector(`input[name="joint-labels"][value="${itemValue}"]`);
            if (checkbox && !checkbox.checked) {
                checkbox.checked = true;
                const event = new Event('change');
                checkbox.dispatchEvent(event);
            }
        }
        else if (itemType === 'set') {
            checkbox = document.querySelector(`input[name="set-numbers"][value="${itemValue}"]`);
            if (checkbox && !checkbox.checked) {
                checkbox.checked = true;
                const event = new Event('change');
                checkbox.dispatchEvent(event);
            }
        }
        else if (itemType === 'phase') {
            checkbox = document.querySelector(`input[name="phase-numbers"][value="${itemValue}"]`);
            if (checkbox && !checkbox.checked) {
                checkbox.checked = true;
                const event = new Event('change');
                checkbox.dispatchEvent(event);
                
                // If we have sets selected, automatically create combination
                if (selectedSets.size > 0) {
                    createSetPhaseCombination();
                }
            }
        }
        
        currentDroppingItem = null;
        renderer.domElement.style.cursor = 'grab';
    });
    
    // Add responsive behavior
    window.addEventListener('resize', onWindowResize);
});
        
       
</script>"

this is load_cases.html 
"<div class="container-fluid py-4">
        <div class="row">
            <div class="col-12">
                <h3>Load Cases Selection & Load Values</h3>
                
                <!-- Navigation back to canvas container -->
                <div class="mb-3">
                    <a href="{% url 'hdata1' %}" class="btn btn-outline-secondary">
                        ‚Üê Back to Canvas Container
                    </a>
                </div>

                <!-- Load Cases Selection Section -->
                <div class="load-cases-section mb-4">
                    <h4>Load Cases Selection</h4>
                    
                    <div class="load-case-links mb-3">
                        <a href="#" id="imported-load-cases-link" class="load-case-link active">Imported Load Cases</a>
                        <a href="#" id="group-load-cases-link" class="load-case-link">Group Load Cases</a>
                        <a href="#" id="custom-groups-link" class="load-case-link">Custom Groups</a>
                    </div>
                    
                    <div id="load-cases-results" class="mb-3 p-3 border rounded bg-light">
                        <!-- Load cases will be displayed here -->
                    </div>
                    
                    <!-- Selected Load Cases Display -->
                    <div class="selected-load-cases mb-3 p-3 border rounded bg-light" id="selected-load-cases" style="display: none;">
                        <h5>Selected Load Cases:</h5>
                        <div id="selected-cases-list" class="d-flex flex-wrap gap-2"></div>
                        
                        <!-- Custom Group Creation -->
                        <div id="create-custom-group" class="mt-3 p-3 border rounded" style="display: none;">
                            <div class="d-flex align-items-center gap-2 flex-wrap">
                                <input type="text" id="custom-group-name" placeholder="Enter custom group name" 
                                       class="form-control" style="min-width: 200px;">
                                <button id="create-custom-group-btn" class="btn btn-primary">Create Custom Group</button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Load Case Selection Form -->
                    <form method="post" id="load-cases-form">
                        {% csrf_token %}
                        <input type="hidden" name="load_cases_selection" value="true">
                        <input type="hidden" name="selected_load_cases_input" id="selected-load-cases-input">
                        
                        <button type="submit" class="btn btn-primary mt-2">Apply Selected Load Cases</button>
                    </form>
                </div>

                <hr>

                <div class="filter-section mb-3">
                <form method="post" id="filter-previous-form">
                    {% csrf_token %}
                    <input type="hidden" name="filter_by_previous" value="true">
                    <button type="submit" class="btn btn-info" id="filter-previous-btn">
                        üîç Filter by attachment selection
                    </button>
                    <small class="text-muted ms-2">
                        {% if filter_criteria %}
                            Active filters: 
                            {% if filter_criteria.joint_labels %}
                                Joint Labels ({{ filter_criteria.joint_labels|length }})
                            {% endif %}
                            {% if filter_criteria.set_phase_combinations %}
                                Set+Phase Combinations ({{ filter_criteria.set_phase_combinations|length }})
                                <div class="debug-info small text-info mt-1">
                                    Combinations ({{ filter_criteria.set_phase_combinations|length }} total): 
                                    {% for combo in filter_criteria.set_phase_combinations %}
                                        Set {{ combo.set }} - Phase {{ combo.phase }}{% if not forloop.last %}, {% endif %}
                                    {% endfor %}
                                </div>
                            {% endif %}
                        {% else %}
                            No previous selection found
                        {% endif %}
                    </small>
                </form>
            </div>


                <!-- Load Values Display Section -->
                <div id="load-values-section">
                    <h4>Load Values</h4>
                    <p class="text-muted">This data will be used for calculations based on your selected load cases.</p>
                    
                    <div class="btn-container mb-3">
                        <button id="calculate-btn" class="btn btn-success calculation-btn" disabled>
                            Calculate Selected Records
                        </button>
                        <span id="selected-count" class="selected-count badge bg-secondary ms-2">0 selected</span>
                    </div>

                    <div class="table-container">
                        <table class="table table-bordered table-striped" id="load-table">
                            <thead class="table-dark">
                                <tr>
                                    <th>Select</th>
                                    {% for column in all_columns %}
                                        <th>{{ column }}</th>
                                    {% endfor %}
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        
    </div>

    <!-- Edit Group Modal -->
<div class="modal fade" id="editGroupModal" tabindex="-1" aria-labelledby="editGroupModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="editGroupModalLabel">Edit Group: <span id="edit-group-name"></span></h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <label class="form-label fw-bold">Available Load Cases:</label>
                    <div id="available-load-cases-list" class="border rounded p-3" style="max-height: 300px; overflow-y: auto;">
                        <!-- Available load cases will be populated here -->
                    </div>
                </div>
                <div class="mb-3">
                    <label class="form-label fw-bold">Selected Load Cases for this Group:</label>
                    <div id="group-selected-cases" class="border rounded p-3 bg-light" style="max-height: 200px; overflow-y: auto;">
                        <!-- Selected cases will be shown here -->
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="save-group-changes">Save Changes</button>
            </div>
        </div>
    </div>
</div>


    {% endblock %}

{% block extra_js %}


<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>


<script>
document.addEventListener('DOMContentLoaded', function() {
    const structureId = '{{ structure_id }}';
    const loadCasesResults = document.getElementById('load-cases-results');
    const selectedLoadCasesSection = document.getElementById('selected-load-cases');
    const selectedCasesList = document.getElementById('selected-cases-list');
    const selectedLoadCasesInput = document.getElementById('selected-load-cases-input');
    const createCustomGroupSection = document.getElementById('create-custom-group');
    const customGroupNameInput = document.getElementById('custom-group-name');
    const createCustomGroupBtn = document.getElementById('create-custom-group-btn');
    const loadCasesForm = document.getElementById('load-cases-form');
    const loadTable = document.getElementById('load-table');
    const loadTableBody = loadTable.querySelector('tbody');
    const calculateBtn = document.getElementById('calculate-btn');
    const selectedCount = document.getElementById('selected-count');
    
    const selectedLoadCases = new Set([...{{ selected_load_cases|safe }}]);
    const loadCaseLinks = document.querySelectorAll('.load-case-link');
    const selectedRecords = new Set();
    let allTableData = [];
    const selectedGroups = new Set();

    // Initialize with imported load cases
    loadImportedLoadCases();
    
    function updateSelectedLoadCases() {
        if (selectedLoadCases.size > 0) {
            selectedLoadCasesSection.style.display = 'block';
            selectedCasesList.innerHTML = '';
            
            selectedLoadCases.forEach(caseName => {
                const caseElement = document.createElement('span');
                caseElement.className = 'badge bg-primary selected-case';
                caseElement.innerHTML = `
                    ${caseName}
                    <span class="remove-case ms-1" data-case="${caseName}" style="cursor: pointer;">√ó</span>
                `;
                selectedCasesList.appendChild(caseElement);
            });
            
            // Show create custom group option
            createCustomGroupSection.style.display = 'block';
            
            // Update hidden input
            selectedLoadCasesInput.value = Array.from(selectedLoadCases).join(',');
            
            // Add remove event listeners
            document.querySelectorAll('.remove-case').forEach(btn => {
                btn.addEventListener('click', function() {
                    const caseName = this.dataset.case;
                    selectedLoadCases.delete(caseName);
                    updateSelectedLoadCases();
                    uncheckCorrespondingCheckbox(caseName);
                });
            });
        } else {
            selectedLoadCasesSection.style.display = 'none';
            createCustomGroupSection.style.display = 'none';
            selectedLoadCasesInput.value = '';
        }
    }
    
    function uncheckCorrespondingCheckbox(caseName) {
        const checkboxes = document.querySelectorAll(`input[type="checkbox"][value="${caseName}"]`);
        checkboxes.forEach(cb => {
            cb.checked = false;
        });
    }
    
    // NEW: Function to clear all selections when switching tabs
    function clearAllSelections() {
        selectedLoadCases.clear();
        updateSelectedLoadCases();
        // Also clear any checkboxes in the current results section
        loadCasesResults.querySelectorAll('input[type="checkbox"]').forEach(cb => {
            cb.checked = false;
        });
    }
    
    // Load Case Links Event Listeners - MODIFIED to clear selections
    document.getElementById('imported-load-cases-link').addEventListener('click', function(e) {
        e.preventDefault();
        setActiveLink(this);
        clearAllSelections(); // NEW: Clear selections when switching tabs
        loadImportedLoadCases();
    });
    
    document.getElementById('group-load-cases-link').addEventListener('click', function(e) {
        e.preventDefault();
        setActiveLink(this);
        clearAllSelections(); // NEW: Clear selections when switching tabs
        loadGroupedLoadCases();
    });
    
    document.getElementById('custom-groups-link').addEventListener('click', function(e) {
        e.preventDefault();
        setActiveLink(this);
        clearAllSelections(); // NEW: Clear selections when switching tabs
        loadCustomGroups();
    });
    
    function setActiveLink(activeLink) {
        loadCaseLinks.forEach(link => link.classList.remove('active'));
        activeLink.classList.add('active');
    }
    
    // Load Imported Load Cases - MODIFIED to add "Select All" functionality
    function loadImportedLoadCases() {
        if (!structureId) {
            loadCasesResults.innerHTML = '<div class="alert alert-warning">No structure selected</div>';
            return;
        }
        
        fetch(`/load-cases/?get_load_cases=true&structure_id=${structureId}`, {
            headers: {
                'X-Requested-With': 'XMLHttpRequest'
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                loadCasesResults.innerHTML = `<div class="alert alert-danger">${data.error}</div>`;
                return;
            }
            
            let html = '<h5>Imported Load Cases</h5>';
            
            // NEW: Add "Select All" checkbox for imported load cases
            if (data.values && data.values.length > 0) {
                html += `
                    <div class="form-check mb-3">
                        <input class="form-check-input" type="checkbox" id="select-all-imported">
                        <label class="form-check-label fw-bold" for="select-all-imported">
                            Select All Imported Load Cases
                        </label>
                    </div>
                `;
                
                html += '<div class="load-cases-list">';
                data.values.forEach(caseName => {
                    const isChecked = selectedLoadCases.has(caseName);
                    html += `
                        <div class="form-check">
                            <input class="form-check-input imported-case-checkbox" type="checkbox" value="${caseName}" 
                                   id="imported-${caseName.replace(/\s+/g, '-')}" 
                                   ${isChecked ? 'checked' : ''}>
                            <label class="form-check-label" for="imported-${caseName.replace(/\s+/g, '-')}">
                                ${caseName}
                            </label>
                        </div>
                    `;
                });
                html += '</div>';
            } else {
                html += '<p class="text-muted">No load cases found</p>';
            }
            loadCasesResults.innerHTML = html;
            
            // NEW: Add "Select All" functionality for imported cases
            const selectAllImported = document.getElementById('select-all-imported');
            if (selectAllImported) {
                selectAllImported.addEventListener('change', function() {
                    const importedCheckboxes = document.querySelectorAll('.imported-case-checkbox');
                    importedCheckboxes.forEach(cb => {
                        cb.checked = this.checked;
                        if (this.checked) {
                            selectedLoadCases.add(cb.value);
                        } else {
                            selectedLoadCases.delete(cb.value);
                        }
                    });
                    updateSelectedLoadCases();
                });
            }
            
            // Add event listeners for individual checkboxes
            document.querySelectorAll('.imported-case-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    if (this.checked) {
                        selectedLoadCases.add(this.value);
                    } else {
                        selectedLoadCases.delete(this.value);
                        // Uncheck "Select All" if any checkbox is unchecked
                        if (selectAllImported) {
                            selectAllImported.checked = false;
                        }
                    }
                    updateSelectedLoadCases();
                });
            });
        })
        .catch(error => {
            loadCasesResults.innerHTML = `<div class="alert alert-danger">Error loading data: ${error}</div>`;
        });
    }
    
    // Load Grouped Load Cases - MODIFIED to enhance "Select All" functionality
    function loadGroupedLoadCases() {
        if (!structureId) {
            loadCasesResults.innerHTML = '<div class="alert alert-warning">No structure selected</div>';
            return;
        }
        
        fetch(`/load-cases/?get_grouped_load_cases=true&structure_id=${structureId}`, {
            headers: {
                'X-Requested-With': 'XMLHttpRequest'
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                loadCasesResults.innerHTML = `<div class="alert alert-danger">${data.error}</div>`;
                return;
            }
            
            let html = '<h5>Group Load Cases</h5>';
            if (data.groups && Object.keys(data.groups).length > 0) {
                // NEW: Add "Select All Groups" master checkbox
                html += `
                    <div class="form-check mb-3">
                        <input class="form-check-input" type="checkbox" id="select-all-groups">
                        <label class="form-check-label fw-bold" for="select-all-groups">
                            Select All Groups
                        </label>
                    </div>
                `;
                
                for (const [groupName, cases] of Object.entries(data.groups)) {
                    html += `
                        <div class="load-case-group mb-3 p-3 border rounded">
                            <h6 class="d-flex align-items-center">
                                ${groupName}
                                <div class="form-check ms-2">
                                    <input class="form-check-input select-all-group" type="checkbox" 
                                           id="select-all-${groupName.replace(/\s+/g, '-')}">
                                    <label class="form-check-label small" for="select-all-${groupName.replace(/\s+/g, '-')}">
                                        Select All in Group
                                    </label>
                                </div>
                            </h6>
                            <div class="group-cases ms-3">`;
                    
                    cases.forEach(caseName => {
                        const isChecked = selectedLoadCases.has(caseName);
                        html += `
                            <div class="form-check">
                                <input class="form-check-input group-case-checkbox" type="checkbox" 
                                       value="${caseName}" data-group="${groupName}"
                                       id="group-${caseName.replace(/\s+/g, '-')}" 
                                       ${isChecked ? 'checked' : ''}>
                                <label class="form-check-label" for="group-${caseName.replace(/\s+/g, '-')}">
                                    ${caseName}
                                </label>
                            </div>
                        `;
                    });
                    
                    html += '</div></div>';
                }
            } else {
                html += '<p class="text-muted">No grouped load cases found</p>';
            }
            loadCasesResults.innerHTML = html;
            
            // NEW: Add master "Select All Groups" functionality
            const selectAllGroups = document.getElementById('select-all-groups');
            if (selectAllGroups) {
                selectAllGroups.addEventListener('change', function() {
                    const groupSelectAlls = document.querySelectorAll('.select-all-group');
                    const groupCaseCheckboxes = document.querySelectorAll('.group-case-checkbox');
                    
                    groupSelectAlls.forEach(cb => {
                        cb.checked = this.checked;
                    });
                    
                    groupCaseCheckboxes.forEach(cb => {
                        cb.checked = this.checked;
                        if (this.checked) {
                            selectedLoadCases.add(cb.value);
                        } else {
                            selectedLoadCases.delete(cb.value);
                        }
                    });
                    updateSelectedLoadCases();
                });
            }
            
            // Add select all functionality for individual groups
            document.querySelectorAll('.select-all-group').forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    const groupName = this.id.replace('select-all-', '');
                    const caseCheckboxes = document.querySelectorAll(`.group-case-checkbox[data-group="${groupName}"]`);
                    caseCheckboxes.forEach(cb => {
                        cb.checked = this.checked;
                        if (this.checked) {
                            selectedLoadCases.add(cb.value);
                        } else {
                            selectedLoadCases.delete(cb.value);
                        }
                    });
                    updateSelectedLoadCases();
                    
                    // Update master "Select All Groups" checkbox
                    updateMasterSelectAllGroups();
                });
            });
            
            // Add individual checkbox listeners
            document.querySelectorAll('.group-case-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    if (this.checked) {
                        selectedLoadCases.add(this.value);
                    } else {
                        selectedLoadCases.delete(this.value);
                        // Uncheck group's select-all
                        const groupName = this.dataset.group;
                        const selectAll = document.getElementById(`select-all-${groupName}`);
                        if (selectAll) selectAll.checked = false;
                    }
                    updateSelectedLoadCases();
                    
                    // Update master "Select All Groups" checkbox
                    updateMasterSelectAllGroups();
                });
            });
            
            // NEW: Helper function to update master "Select All Groups" checkbox
            function updateMasterSelectAllGroups() {
                const selectAllGroups = document.getElementById('select-all-groups');
                if (selectAllGroups) {
                    const allGroupCheckboxes = document.querySelectorAll('.group-case-checkbox');
                    const allChecked = Array.from(allGroupCheckboxes).every(cb => cb.checked);
                    selectAllGroups.checked = allChecked;
                }
            }
        })
        .catch(error => {
            loadCasesResults.innerHTML = `<div class="alert alert-danger">Error loading data: ${error}</div>`;
        });
    }
    
    // Load Custom Groups - MODIFIED to enhance "Select All" functionality
    function loadCustomGroups() {
    if (!structureId) {
        loadCasesResults.innerHTML = '<div class="alert alert-warning">No structure selected</div>';
        return;
    }
    
    fetch(`/load-cases/?get_custom_groups_for_selection=true&structure_id=${structureId}`, {
        headers: {
            'X-Requested-With': 'XMLHttpRequest'
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            loadCasesResults.innerHTML = `<div class="alert alert-danger">${data.error}</div>`;
            return;
        }
        
        let html = '<h5>Custom Groups</h5>';
        if (data.custom_groups && Object.keys(data.custom_groups).length > 0) {
            // NEW: Add "Select All Custom Groups" master checkbox
            html += `
                <div class="form-check mb-3">
                    <input class="form-check-input" type="checkbox" id="select-all-custom-groups">
                    <label class="form-check-label fw-bold" for="select-all-custom-groups">
                        Select All Custom Groups
                    </label>
                </div>
            `;
            
            for (const [groupName, cases] of Object.entries(data.custom_groups)) {
                html += `
                    <div class="load-case-group mb-3 p-3 border rounded" id="custom-group-${groupName.replace(/\s+/g, '-')}" data-group="${groupName}">  <!-- **MODIFIED: Added data-group to store original name** -->
                        <h6 class="d-flex align-items-center">
                            <span class="group-name-display">${groupName}</span>
                            <div class="ms-2">
                                <button class="btn btn-sm btn-outline-primary edit-group" data-group="${groupName}">Rename</button>
                                <button class="btn btn-sm btn-outline-warning edit-group-members" data-group="${groupName}">Edit</button>
                                <button class="btn btn-sm btn-outline-danger delete-group" data-group="${groupName}">Delete</button>
                            </div>
                            <div class="form-check ms-2">
                                <input class="form-check-input select-all-custom-group" type="checkbox" 
                                       id="select-all-custom-${groupName.replace(/\s+/g, '-')}" data-group="${groupName}">  <!-- **MODIFIED: Added data-group to store original name** -->
                                <label class="form-check-label small" for="select-all-custom-${groupName.replace(/\s+/g, '-')}">
                                    Select All in Group
                                </label>
                            </div>
                        </h6>
                        <div class="group-edit-form mt-2" style="display: none;">
                            <div class="d-flex gap-2">
                                <input type="text" class="form-control form-control-sm edit-group-input" value="${groupName}">
                                <button class="btn btn-sm btn-success save-edit" data-group="${groupName}">Save</button>
                                <button class="btn btn-sm btn-secondary cancel-edit" data-group="${groupName}">Cancel</button>
                            </div>
                        </div>
                        <div class="group-cases ms-3 mt-2">`;
                
                cases.forEach(caseName => {
                    const isChecked = selectedLoadCases.has(caseName);
                    html += `
                        <div class="form-check">
                            <input class="form-check-input custom-group-case-checkbox" type="checkbox" 
                                   value="${caseName}" data-group="${groupName}"
                                   id="custom-${caseName.replace(/\s+/g, '-')}" 
                                   ${isChecked ? 'checked' : ''}>
                            <label class="form-check-label" for="custom-${caseName.replace(/\s+/g, '-')}">
                                ${caseName}
                            </label>
                        </div>
                    `;
                });
                
                html += '</div></div>';
            }
        } else {
            html += '<p class="text-muted">No custom groups found</p>';
        }
        loadCasesResults.innerHTML = html;
        
        // Add custom group functionality
        setupCustomGroupFunctionality();
    })
    .catch(error => {
        loadCasesResults.innerHTML = `<div class="alert alert-danger">Error loading data: ${error}</div>`;
    });
}
    
    // Setup custom group functionality (edit, delete, select all) - MODIFIED
    function setupCustomGroupFunctionality() {
    // NEW: Add master "Select All Custom Groups" functionality
    const selectAllCustomGroups = document.getElementById('select-all-custom-groups');
    if (selectAllCustomGroups) {
        selectAllCustomGroups.addEventListener('change', function() {
            const groupSelectAlls = document.querySelectorAll('.select-all-custom-group');
            const customGroupCaseCheckboxes = document.querySelectorAll('.custom-group-case-checkbox');
            
            groupSelectAlls.forEach(cb => {
                cb.checked = this.checked;
            });
            
            customGroupCaseCheckboxes.forEach(cb => {
                cb.checked = this.checked;
                if (this.checked) {
                    selectedLoadCases.add(cb.value);
                } else {
                    selectedLoadCases.delete(cb.value);
                }
            });
            
            // NEW: Update selectedGroups
            if (this.checked) {
                // Add all custom group names to selectedGroups
                const allGroupElements = document.querySelectorAll('.load-case-group[id^="custom-group-"]');
                allGroupElements.forEach(el => {
                    const groupName = el.dataset.group;  // **MODIFIED: Use dataset.group instead of manipulating ID**
                    selectedGroups.add(groupName);
                });
            } else {
                // Clear selectedGroups
                selectedGroups.clear();
            }
            
            updateSelectedLoadCases();
        });
    }
        
        // In setupCustomGroupFunctionality() - make sure selectedGroups is updated
        document.querySelectorAll('.select-all-custom-group').forEach(checkbox => {
            checkbox.addEventListener('change', function() {
                const groupName = this.dataset.group;
                const caseCheckboxes = document.querySelectorAll(`.custom-group-case-checkbox[data-group="${groupName}"]`);
                caseCheckboxes.forEach(cb => {
                    cb.checked = this.checked;
                    if (this.checked) {
                        selectedLoadCases.add(cb.value);
                        selectedGroups.add(groupName);  // This should add the group
                    } else {
                        selectedLoadCases.delete(cb.value);
                        selectedGroups.delete(groupName);  // This should remove the group
                    }
                });
                updateSelectedLoadCases();
                updateMasterSelectAllCustomGroups();
            });
        });

                
                // Individual checkbox listeners
                document.querySelectorAll('.custom-group-case-checkbox').forEach(checkbox => {
            checkbox.addEventListener('change', function() {
                if (this.checked) {
                    selectedLoadCases.add(this.value);
                } else {
                    selectedLoadCases.delete(this.value);
                    // If no cases are selected in this group, remove the group from selectedGroups
                    const groupName = this.dataset.group;
                    const groupCheckboxes = document.querySelectorAll(`.custom-group-case-checkbox[data-group="${groupName}"]`);
                    const anyChecked = Array.from(groupCheckboxes).some(cb => cb.checked);
                    if (!anyChecked) {
                        selectedGroups.delete(groupName);  // NEW: Remove group if no cases selected
                    }
                }
                updateSelectedLoadCases();
                
                // Update master "Select All Custom Groups" checkbox
                updateMasterSelectAllCustomGroups();
            });
        });

        document.querySelectorAll('.edit-group-members').forEach(btn => {
            btn.addEventListener('click', function() {
                const groupName = this.dataset.group;
                openEditGroupModal(groupName);
            });
        });

        function openEditGroupModal(groupName) {
            // Set the group name in modal title
            document.getElementById('edit-group-name').textContent = groupName;
            
            // Show loading state
            document.getElementById('available-load-cases-list').innerHTML = '<div class="text-center py-3"><div class="spinner-border" role="status"></div></div>';
            document.getElementById('group-selected-cases').innerHTML = '<div class="text-center py-2">Loading...</div>';
            
            // Fetch available load cases and current group members
            fetch(`/load-cases/?get_all_load_cases=true&structure_id=${structureId}`, {
                headers: {
                    'X-Requested-With': 'XMLHttpRequest'
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert('Error loading load cases: ' + data.error);
                    return;
                }
                
                // Get current group members from the displayed checkboxes
                const currentGroupElement = document.getElementById(`custom-group-${groupName.replace(/\s+/g, '-')}`);
                const currentCases = [];
                if (currentGroupElement) {
                    const checkboxes = currentGroupElement.querySelectorAll('.custom-group-case-checkbox');
                    checkboxes.forEach(cb => {
                        currentCases.push(cb.value);
                    });
                }
                
                populateEditGroupModal(data.values || [], currentCases, groupName);
                
                // Show the modal
                const modal = new bootstrap.Modal(document.getElementById('editGroupModal'));
                modal.show();
            })
            .catch(error => {
                alert('Error loading load cases: ' + error);
            });
        }

        // Function to populate the edit group modal
        function populateEditGroupModal(allLoadCases, currentGroupCases, groupName) {
            const availableList = document.getElementById('available-load-cases-list');
            const selectedList = document.getElementById('group-selected-cases');
            
            // Clear previous content
            availableList.innerHTML = '';
            selectedList.innerHTML = '';
            
            if (!allLoadCases || allLoadCases.length === 0) {
                availableList.innerHTML = '<p class="text-muted">No load cases available</p>';
                return;
            }
            
            // Sort load cases alphabetically for better UX
            allLoadCases.sort();
            
            // Create available load cases list
            allLoadCases.forEach(caseName => {
                const isInGroup = currentGroupCases.includes(caseName);
                const caseElement = document.createElement('div');
                caseElement.className = 'form-check';
                caseElement.innerHTML = `
                    <input class="form-check-input available-case-checkbox" type="checkbox" 
                        value="${caseName}" id="available-${caseName.replace(/\s+/g, '-')}"
                        ${isInGroup ? 'checked' : ''}>
                    <label class="form-check-label" for="available-${caseName.replace(/\s+/g, '-')}">
                        ${caseName}
                    </label>
                `;
                availableList.appendChild(caseElement);
            });
            
            // Populate selected cases display
            updateSelectedCasesDisplay(currentGroupCases);
            
            // Add event listeners to checkboxes
            document.querySelectorAll('.available-case-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    updateSelectedCasesDisplayFromCheckboxes();
                });
            });
            
            // Set up save button
            document.getElementById('save-group-changes').onclick = function() {
                saveGroupChanges(groupName);
            };
        }

        // Function to update selected cases display from checkboxes
        function updateSelectedCasesDisplayFromCheckboxes() {
            const selectedCases = [];
            document.querySelectorAll('.available-case-checkbox:checked').forEach(checkbox => {
                selectedCases.push(checkbox.value);
            });
            updateSelectedCasesDisplay(selectedCases);
        }

        // Function to update selected cases display
        function updateSelectedCasesDisplay(selectedCases) {
            const selectedList = document.getElementById('group-selected-cases');
            
            if (selectedCases.length === 0) {
                selectedList.innerHTML = '<p class="text-muted">No load cases selected</p>';
                return;
            }
            
            selectedList.innerHTML = '';
            
            // Sort selected cases alphabetically
            selectedCases.sort().forEach(caseName => {
                const caseElement = document.createElement('div');
                caseElement.className = 'selected-case-item d-flex justify-content-between align-items-center p-2 mb-1 bg-white rounded border';
                caseElement.innerHTML = `
                    <span class="flex-grow-1">${caseName}</span>
                    <button type="button" class="btn btn-sm btn-outline-danger remove-case-btn" data-case="${caseName}">
                        √ó
                    </button>
                `;
                selectedList.appendChild(caseElement);
            });
            
            // Add remove functionality
            document.querySelectorAll('.remove-case-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const caseName = this.dataset.case;
                    const checkbox = document.querySelector(`#available-${caseName.replace(/\s+/g, '-')}`);
                    if (checkbox) {
                        checkbox.checked = false;
                        updateSelectedCasesDisplayFromCheckboxes();
                    }
                });
            });
        }

        // Function to save group changes
        function saveGroupChanges(groupName) {
            const selectedCases = [];
            document.querySelectorAll('.available-case-checkbox:checked').forEach(checkbox => {
                selectedCases.push(checkbox.value);
            });
            
            if (selectedCases.length === 0) {
                alert('Please select at least one load case for the group');
                return;
            }
            
            const formData = new FormData();
            formData.append('edit_custom_group', 'true');
            formData.append('structure_id', structureId);
            formData.append('group_name', groupName);
            selectedCases.forEach(caseName => {
                formData.append('selected_cases[]', caseName);
            });
            
            // Show loading state
            const saveBtn = document.getElementById('save-group-changes');
            const originalText = saveBtn.innerHTML;
            saveBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status"></span> Saving...';
            saveBtn.disabled = true;
            
            fetch('/load-cases/', {
                method: 'POST',
                headers: {
                    'X-Requested-With': 'XMLHttpRequest',
                    'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
                },
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showNotification(`Group "${groupName}" updated successfully!`, 'success');
                    // Close modal
                    const modal = bootstrap.Modal.getInstance(document.getElementById('editGroupModal'));
                    if (modal) modal.hide();
                    // Reload custom groups to reflect changes
                    loadCustomGroups();
                } else {
                    alert('Error updating group: ' + (data.error || 'Unknown error'));
                }
            })
            .catch(error => {
                alert('Error updating group: ' + error);
            })
            .finally(() => {
                saveBtn.innerHTML = originalText;
                saveBtn.disabled = false;
            });
        }
                
        // NEW: Helper function to update master "Select All Custom Groups" checkbox
        function updateMasterSelectAllCustomGroups() {
            const selectAllCustomGroups = document.getElementById('select-all-custom-groups');
            if (selectAllCustomGroups) {
                const allCustomGroupCheckboxes = document.querySelectorAll('.custom-group-case-checkbox');
                const allChecked = allCustomGroupCheckboxes.length > 0 && 
                                 Array.from(allCustomGroupCheckboxes).every(cb => cb.checked);
                selectAllCustomGroups.checked = allChecked;
            }
        }
        
        // Edit group functionality
        document.querySelectorAll('.edit-group').forEach(btn => {
            btn.addEventListener('click', function() {
                const groupName = this.dataset.group;
                const groupElement = this.closest('.load-case-group');
                const displayElement = groupElement.querySelector('.group-name-display');
                const editForm = groupElement.querySelector('.group-edit-form');
                
                displayElement.style.display = 'none';
                this.style.display = 'none';
                groupElement.querySelector('.delete-group').style.display = 'none';
                editForm.style.display = 'block';
            });
        });
        
        // Cancel edit
        document.querySelectorAll('.cancel-edit').forEach(btn => {
            btn.addEventListener('click', function() {
                const groupName = this.dataset.group;
                const groupElement = this.closest('.load-case-group');
                const displayElement = groupElement.querySelector('.group-name-display');
                const editForm = groupElement.querySelector('.group-edit-form');
                
                editForm.style.display = 'none';
                displayElement.style.display = 'inline';
                groupElement.querySelector('.edit-group').style.display = 'inline-block';
                groupElement.querySelector('.delete-group').style.display = 'inline-block';
            });
        });
        
        // Save edit
        document.querySelectorAll('.save-edit').forEach(btn => {
            btn.addEventListener('click', function() {
                const oldGroupName = this.dataset.group;
                const newGroupName = this.closest('.group-edit-form').querySelector('.edit-group-input').value.trim();
                
                if (!newGroupName) {
                    alert('Group name cannot be empty');
                    return;
                }
                
                if (newGroupName === oldGroupName) {
                    this.closest('.group-edit-form').querySelector('.cancel-edit').click();
                    return;
                }
                
                const formData = new FormData();
                formData.append('update_custom_group', 'true');
                formData.append('old_group_name', oldGroupName);
                formData.append('new_group_name', newGroupName);
                formData.append('structure_id', structureId);
                
                fetch('/load-cases/', {
                    method: 'POST',
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest',
                        'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
                    },
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Reload custom groups to reflect changes
                        loadCustomGroups();
                    } else {
                        alert('Error updating group: ' + data.error);
                    }
                })
                .catch(error => {
                    alert('Error updating group: ' + error);
                });
            });
        });
        
        // Delete group functionality
        document.querySelectorAll('.delete-group').forEach(btn => {
            btn.addEventListener('click', function() {
                const groupName = this.dataset.group;
                if (confirm(`Are you sure you want to delete the group "${groupName}"?`)) {
                    const formData = new FormData();
                    formData.append('delete_custom_group', 'true');
                    formData.append('structure_id', structureId);
                    formData.append('group_name', groupName);
                    
                    fetch('/load-cases/', {
                        method: 'POST',
                        headers: {
                            'X-Requested-With': 'XMLHttpRequest',
                            'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
                        },
                        body: formData
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            // Reload custom groups
                            loadCustomGroups();
                        } else {
                            alert('Error deleting group: ' + data.error);
                        }
                    })
                    .catch(error => {
                        alert('Error deleting group: ' + error);
                    });
                }
            });
        });
    }
    
    // Create Custom Group
    createCustomGroupBtn.addEventListener('click', function() {
        const groupName = customGroupNameInput.value.trim();
        
        if (!structureId) {
            alert('Please select a structure first');
            return;
        }
        
        if (!groupName) {
            alert('Please enter a group name');
            return;
        }
        
        if (selectedLoadCases.size === 0) {
            alert('Please select at least one load case');
            return;
        }
        
        const formData = new FormData();
        formData.append('create_custom_group', 'true');
        formData.append('structure_id', structureId);
        formData.append('group_name', groupName);
        selectedLoadCases.forEach(caseName => {
            formData.append('selected_cases', caseName);
        });
        
        fetch('/load-cases/', {
            method: 'POST',
            headers: {
                'X-Requested-With': 'XMLHttpRequest',
                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
            },
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                alert(`Custom group "${groupName}" created successfully!`);
                customGroupNameInput.value = '';
                // Switch to custom groups tab
                document.getElementById('custom-groups-link').click();
            } else {
                alert('Error creating custom group: ' + data.error);
            }
        })
        .catch(error => {
            alert('Error creating custom group: ' + error);
        });
    });
    
    // Function to update the load values table with filtered data
    function updateLoadValuesTable(selectedCases, selectionSource = 'imported') {
    if (!structureId) {
        return;
    }
    
    // Show loading state
    loadTableBody.innerHTML = '<tr><td colspan="100%" class="text-center py-4"><div class="spinner-border" role="status"><span class="visually-hidden">Loading...</span></div></td></tr>';
    
    // Build URL with selected load cases and selection source
    const url = new URL('/load-cases/', window.location.origin);
    url.searchParams.append('get_filtered_load_data', 'true');
    url.searchParams.append('structure_id', structureId);
    url.searchParams.append('selection_source', selectionSource); // NEW: Add selection source
    selectedCases.forEach(caseName => {
        url.searchParams.append('selected_load_cases', caseName);
    });
    
    if (selectionSource === 'custom') {
        selectedGroups.forEach(groupName => {
            url.searchParams.append('selected_groups', groupName);
        });
    }

    fetch(url, {
        headers: {
            'X-Requested-With': 'XMLHttpRequest'
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            loadTableBody.innerHTML = `<tr><td colspan="100%" class="text-center text-danger py-4">${data.error}</td></tr>`;
            return;
        }
        
        // Clear existing table data
        loadTableBody.innerHTML = '';
        allTableData = []; // Reset all table data
        selectedRecords.clear(); // Clear previous selections
        
        // NEW: Handle grouped data response
        if (data.is_grouped && data.grouped_data) {
            updateTableWithGroupedData(data.grouped_data, data.all_columns);
        } 
        // Handle flat data response (existing behavior)
        else if (data.load_data && data.load_data.length > 0) {
            updateTableWithFlatData(data.load_data, data.all_columns);
        } 
        else {
            loadTableBody.innerHTML = '<tr><td colspan="100%" class="text-center text-muted py-4">No data found for selected load cases</td></tr>';
            selectedCount.textContent = '0 records';
            calculateBtn.disabled = true;
        }
    })
    .catch(error => {
        loadTableBody.innerHTML = `<tr><td colspan="100%" class="text-center text-danger py-4">Error loading data: ${error}</td></tr>`;
    });
}

// NEW: Function to update table with grouped data
function updateTableWithGroupedData(groupedData, columns) {
    let totalRecords = 0;
    let rowIndex = 0;
    
    // Clear existing table data
    loadTableBody.innerHTML = '';
    allTableData = [];
    selectedRecords.clear();
    
    // Update table header
    updateTableHeader(columns);
    
    // If no grouped data, show empty message
    if (Object.keys(groupedData).length === 0) {
        loadTableBody.innerHTML = '<tr><td colspan="100%" class="text-center text-muted py-4">No matching records found</td></tr>';
        selectedCount.textContent = '0 records';
        calculateBtn.disabled = true;
        return;
    }
    
    // Iterate through each group
    for (const [groupName, records] of Object.entries(groupedData)) {
        if (records.length === 0) continue;
        
        totalRecords += records.length;
        
        // Add group header row
        const headerRow = document.createElement('tr');
        headerRow.className = 'group-header-row table-primary';
        headerRow.style.fontWeight = 'bold';
        
        const headerCell = document.createElement('td');
        headerCell.colSpan = columns.length + 1; // +1 for select column
        headerCell.innerHTML = `
            <div class="d-flex align-items-center justify-content-between">
                <span>üìÅ ${groupName} (${records.length} records)</span>
                <div class="form-check">
                    <input class="form-check-input select-group-checkbox" type="checkbox" 
                           data-group="${groupName.replace(/\s+/g, '-')}">
                    <label class="form-check-label small">Select All in Group</label>
                </div>
            </div>
        `;
        headerRow.appendChild(headerCell);
        loadTableBody.appendChild(headerRow);
        
        // Add records for this group
        records.forEach(record => {
            const row = document.createElement('tr');
            row.className = 'group-data-row';
            row.dataset.group = groupName.replace(/\s+/g, '-');
            
            // Add select checkbox
            const selectCell = document.createElement('td');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'row-select';
            checkbox.dataset.index = rowIndex;
            checkbox.dataset.group = groupName.replace(/\s+/g, '-');
            selectCell.appendChild(checkbox);
            row.appendChild(selectCell);
            
            // Add data cells
            columns.forEach(column => {
                const cell = document.createElement('td');
                const value = record[column] || '';
                cell.textContent = value;
                
                // Highlight important columns
                if (column === 'Set No.' || column === 'Phase No.') {
                    cell.style.fontWeight = 'bold';
                    cell.style.backgroundColor = '#e8f5e8';
                    cell.style.borderLeft = '3px solid #28a745';
                }
                
                // Highlight Load Case Description
                if (column === 'Load Case Description') {
                    cell.style.fontWeight = 'bold';
                    cell.style.backgroundColor = '#e3f2fd';
                }
                
                row.appendChild(cell);
            });
            
            loadTableBody.appendChild(row);
            
            // Store the row data in allTableData
            allTableData.push(record);
            rowIndex++;
        });
        
        // Add a small spacer between groups
        const spacerRow = document.createElement('tr');
        const spacerCell = document.createElement('td');
        spacerCell.colSpan = columns.length + 1;
        spacerCell.style.height = '5px';
        spacerCell.style.backgroundColor = '#f8f9fa';
        spacerRow.appendChild(spacerCell);
        loadTableBody.appendChild(spacerRow);
    }
    
    // Update record count and setup selection
    selectedCount.textContent = `${totalRecords} records`;
    calculateBtn.disabled = true;
    
    // Add selection functionality
    setupRowSelection();
    setupGroupSelection();
    updateSelectedCount();
}

function updateTableWithFlatData(loadData, columns) {
    // Clear existing table data
    loadTableBody.innerHTML = '';
    allTableData = []; // Reset all table data
    selectedRecords.clear(); // Clear previous selections
    
    // Update table header if columns changed
    updateTableHeader(columns);
    
    // Populate table rows
    loadData.forEach((rowData, index) => {
        const row = document.createElement('tr');
        
        // Add select checkbox
        const selectCell = document.createElement('td');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'row-select';
        checkbox.dataset.index = index;
        selectCell.appendChild(checkbox);
        row.appendChild(selectCell);
        
        // Add data cells
        columns.forEach(column => {
            const cell = document.createElement('td');
            cell.textContent = rowData[column] || '';
            row.appendChild(cell);
        });
        
        loadTableBody.appendChild(row);
        
        // Store the row data in allTableData
        allTableData.push(rowData);
    });
    
    // Update record count
    selectedCount.textContent = `${loadData.length} records`;
    calculateBtn.disabled = true;
    
    // Add row selection functionality
    setupRowSelection();
    updateSelectedCount();
}

// NEW: Function to setup group selection
function setupGroupSelection() {
    document.querySelectorAll('.select-group-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', function() {
            const groupName = this.dataset.group;
            const groupHeader = this.closest('.group-header-row');
            let nextRow = groupHeader.nextElementSibling;
            
            // Find and check/uncheck all rows in this group
            while (nextRow && (nextRow.classList.contains('group-data-row') || nextRow.classList.contains('group-spacer-row'))) {
                if (nextRow.classList.contains('group-data-row') && nextRow.dataset.group === groupName) {
                    const rowCheckbox = nextRow.querySelector('.row-select');
                    if (rowCheckbox) {
                        rowCheckbox.checked = this.checked;
                        const index = parseInt(rowCheckbox.dataset.index);
                        const record = allTableData[index];
                        
                        if (this.checked) {
                            selectedRecords.add(record);
                        } else {
                            selectedRecords.delete(record);
                        }
                    }
                }
                nextRow = nextRow.nextElementSibling;
            }
            
            updateSelectedCount();
        });
    });
}


// Add select all functionality (optional but recommended)
function addSelectAllFunctionality() {
    // Add select all checkbox in header
    const thead = loadTable.querySelector('thead');
    const headerRow = thead.querySelector('tr');
    
    // Check if select all checkbox already exists
    if (!headerRow.querySelector('.select-all-checkbox')) {
        const selectAllTh = headerRow.querySelector('th:first-child');
        if (selectAllTh) {
            const selectAllCheckbox = document.createElement('input');
            selectAllCheckbox.type = 'checkbox';
            selectAllCheckbox.className = 'select-all-checkbox';
            selectAllCheckbox.addEventListener('change', function() {
                const rowCheckboxes = document.querySelectorAll('.row-select');
                rowCheckboxes.forEach(checkbox => {
                    checkbox.checked = this.checked;
                    const index = parseInt(checkbox.dataset.index);
                    const record = allTableData[index];
                    
                    if (this.checked) {
                        selectedRecords.add(record);
                    } else {
                        selectedRecords.delete(record);
                    }
                });
                updateSelectedCount();
            });
            selectAllTh.innerHTML = '';
            selectAllTh.appendChild(selectAllCheckbox);
        }
    }
}
    // Function to update table header
    function updateTableHeader(columns) {
    const thead = loadTable.querySelector('thead');
    const headerRow = thead.querySelector('tr');
    
    // Keep the select column and update data columns
    headerRow.innerHTML = '<th>Select</th>';
    columns.forEach(column => {
        const th = document.createElement('th');
        th.textContent = column;
        headerRow.appendChild(th);
    });
    
    // Add select all functionality
    addSelectAllFunctionality();
}
    
    // Function to setup row selection
function setupRowSelection() {
    const rowSelects = document.querySelectorAll('.row-select');
    
    rowSelects.forEach(checkbox => {
        checkbox.addEventListener('change', function() {
            const index = parseInt(this.dataset.index);
            const record = allTableData[index];
            const groupName = this.dataset.group;
            
            if (this.checked) {
                selectedRecords.add(record);
            } else {
                selectedRecords.delete(record);
            }
            
            // Update group checkbox state
            updateGroupCheckboxState(groupName);
            updateSelectedCount();
        });
    });
}
    
function updateGroupCheckboxState(groupName) {
    const groupCheckbox = document.querySelector(`.select-group-checkbox[data-group="${groupName}"]`);
    if (!groupCheckbox) return;
    
    const groupRows = document.querySelectorAll(`.group-data-row[data-group="${groupName}"]`);
    const groupCheckboxes = Array.from(groupRows).map(row => row.querySelector('.row-select'));
    
    if (groupCheckboxes.length === 0) return;
    
    const allChecked = groupCheckboxes.every(cb => cb.checked);
    const someChecked = groupCheckboxes.some(cb => cb.checked);
    
    groupCheckbox.checked = allChecked;
    groupCheckbox.indeterminate = someChecked && !allChecked;
}

function updateSelectedCount() {
    const selectedCount = document.getElementById('selected-count');
    const calculateBtn = document.getElementById('calculate-btn');
    
    selectedCount.textContent = `${selectedRecords.size} selected`;
    calculateBtn.disabled = selectedRecords.size === 0;
}

document.getElementById('calculate-btn').addEventListener('click', function() {
    if (selectedRecords.size > 0) {
        const calculationData = Array.from(selectedRecords);
        
        // Determine selection source based on active tab
        let selectionSource = 'imported';
        let customGroupsData = {};
        
        if (document.getElementById('group-load-cases-link').classList.contains('active')) {
            selectionSource = 'group';
        } else if (document.getElementById('custom-groups-link').classList.contains('active')) {
            selectionSource = 'custom';
            // NEW: Get custom groups data from the current displayed groups
            customGroupsData = getCurrentCustomGroupsData();
        }
        
        console.log('=== CALCULATION DEBUG ===');
        console.log('Selection Source:', selectionSource);
        console.log('Custom Groups Data:', customGroupsData);
        console.log('Records to calculate:', calculationData.length);
        console.log('Selected Groups:', Array.from(selectedGroups));
        console.log('======================');

        if (selectionSource === 'custom' && Object.keys(customGroupsData).length === 0) {
            console.warn('WARNING: No custom groups data found!');
            // Fallback: try to get from selectedGroups
            if (selectedGroups.size > 0) {
                console.log('Attempting fallback using selectedGroups:', Array.from(selectedGroups));
                // You might need additional logic here to map selectedGroups to customGroupsData
            }
        }
        
        const form = document.createElement('form');
        form.method = 'POST';
        form.action = "{% url 'calculation' %}";
        form.target = '_blank';
        form.style.display = 'none';
        
        // Add CSRF token
        const csrfToken = document.createElement('input');
        csrfToken.type = 'hidden';
        csrfToken.name = 'csrfmiddlewaretoken';
        csrfToken.value = '{{ csrf_token }}';
        form.appendChild(csrfToken);
        
        // Add calculation data
        const dataInput = document.createElement('input');
        dataInput.type = 'hidden';
        dataInput.name = 'calculation_data';
        dataInput.value = JSON.stringify(calculationData);
        form.appendChild(dataInput);
        
        // Add selection source
        const sourceInput = document.createElement('input');
        sourceInput.type = 'hidden';
        sourceInput.name = 'selection_source';
        sourceInput.value = selectionSource;
        form.appendChild(sourceInput);
        
        // NEW: Add custom groups data
        const groupsInput = document.createElement('input');
        groupsInput.type = 'hidden';
        groupsInput.name = 'custom_groups_data';
        groupsInput.value = JSON.stringify(customGroupsData);
        form.appendChild(groupsInput);
        
        document.body.appendChild(form);
        form.submit();
        document.body.removeChild(form);
    }
});

// NEW: Enhanced function to get current custom groups data from the displayed table
function getCurrentCustomGroupsData() {
    const customGroupsData = {};
    
    // Check if we're in custom groups view and data is grouped
    const groupHeaders = document.querySelectorAll('.group-header-row');
    
    if (groupHeaders.length > 0) {
        console.log('DEBUG: Found grouped data, extracting custom groups...');
        
        // Find the "Load Case Description" column index dynamically
        const table = document.querySelector('#load-table');
        if (!table) {
            console.warn('DEBUG: Table not found');
            return customGroupsData;
        }
        
        const headers = table.querySelectorAll('thead th');
        let loadCaseColumnIndex = -1;
        headers.forEach((th, index) => {
            if (th.textContent.trim() === 'Load Case Description') {
                loadCaseColumnIndex = index;
            }
        });
        
        if (loadCaseColumnIndex === -1) {
            console.warn('DEBUG: Load Case Description column not found. Checking all columns...');
            // Fallback: try to find any column that might contain load case info
            headers.forEach((th, index) => {
                if (th.textContent.toLowerCase().includes('load') || 
                    th.textContent.toLowerCase().includes('case') ||
                    th.textContent.toLowerCase().includes('description')) {
                    loadCaseColumnIndex = index;
                    console.log('DEBUG: Using fallback column:', th.textContent, 'at index', index);
                }
            });
        }
        
        if (loadCaseColumnIndex === -1) {
            console.warn('DEBUG: No suitable column found for load cases');
            return customGroupsData;
        }
        
        console.log('DEBUG: Load Case Column Index:', loadCaseColumnIndex);
        
        // We have grouped data, extract group information
        groupHeaders.forEach(header => {
            const headerText = header.textContent.trim();
            console.log('DEBUG: Processing header:', headerText);
            
            // Extract group name from header text (e.g., "üìÅ RULE (18 records)" -> "RULE")
            const groupMatch = headerText.match(/üìÅ\s*([^(]+?)\s*\(\d+/);
            if (groupMatch && groupMatch[1]) {
                const groupName = groupMatch[1].trim();
                const loadCases = new Set();
                
                console.log('DEBUG: Found group:', groupName);
                
                // Find all rows belonging to this group
                let nextRow = header.nextElementSibling;
                let recordsProcessed = 0;
                
                while (nextRow && (nextRow.classList.contains('group-data-row') || 
                                 (nextRow.classList.contains('group-spacer-row') && !nextRow.querySelector('td[colspan]')))) {
                    
                    if (nextRow.classList.contains('group-data-row')) {
                        // Get the load case from the correct column
                        const cells = nextRow.querySelectorAll('td');
                        if (cells.length > loadCaseColumnIndex) {
                            const loadCaseDesc = cells[loadCaseColumnIndex].textContent.trim();
                            if (loadCaseDesc) {
                                loadCases.add(loadCaseDesc);
                                recordsProcessed++;
                            }
                        }
                    }
                    nextRow = nextRow.nextElementSibling;
                }
                
                // Store unique load cases for this group
                if (loadCases.size > 0) {
                    customGroupsData[groupName] = Array.from(loadCases);
                    console.log('DEBUG: Group', groupName, 'has', loadCases.size, 'load cases from', recordsProcessed, 'records');
                } else {
                    console.warn('DEBUG: No load cases found for group:', groupName);
                }
            } else {
                console.warn('DEBUG: Could not extract group name from header:', headerText);
            }
        });
    } else {
        console.log('DEBUG: No grouped data found, falling back to UI selection');
        // Fallback: get custom groups from the custom groups selection UI
        const customGroupElements = document.querySelectorAll('.load-case-group[id^="custom-group-"]');
        
        customGroupElements.forEach(groupElement => {
            const groupNameElement = groupElement.querySelector('.group-name-display');
            if (groupNameElement) {
                const groupName = groupNameElement.textContent.trim();
                const checkboxes = groupElement.querySelectorAll('.custom-group-case-checkbox:checked');
                const loadCases = Array.from(checkboxes).map(cb => cb.value);
                
                if (loadCases.length > 0) {
                    customGroupsData[groupName] = loadCases;
                }
            }
        });
    }
    
    console.log('DEBUG: Final Custom Groups Data:', customGroupsData);
    return customGroupsData;
}

    // Handle form submission with AJAX to prevent page refresh
    loadCasesForm.addEventListener('submit', function(e) {
    e.preventDefault();
    
    const formData = new FormData(this);
    
    let selectionSource = 'imported';
    if (document.getElementById('group-load-cases-link').classList.contains('active')) {
        selectionSource = 'group';
    } else if (document.getElementById('custom-groups-link').classList.contains('active')) {
        selectionSource = 'custom';
    }
    
    selectedLoadCases.forEach(caseName => {
        formData.append('selected_load_cases', caseName);
    });
    
    // NEW: Add selected_groups for 'custom'
    if (selectionSource === 'custom') {
        selectedGroups.forEach(groupName => {
            formData.append('selected_groups', groupName);
        });
    }
    
    fetch(this.action, {
        method: 'POST',
        headers: {
            'X-Requested-With': 'XMLHttpRequest',
            'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
        },
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            updateLoadValuesTable(Array.from(selectedLoadCases), selectionSource);
        } else {
            showNotification('Error applying load cases', 'error');
        }
    })
    .catch(error => {
        showNotification('Error applying load cases: ' + error, 'error');
    });
});
    
    // Function to show notifications
document.getElementById('filter-previous-form')?.addEventListener('submit', function(e) {
    e.preventDefault();
    
    const formData = new FormData(this);
    const filterBtn = document.getElementById('filter-previous-btn');
    const originalText = filterBtn.innerHTML;
    
    let selectionSource = 'imported';
    if (document.getElementById('group-load-cases-link').classList.contains('active')) {
        selectionSource = 'group';
    } else if (document.getElementById('custom-groups-link').classList.contains('active')) {
        selectionSource = 'custom';
    }
    
    // Add selection source
    formData.append('selection_source', selectionSource);
    
    // NEW: Add selected_groups for 'custom'
    if (selectionSource === 'custom') {
        selectedGroups.forEach(groupName => {
            formData.append('selected_groups', groupName);
        });
    }
    
    // Show loading state
    filterBtn.innerHTML = '‚è≥ Applying Filter...';
    filterBtn.disabled = true;
    
    console.log('=== FILTER DEBUG INFO ===');
    console.log('Current selected load cases:', Array.from(selectedLoadCases));
    console.log('Selection source:', selectionSource);
    console.log('Selected groups:', Array.from(selectedGroups));  // NEW: Debug selected groups
    console.log('Filter criteria from template:', {{ filter_criteria|default:"{}"|safe }});
    console.log('Structure ID:', structureId);
    console.log('========================');
    
    fetch(this.action, {
        method: 'POST',
        headers: {
            'X-Requested-With': 'XMLHttpRequest',
            'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
        },
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        console.log('=== FILTER RESPONSE ===');
        console.log('Filter response:', data);
        console.log('Record count:', data.record_count);
        console.log('Group count:', data.grouped_data ? Object.keys(data.grouped_data).length : 0);
        console.log('Is grouped:', data.is_grouped);
        console.log('========================');
        
        if (data.success) {
            if (data.is_grouped && data.grouped_data) {
                updateTableWithGroupedData(data.grouped_data, data.all_columns);
                
                let filterType = '';
                if (data.filter_criteria && data.filter_criteria.joint_labels) {
                    filterType = `Joint Labels (${data.filter_criteria.joint_labels.length})`;
                }
                if (data.filter_criteria && data.filter_criteria.set_phase_combinations) {
                    filterType = `Set+Phase Combinations (${data.filter_criteria.set_phase_combinations.length})`;
                }
                
                const groupCount = Object.keys(data.grouped_data).length;
                showNotification(`‚úÖ Filter applied! Found ${data.record_count} records in ${groupCount} groups matching ${filterType}`, 'success');
            } else {
                loadTableBody.innerHTML = '<tr><td colspan="100%" class="text-center text-warning py-4">No matching records found for the current selection</td></tr>';
                selectedCount.textContent = '0 records';
                calculateBtn.disabled = true;
                showNotification('‚ö†Ô∏è No matching records found for the current selection', 'warning');
            }
        } else {
            showNotification('‚ùå Error applying filter', 'error');
        }
    })
    .catch(error => {
        console.error('Filter error:', error);
        showNotification('‚ùå Error applying filter: ' + error, 'error');
    })
    .finally(() => {
        filterBtn.innerHTML = 'üîç Filter by attachment selection';
        filterBtn.disabled = false;
    });
});


// NEW: Function to update table with pre-filtered data
function updateTableWithFilteredData(filteredData) {
    // Clear existing table data
    loadTableBody.innerHTML = '';
    allTableData = []; // Reset all table data
    selectedRecords.clear(); // Clear previous selections
    
    if (filteredData && filteredData.length > 0) {
        // Get columns from the first data item
        const columns = Object.keys(filteredData[0]);
        
        // Update table header if needed
        updateTableHeader(columns);
        
        // Populate table rows with filtered data
        filteredData.forEach((rowData, index) => {
            const row = document.createElement('tr');
            
            // Add select checkbox
            const selectCell = document.createElement('td');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'row-select';
            checkbox.dataset.index = index;
            selectCell.appendChild(checkbox);
            row.appendChild(selectCell);
            
            // Add data cells
            columns.forEach(column => {
                const cell = document.createElement('td');
                const value = rowData[column] || '';
                cell.textContent = value;
                
                // Highlight Set No. and Phase No. columns for better visibility
                if (column === 'Set No.' || column === 'Phase No.') {
                    cell.style.fontWeight = 'bold';
                    cell.style.backgroundColor = '#e8f5e8'; // Light green
                    cell.style.borderLeft = '3px solid #28a745';
                }
                
                // Highlight Load Case Description
                if (column === 'Load Case Description') {
                    cell.style.fontWeight = 'bold';
                    cell.style.backgroundColor = '#e3f2fd'; // Light blue
                }
                
                row.appendChild(cell);
            });
            
            loadTableBody.appendChild(row);
            
            // Store the row data in allTableData
            allTableData.push(rowData);
        });
        
        // Update record count
        selectedCount.textContent = `${filteredData.length} records`;
        calculateBtn.disabled = true; // Start with disabled calculate button
        
        // Add row selection functionality
        setupRowSelection();
        updateSelectedCount();
        
        // Add select all functionality
        addSelectAllFunctionality();
        
    } else {
        loadTableBody.innerHTML = '<tr><td colspan="100%" class="text-center text-muted py-4">No matching records found for the selected Set+Phase combinations</td></tr>';
        selectedCount.textContent = '0 records';
        calculateBtn.disabled = true;
    }
}


// NEW: Update all checkboxes based on filtered results
function updateAllCheckboxes(filteredCases) {
    // Update imported load cases checkboxes
    document.querySelectorAll('#load-cases-results input[type="checkbox"]').forEach(checkbox => {
        checkbox.checked = filteredCases.includes(checkbox.value);
    });
    
    // Update grouped load cases checkboxes
    document.querySelectorAll('.group-case-checkbox').forEach(checkbox => {
        checkbox.checked = filteredCases.includes(checkbox.value);
    });
    
    // Update custom group checkboxes  
    document.querySelectorAll('.custom-group-case-checkbox').forEach(checkbox => {
        checkbox.checked = filteredCases.includes(checkbox.value);
    });
}

// NEW: Enhanced notification function
// NEW: Enhanced notification function with better styling
function showNotification(message, type) {
    // Remove existing notifications
    const existingNotifications = document.querySelectorAll('.custom-notification');
    existingNotifications.forEach(notification => notification.remove());
    
    const notification = document.createElement('div');
    notification.className = `custom-notification alert alert-${type === 'success' ? 'success' : type === 'warning' ? 'warning' : type === 'info' ? 'info' : 'danger'} alert-dismissible fade show`;
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 9999;
        min-width: 300px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        font-weight: 500;
    `;
    
    notification.innerHTML = `
        <div class="d-flex align-items-center">
            <span class="me-2">${getNotificationIcon(type)}</span>
            <span>${message}</span>
        </div>
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
    
    document.body.appendChild(notification);
    
    // Auto-remove after 5 seconds
    setTimeout(() => {
        if (notification.parentNode) {
            notification.remove();
        }
    }, 5000);
}

// Helper function for notification icons
function getNotificationIcon(type) {
    switch(type) {
        case 'success': return '‚úÖ';
        case 'warning': return '‚ö†Ô∏è';
        case 'info': return '‚ÑπÔ∏è';
        case 'error': return '‚ùå';
        default: return 'üí°';
    }
}
    
    // Initialize selected cases display
    updateSelectedLoadCases();
    
    // Initialize table with current data on page load
    if (selectedLoadCases.size > 0) {
        updateLoadValuesTable(Array.from(selectedLoadCases));
    }
});
</script>
"