Read the complete code carefully and act as an experienced developer.

This is the full code for the Calculation page.

Currently:

When we click “Select Group Max Resultant”, we fetch the max resultant rows from all groups and then add all selected records together. This behavior is correct.

When we click “Select Set Max Resultant (Within Groups)”, we fetch max resultant records within each group. However, the system currently performs one combined addition for all selected records, which is not correct.

Required Change
For “Select Set Max Resultant (Within Groups)”, I want the addition to be performed separately for each group, just like we already apply Buffer separately for this option.
Only the addition logic needs to change.
All other functionality should remain exactly the same.


this is views
"def calculation_view(request):
    # Initialize context with default values to avoid UnboundLocalError
    context = {'error': None}
    
    if request.method == 'POST':  # Handle POST requests
        # Get calculation data and selection source from POST parameters
        calculation_data_json = request.POST.get('calculation_data')
        selection_source = request.POST.get('selection_source', 'imported')
        custom_groups_json = request.POST.get('custom_groups_data', '{}')  # NEW: Get custom groups data
        
        if calculation_data_json:
            try:
                calculation_data = json.loads(calculation_data_json)
                custom_groups_data = json.loads(custom_groups_json)  # NEW: Parse custom groups
                
                # Add resultant calculation and unique ID to each record
                for index, record in enumerate(calculation_data):
                    vert = float(record.get('Structure Loads Vert. (lbs)', 0) or 0)
                    trans = float(record.get('Structure Loads Trans. (lbs)', 0) or 0)
                    long = float(record.get('Structure Loads Long. (lbs)', 0) or 0)
                    
                    # Calculate SQRT(Vert² + Trans² + Long²) for each record
                    resultant = math.sqrt(vert**2 + trans**2 + long**2)
                    record['Resultant'] = round(resultant, 2)
                    # Add unique ID for checkbox identification
                    record['record_id'] = f"record_{index}"
                    
                    # Add clean keys for template access
                    record['Structure_Loads_Vert'] = vert
                    record['Structure_Loads_Trans'] = trans
                    record['Structure_Loads_Long'] = long
                    # Store Set No. in data attribute
                    record['Set_No'] = record.get('Set No.', 'Unknown')
                    # Store Load Case Description for grouping
                    record['Load_Case_Description'] = record.get('Load Case Description', 'Unknown')
                
                # NEW: Group data based on selection source with custom groups support
                grouped_data = group_calculation_data(calculation_data, selection_source, custom_groups_data)
                
                # NEW: Create set-wise grouping within each group
                set_wise_data = {}
                set_max_resultants = {}
                
                for group_name, records in grouped_data.items():
                    set_wise_data[group_name] = {}
                    set_max_resultants[group_name] = {}
                    
                    # Group records by Set No. within this group
                    for record in records:
                        set_no = record.get('Set_No', 'Unknown')
                        if set_no not in set_wise_data[group_name]:
                            set_wise_data[group_name][set_no] = []
                        set_wise_data[group_name][set_no].append(record)
                    
                    # Calculate max resultant for each set within this group
                    for set_no, set_records in set_wise_data[group_name].items():
                        resultant_values = [record['Resultant'] for record in set_records]
                        max_resultant = max(resultant_values)
                        max_index = resultant_values.index(max_resultant)
                        
                        set_max_resultants[group_name][set_no] = {
                            'vert': set_records[max_index]['Structure_Loads_Vert'],
                            'trans': set_records[max_index]['Structure_Loads_Trans'],
                            'long': set_records[max_index]['Structure_Loads_Long'],
                            'resultant': max_resultant,
                            'record_id': set_records[max_index]['record_id']
                        }
                        
                        # Add max resultant flag to set records
                        for i, record in enumerate(set_records):
                            if resultant_values[i] == max_resultant:
                                record['set_max_resultant_flag'] = 'yes'
                            else:
                                record['set_max_resultant_flag'] = 'no'
                
                # NEW: Calculate group-wise sums for set max resultants
                group_wise_set_max_sums = {}
                for group_name, set_data in set_max_resultants.items():
                    group_vert = sum([data['vert'] for data in set_data.values()])
                    group_trans = sum([data['trans'] for data in set_data.values()])
                    group_long = sum([data['long'] for data in set_data.values()])
                    group_resultant = math.sqrt(group_vert**2 + group_trans**2 + group_long**2)
                    
                    group_wise_set_max_sums[group_name] = {
                        'vert': group_vert,
                        'trans': group_trans,
                        'long': group_long,
                        'resultant': group_resultant,
                        'set_count': len(set_data)
                    }
                    
                request.session['group_wise_set_max_sums'] = group_wise_set_max_sums
                
                global_set_max_resultants = {}
                all_records = []
                
                # Collect all records from all groups
                for group_name, records in grouped_data.items():
                    all_records.extend(records)
                
                # Group all records by Set No. globally
                global_set_records = {}
                for record in all_records:
                    set_no = record.get('Set_No', 'Unknown')
                    if set_no not in global_set_records:
                        global_set_records[set_no] = []
                    global_set_records[set_no].append(record)
                
                # Find max resultant for each set across all groups
                for set_no, records in global_set_records.items():
                    resultant_values = [record['Resultant'] for record in records]
                    max_resultant = max(resultant_values)
                    max_index = resultant_values.index(max_resultant)
                    
                    global_set_max_resultants[set_no] = {
                        'vert': records[max_index]['Structure_Loads_Vert'],
                        'trans': records[max_index]['Structure_Loads_Trans'],
                        'long': records[max_index]['Structure_Loads_Long'],
                        'resultant': max_resultant,
                        'record_id': records[max_index]['record_id'],
                        'group_name': None  # We don't track which group it came from for global max
                    }
                    
                    # Add global max resultant flag to ALL records (not just within groups)
                    for record in records:
                        if record['Resultant'] == max_resultant:
                            record['global_set_max_resultant_flag'] = 'yes'
                        else:
                            record['global_set_max_resultant_flag'] = 'no'
                
                # Calculate max values for each group and flag max resultant rows
                group_max_values = {}
                max_resultant_values = {}  # Store the actual values that created the max resultant
                max_resultant_indexes = {}  # Store indexes for JavaScript approach
                
                for group_name, records in grouped_data.items():
                    vert_values = [float(record.get('Structure Loads Vert. (lbs)', 0) or 0) for record in records]
                    trans_values = [float(record.get('Structure Loads Trans. (lbs)', 0) or 0) for record in records]
                    long_values = [float(record.get('Structure Loads Long. (lbs)', 0) or 0) for record in records]
                    resultant_values = [record['Resultant'] for record in records]
                    
                    # Find the maximum resultant value
                    max_resultant = max(resultant_values)
                    max_index = resultant_values.index(max_resultant)
                    
                    # Store the actual values that created the max resultant
                    max_resultant_values[group_name] = {
                        'vert': vert_values[max_index],
                        'trans': trans_values[max_index],
                        'long': long_values[max_index],
                        'resultant': max_resultant,
                        'record_id': records[max_index]['record_id']  # Add record ID
                    }
                    
                    # Store index for JavaScript approach
                    max_resultant_indexes[group_name] = max_index
                    
                    # Add a simple flag to each record (as a string to avoid underscore issues)
                    for i, record in enumerate(records):
                        if resultant_values[i] == max_resultant:
                            record['max_resultant_flag'] = 'yes'
                        else:
                            record['max_resultant_flag'] = 'no'
                    
                    group_max_values[group_name] = {
                        'max_vert': max(vert_values),
                        'max_trans': max(trans_values),
                        'max_long': max(long_values),
                        'max_resultant': max_resultant,
                        'count': len(records)
                    }
                
                # Calculate combined values across all groups using the actual values that created max resultants
                combined_vert = sum([values['vert'] for values in max_resultant_values.values()])
                combined_trans = sum([values['trans'] for values in max_resultant_values.values()])
                combined_long = sum([values['long'] for values in max_resultant_values.values()])
                
                # Calculate the SQRT formula for combined values
                combined_sqrt = math.sqrt(combined_vert**2 + combined_trans**2 + combined_long**2)
                
                # Prepare context for template
                context = {
                    'grouped_data': grouped_data,
                    'group_max_values': group_max_values,
                    'max_resultant_values': max_resultant_values,
                    'global_set_max_resultants': global_set_max_resultants,
                    'set_wise_data': set_wise_data,  # NEW: Set-wise grouped data
                    'set_max_resultants': set_max_resultants,  # NEW: Set max resultants
                    'group_wise_set_max_sums': group_wise_set_max_sums,  # NEW: Group-wise sums
                    'combined_vert': combined_vert,
                    'combined_trans': combined_trans,
                    'combined_long': combined_long,
                    'combined_sqrt': combined_sqrt,
                    'calculation_data': calculation_data,
                    'max_resultant_indexes': max_resultant_indexes,
                    'calculation_data_json': json.dumps(calculation_data),
                    'selection_source': selection_source,
                    'custom_groups_data': custom_groups_data,  # NEW: Pass to template for reference
                    'error': None
                }
                
            except json.JSONDecodeError:
                context['error'] = 'Invalid calculation data format'
            except Exception as e:
                context['error'] = f'Error processing data: {str(e)}'
        else:
            context['error'] = 'No calculation data provided'
    
    # Handle GET requests
    elif request.method == 'GET':
        calculation_data_json = request.GET.get('calculation_data')
        selection_source = request.GET.get('selection_source', 'imported')
        custom_groups_json = request.GET.get('custom_groups_data', '{}')  # NEW: Get custom groups data
        
        if calculation_data_json:
            try:
                calculation_data = json.loads(calculation_data_json)
                custom_groups_data = json.loads(custom_groups_json)  # NEW: Parse custom groups
                
                # Add resultant calculation and unique ID to each record
                for index, record in enumerate(calculation_data):
                    vert = float(record.get('Structure Loads Vert. (lbs)', 0) or 0)
                    trans = float(record.get('Structure Loads Trans. (lbs)', 0) or 0)
                    long = float(record.get('Structure Loads Long. (lbs)', 0) or 0)
                    
                    resultant = math.sqrt(vert**2 + trans**2 + long**2)
                    record['Resultant'] = round(resultant, 2)
                    record['record_id'] = f"record_{index}"
                    record['Structure_Loads_Vert'] = vert
                    record['Structure_Loads_Trans'] = trans
                    record['Structure_Loads_Long'] = long
                    record['Set_No'] = record.get('Set No.', 'Unknown')
                    record['Load_Case_Description'] = record.get('Load Case Description', 'Unknown')
                
                # NEW: Group data based on selection source with custom groups support
                grouped_data = group_calculation_data(calculation_data, selection_source, custom_groups_data)
                
                # NEW: Create set-wise grouping within each group for GET requests
                set_wise_data = {}
                set_max_resultants = {}
                
                for group_name, records in grouped_data.items():
                    set_wise_data[group_name] = {}
                    set_max_resultants[group_name] = {}
                    
                    # Group records by Set No. within this group
                    for record in records:
                        set_no = record.get('Set_No', 'Unknown')
                        if set_no not in set_wise_data[group_name]:
                            set_wise_data[group_name][set_no] = []
                        set_wise_data[group_name][set_no].append(record)
                    
                    # Calculate max resultant for each set within this group
                    for set_no, set_records in set_wise_data[group_name].items():
                        resultant_values = [record['Resultant'] for record in set_records]
                        max_resultant = max(resultant_values)
                        max_index = resultant_values.index(max_resultant)
                        
                        set_max_resultants[group_name][set_no] = {
                            'vert': set_records[max_index]['Structure_Loads_Vert'],
                            'trans': set_records[max_index]['Structure_Loads_Trans'],
                            'long': set_records[max_index]['Structure_Loads_Long'],
                            'resultant': max_resultant,
                            'record_id': set_records[max_index]['record_id']
                        }
                        
                        # Add max resultant flag to set records
                        for i, record in enumerate(set_records):
                            if resultant_values[i] == max_resultant:
                                record['set_max_resultant_flag'] = 'yes'
                            else:
                                record['set_max_resultant_flag'] = 'no'
                
                # NEW: Calculate group-wise sums for set max resultants for GET requests
                group_wise_set_max_sums = {}
                for group_name, set_data in set_max_resultants.items():
                    group_vert = sum([data['vert'] for data in set_data.values()])
                    group_trans = sum([data['trans'] for data in set_data.values()])
                    group_long = sum([data['long'] for data in set_data.values()])
                    group_resultant = math.sqrt(group_vert**2 + group_trans**2 + group_long**2)
                    
                    group_wise_set_max_sums[group_name] = {
                        'vert': group_vert,
                        'trans': group_trans,
                        'long': group_long,
                        'resultant': group_resultant,
                        'set_count': len(set_data)
                    }
                
                # Calculate max values
                group_max_values = {}
                max_resultant_values = {}
                max_resultant_indexes = {}
                
                for group_name, records in grouped_data.items():
                    vert_values = [float(record.get('Structure Loads Vert. (lbs)', 0) or 0) for record in records]
                    trans_values = [float(record.get('Structure Loads Trans. (lbs)', 0) or 0) for record in records]
                    long_values = [float(record.get('Structure Loads Long. (lbs)', 0) or 0) for record in records]
                    resultant_values = [record['Resultant'] for record in records]
                    
                    max_resultant = max(resultant_values)
                    max_index = resultant_values.index(max_resultant)
                    
                    max_resultant_values[group_name] = {
                        'vert': vert_values[max_index],
                        'trans': trans_values[max_index],
                        'long': long_values[max_index],
                        'resultant': max_resultant,
                        'record_id': records[max_index]['record_id']
                    }
                    
                    max_resultant_indexes[group_name] = max_index
                    
                    for i, record in enumerate(records):
                        if resultant_values[i] == max_resultant:
                            record['max_resultant_flag'] = 'yes'
                        else:
                            record['max_resultant_flag'] = 'no'
                    
                    group_max_values[group_name] = {
                        'max_vert': max(vert_values),
                        'max_trans': max(trans_values),
                        'max_long': max(long_values),
                        'max_resultant': max_resultant,
                        'count': len(records)
                    }
                request.session['group_wise_set_max_sums'] = group_wise_set_max_sums
                    
                global_set_max_resultants = {}
                all_records = []
                
                # Collect all records from all groups
                for group_name, records in grouped_data.items():
                    all_records.extend(records)
                
                # Group all records by Set No. globally
                global_set_records = {}
                for record in all_records:
                    set_no = record.get('Set_No', 'Unknown')
                    if set_no not in global_set_records:
                        global_set_records[set_no] = []
                    global_set_records[set_no].append(record)
                
                # Find max resultant for each set across all groups
                for set_no, records in global_set_records.items():
                    resultant_values = [record['Resultant'] for record in records]
                    max_resultant = max(resultant_values)
                    max_index = resultant_values.index(max_resultant)
                    
                    global_set_max_resultants[set_no] = {
                        'vert': records[max_index]['Structure_Loads_Vert'],
                        'trans': records[max_index]['Structure_Loads_Trans'],
                        'long': records[max_index]['Structure_Loads_Long'],
                        'resultant': max_resultant,
                        'record_id': records[max_index]['record_id'],
                        'group_name': None
                    }
                    
                    # Add global max resultant flag to ALL records
                    for record in records:
                        if record['Resultant'] == max_resultant:
                            record['global_set_max_resultant_flag'] = 'yes'
                        else:
                            record['global_set_max_resultant_flag'] = 'no'
                
                # Calculate combined values
                combined_vert = sum([values['vert'] for values in max_resultant_values.values()])
                combined_trans = sum([values['trans'] for values in max_resultant_values.values()])
                combined_long = sum([values['long'] for values in max_resultant_values.values()])
                combined_sqrt = math.sqrt(combined_vert**2 + combined_trans**2 + combined_long**2)
                
                context = {
                    'grouped_data': grouped_data,
                    'group_max_values': group_max_values,
                    'max_resultant_values': max_resultant_values,
                    'global_set_max_resultants': global_set_max_resultants,
                    'set_wise_data': set_wise_data,  # NEW: Set-wise grouped data
                    'set_max_resultants': set_max_resultants,  # NEW: Set max resultants
                    'group_wise_set_max_sums': group_wise_set_max_sums,  # NEW: Group-wise sums for GET
                    'combined_vert': combined_vert,
                    'combined_trans': combined_trans,
                    'combined_long': combined_long,
                    'combined_sqrt': combined_sqrt,
                    'calculation_data': calculation_data,
                    'max_resultant_indexes': max_resultant_indexes,
                    'calculation_data_json': json.dumps(calculation_data),
                    'selection_source': selection_source,
                    'custom_groups_data': custom_groups_data,  # NEW: Pass to template
                    'error': None
                }
                
            except json.JSONDecodeError:
                context['error'] = 'Invalid calculation data format'
            except Exception as e:
                context['error'] = f'Error processing data: {str(e)}'
        else:
            context['error'] = 'No calculation data provided'
    else:
        context['error'] = 'Invalid request method'
    
    return render(request, 'app1/calculation.html', context)



def group_calculation_data(calculation_data, selection_source, custom_groups_data=None):
    """Group calculation data based on selection source with custom groups support"""
    grouped_data = {}
    
    if selection_source == 'imported':
        # Group by Load Case Description (individual load cases)
        for record in calculation_data:
            case_name = record.get('Load Case Description', 'Unknown')
            if case_name not in grouped_data:
                grouped_data[case_name] = []
            grouped_data[case_name].append(record)
    
    elif selection_source == 'group':
        # Group by prefix for group load cases (first word before space)
        for record in calculation_data:
            case_name = record.get('Load Case Description', 'Unknown')
            if ' ' in case_name:
                group_name = case_name.split(' ')[0]
            else:
                group_name = case_name
            
            if group_name not in grouped_data:
                grouped_data[group_name] = []
            grouped_data[group_name].append(record)
    
    elif selection_source == 'custom' and custom_groups_data:
        # Group by custom groups using the provided mapping
        # custom_groups_data should be a dict like: {'hurri1': ['Hurricane NL+', 'Hurricane NL-'], ...}
        for group_name, load_cases in custom_groups_data.items():
            grouped_data[group_name] = []
            for record in calculation_data:
                case_name = record.get('Load Case Description', '')
                if case_name in load_cases:
                    grouped_data[group_name].append(record)
            # Remove empty groups
            if not grouped_data[group_name]:
                del grouped_data[group_name]
    
    else:  # Default fallback - group by Set No.
        for record in calculation_data:
            set_no = record.get('Set No.', 'Unknown')
            if set_no not in grouped_data:
                grouped_data[set_no] = []
            grouped_data[set_no].append(record)
    
    return grouped_data

# NEW: Optional helper function to extract custom groups from data
def extract_custom_groups_from_data(calculation_data):
    """
    Try to extract custom group information from the calculation data.
    This is a simplified implementation - in practice, you might want to pass
    this information explicitly from the Load Cases page.
    """
    custom_groups = {}
    
    # Look for patterns that might indicate custom groups
    # This is a heuristic approach - adjust based on your data structure
    for record in calculation_data:
        case_name = record.get('Load Case Description', '')
        # If the case name contains specific patterns, you could group them
        # For now, return empty to fall back to Set No. grouping
        pass
    
    return custom_groups if custom_groups else None"

this is calculation.html 
" <div class="container">
        <header>
            <h2><i class="fas fa-calculator"></i> Calculation Results</h2>
            <p>Detailed analysis of structural load calculations</p>
        </header>
        
        {% if error %}
            <div class="error">
                <i class="fas fa-exclamation-circle"></i> {{ error }}
            </div>
        {% else %}
            <!-- Selection Controls -->
            <div class="card">
                <h3><i class="fas fa-mouse-pointer"></i> Record Selection</h3>
                <!-- In the selection controls section -->
                <div class="selection-controls">
                    <button type="button" id="selectAllBtn" class="btn btn-outline-primary">
                        <i class="fas fa-check-square"></i> Select All
                    </button>
                    <button type="button" id="selectNoneBtn" class="btn btn-outline-secondary">
                        <i class="fas fa-square"></i> Select None
                    </button>
                    <button type="button" id="selectMaxResultantBtn" class="btn btn-outline-info">
                        <i class="fas fa-star"></i> Select Group Max Resultant
                    </button>
                    <button type="button" id="selectSetMaxResultantBtn" class="btn btn-outline-warning">
                        <i class="fas fa-layer-group"></i> Select Set Max Resultant (Within Groups)
                    </button>
                    <!-- NEW BUTTON -->
                    <button type="button" id="selectGlobalSetMaxResultantBtn" class="btn btn-outline-success">
                        <i class="fas fa-globe"></i> Select Global Set Max Resultant
                    </button>
                    <span class="selection-count">Selected: <span id="selectedCount">0</span> records</span>
                </div>
            </div>

          <div class="card">
    <h3><i class="fas fa-list-ol"></i> Selected Records 
        {% if selection_source == 'imported' %}Grouped by Load Case{% endif %}
        {% if selection_source == 'group' %}Grouped by Load Case Groups{% endif %}
        {% if selection_source == 'custom' %}Grouped by Custom Groups{% endif %}
        {% if not selection_source %}Grouped by Set Number{% endif %}
    </h3>
    
    {% for group_name, records in grouped_data.items %}
        <div class="set-container">
            <div class="set-header">
                <h4>
                    <i class="fas fa-cubes"></i> 
                    {% if selection_source == 'imported' %}Load Case: {{ group_name }}{% endif %}
                    {% if selection_source == 'group' %}Group: {{ group_name }}{% endif %}
                    {% if selection_source == 'custom' %}Custom Group: {{ group_name }}{% endif %}
                    {% if not selection_source %}Set No. {{ group_name }}{% endif %}
                    <span class="badge badge-primary">{{ records|length }} records</span>
                </h4>
            </div>

            <!-- Group-wise table showing ALL records -->
            <div class="group-wise-section">
                <h5><i class="fas fa-chart-line"></i> Group Records (All Records)</h5>
                <div class="table-container">
                    <table class="group-records-table">
                        <thead>
                            <tr>
                                <th>Select</th>
                                {% for key in records.0.keys %}
                                    {% if key != 'max_resultant_flag' and key != 'record_id' and key != 'Structure_Loads_Vert' and key != 'Structure_Loads_Trans' and key != 'Structure_Loads_Long' and key != 'Set_No' and key != 'set_max_resultant_flag' %}
                                        <th>{{ key }}</th>
                                    {% endif %}
                                {% endfor %}
                            </tr>
                        </thead>
                        <tbody>
                            {% for record in records %}
                            <tr class="{% if record.max_resultant_flag == 'yes' %}max-resultant-row{% endif %} 
                                    {% if record.global_set_max_resultant_flag == 'yes' %}global-max-resultant-row{% endif %}" 
                                data-record-id="{{ record.record_id }}">
                                <td>
                                    <input type="checkbox" class="record-checkbox" 
                                        data-record-id="{{ record.record_id }}"
                                        data-set-no="{{ record.Set_No }}"
                                        data-vert="{{ record.Structure_Loads_Vert }}"
                                        data-trans="{{ record.Structure_Loads_Trans }}"
                                        data-long="{{ record.Structure_Loads_Long }}"
                                        data-resultant="{{ record.Resultant }}"
                                        {% if record.max_resultant_flag == 'yes' %}checked{% endif %}>
                                    {% if record.global_set_max_resultant_flag == 'yes' %}
                                    <span class="global-max-badge" title="Global Max for Set {{ record.Set_No }}"></span>
                                    {% endif %}
                                </td>
                                {% for key, value in record.items %}
                                    {% if key != 'max_resultant_flag' and key != 'record_id' and key != 'Structure_Loads_Vert' and key != 'Structure_Loads_Trans' and key != 'Structure_Loads_Long' and key != 'Set_No' and key != 'set_max_resultant_flag' %}
                                        {% if key == 'Resultant' %}
                                            <td class="resultant-cell">{{ value }}</td>
                                        {% else %}
                                            <td>{{ value }}</td>
                                        {% endif %}
                                    {% endif %}
                                {% endfor %}
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Set-wise tables for this group -->
            <div class="set-wise-section">
                <h5><i class="fas fa-layer-group"></i> Set-wise Records</h5>
                
                {% for set_no, set_records in set_wise_data.items %}
                    {% if set_no == group_name %}
                        {% for inner_set_no, inner_set_records in set_records.items %}
                        <div class="set-subgroup">
                            <h6>
                                <i class="fas fa-cube"></i> Set {{ inner_set_no }}
                                <span class="badge badge-secondary">{{ inner_set_records|length }} records</span>
                            </h6>
                            
                            <div class="table-container">
                                <table class="set-records-table">
                                    <thead>
                                        <tr>
                                            <th>Select</th>
                                            {% for key in inner_set_records.0.keys %}
                                                {% if key != 'max_resultant_flag' and key != 'record_id' and key != 'Structure_Loads_Vert' and key != 'Structure_Loads_Trans' and key != 'Structure_Loads_Long' and key != 'Set_No' and key != 'set_max_resultant_flag' %}
                                                    <th>{{ key }}</th>
                                                {% endif %}
                                            {% endfor %}
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {% for record in inner_set_records %}
                                        <tr class="{% if record.set_max_resultant_flag == 'yes' %}set-max-resultant-row{% endif %}" 
                                            data-record-id="{{ record.record_id }}">
                                            <td>
                                                <input type="checkbox" class="record-checkbox set-record-checkbox" 
                                                    data-record-id="{{ record.record_id }}"
                                                    data-set-no="{{ record.Set_No }}"
                                                    data-vert="{{ record.Structure_Loads_Vert }}"
                                                    data-trans="{{ record.Structure_Loads_Trans }}"
                                                    data-long="{{ record.Structure_Loads_Long }}"
                                                    data-resultant="{{ record.Resultant }}"
                                                    {% if record.set_max_resultant_flag == 'yes' %}checked{% endif %}>
                                            </td>
                                            {% for key, value in record.items %}
                                                {% if key != 'max_resultant_flag' and key != 'record_id' and key != 'Structure_Loads_Vert' and key != 'Structure_Loads_Trans' and key != 'Structure_Loads_Long' and key != 'Set_No' and key != 'set_max_resultant_flag' %}
                                                    {% if key == 'Resultant' %}
                                                        <td class="resultant-cell">{{ value }}</td>
                                                    {% else %}
                                                        <td>{{ value }}</td>
                                                    {% endif %}
                                                {% endif %}
                                            {% endfor %}
                                        </tr>
                                        {% endfor %}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        {% if not forloop.last %}<hr class="set-divider">{% endif %}
                        {% endfor %}
                    {% endif %}
                {% empty %}
                    <p>No set-wise data available.</p>
                {% endfor %}
            </div>
        </div>
        {% if not forloop.last %}<hr>{% endif %}
    {% endfor %}
</div>

<!-- Group-wise Set Max Resultant Calculations Card -->
<div class="card">
    <h3><i class="fas fa-calculator"></i> Group-wise Set Max Resultant Calculations</h3>
    
    {% for group_name, sums in group_wise_set_max_sums.items %}
    <div class="group-calculation-section">
        <h4>
            <i class="fas fa-layer-group"></i> 
            {% if selection_source == 'imported' %}Load Case: {{ group_name }}{% endif %}
            {% if selection_source == 'group' %}Group: {{ group_name }}{% endif %}
            {% if selection_source == 'custom' %}Custom Group: {{ group_name }}{% endif %}
            {% if not selection_source %}Set No. {{ group_name }}{% endif %}
            <span class="badge badge-info">{{ sums.set_count }} sets</span>
        </h4>
        
        <div class="calculation-results">
            <div class="calculation-grid">
                <div class="calc-item">
                    <label>Sum of Vertical Loads:</label>
                    <span class="calc-value">{{ sums.vert|floatformat:2 }} lbs</span>
                </div>
                <div class="calc-item">
                    <label>Sum of Transverse Loads:</label>
                    <span class="calc-value">{{ sums.trans|floatformat:2 }} lbs</span>
                </div>
                <div class="calc-item">
                    <label>Sum of Longitudinal Loads:</label>
                    <span class="calc-value">{{ sums.long|floatformat:2 }} lbs</span>
                </div>
                <div class="calc-item resultant">
                    <label>Resultant Load:</label>
                    <span class="calc-value">{{ sums.resultant|floatformat:2 }} lbs</span>
                </div>
            </div>
            
            <!-- Buffer Configuration for this Group -->
            <div class="group-buffer-config">
            <h5><i class="fas fa-sliders-h"></i> Apply Buffer to This Group</h5>
            <div class="buffer-controls">
                <div class="buffer-input">
                    <label>Vertical Buffer:</label>
                    <input type="number" class="group-vert-buffer" placeholder="Buffer (lbs)" value="100" step="1" min="0">
                    <select class="group-vert-rounding">
                        <option value="0">No rounding</option>
                        <option value="1">Round to nearest 1</option>
                        <option value="10">Round to nearest 10</option>
                        <option value="100" selected>Round to nearest 100</option>
                        <option value="1000">Round to nearest 1000</option>
                    </select>
                </div>
                <div class="buffer-input">
                    <label>Transverse Buffer:</label>
                    <input type="number" class="group-trans-buffer" placeholder="Buffer (lbs)" value="100" step="1" min="0">
                    <select class="group-trans-rounding">
                        <option value="0">No rounding</option>
                        <option value="1">Round to nearest 1</option>
                        <option value="10">Round to nearest 10</option>
                        <option value="100" selected>Round to nearest 100</option>
                        <option value="1000">Round to nearest 1000</option>
                    </select>
                </div>
                <div class="buffer-input">
                    <label>Longitudinal Buffer:</label>
                    <input type="number" class="group-long-buffer" placeholder="Buffer (lbs)" value="25" step="1" min="0">
                    <select class="group-long-rounding">
                        <option value="0">No rounding</option>
                        <option value="1">Round to nearest 1</option>
                        <option value="10" selected>Round to nearest 10</option>
                        <option value="100">Round to nearest 100</option>
                        <option value="1000">Round to nearest 1000</option>
                    </select>
                </div>
                <button type="button" class="btn btn-sm btn-primary apply-group-buffer" data-group="{{ group_name }}">
                    <i class="fas fa-calculator"></i> Apply Buffer
                </button>
            </div>
            
            <div class="buffered-results" id="bufferedResults{{ group_name }}" style="display: none; margin-top: 10px;">
                <h6>Buffered Results for {{ group_name }}</h6>
                <div class="table-container">
                    <table class="buffered-group-table">
                        <thead>
                            <tr>
                                <th>Load Type</th>
                                <th>Original</th>
                                <th>Buffered</th>
                                <th>Difference</th>
                            </tr>
                        </thead>
                        <tbody id="bufferedBody{{ group_name }}">
                            <!-- Will be populated by JavaScript -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        </div>
    </div>
    {% if not forloop.last %}<hr class="group-divider">{% endif %}
    {% endfor %}
    
    {% if not group_wise_set_max_sums %}
    <div class="no-data-message">
        <p>No group-wise calculations available. Please use "Select Set Max Resultant (Within Groups)" to see calculations.</p>
    </div>
    {% endif %}
</div>
            
            <!-- Custom Selection Results Card -->
            <div class="card">
                <h3><i class="fas fa-layer-group"></i> Custom Selection Results</h3>
                
                <div class="stats-grid" id="customSelectionStats">
                    <!-- Will be populated by JavaScript -->
                </div>
                
                <div class="table-container">
                    <table id="customSelectionTable">
                        <thead>
                            <tr>
                                <th>Set No.</th>
                                <th>Record ID</th>
                                <th>Vert (lbs)</th>
                                <th>Trans (lbs)</th>
                                <th>Long (lbs)</th>
                                <th>Resultant (lbs)</th>
                            </tr>
                        </thead>
                        <tbody id="customSelectionBody">
                            <!-- Will be populated by JavaScript -->
                        </tbody>
                        <tfoot id="customSelectionFooter">
                            <!-- Will be populated by JavaScript -->
                        </tfoot>
                    </table>
                </div>
            </div>



            <div class="card">
                <h3><i class="fas fa-calculator"></i> Buffer Configuration</h3>
                
                <form id="bufferConfigurationForm">
                    <div class="form-group">
                        <label for="bufferConfig">Apply Buffer</label>
                        <div class="checkbox-group">
                            <input type="checkbox" id="applyBuffer" name="apply_buffer">
                            <label for="applyBuffer">Apply buffer to combined loads</label>
                        </div>
                        
                        <div id="bufferSettings" style="display: none; margin-top: 10px;">
                            <h4>Vertical Direction</h4>
                            <div class="direction-config">
                                <input type="number" id="vertBuffer" name="vert_buffer" placeholder="Buffer value (lbs)" value="100" step="1" min="0">
                                <select id="vertRounding" name="vert_rounding">
                                    <option value="0">No rounding</option>
                                    <option value="1">Round to nearest 1</option>
                                    <option value="10">Round to nearest 10</option>
                                    <option value="100" selected>Round to nearest 100</option>
                                    <option value="1000">Round to nearest 1000</option>
                                </select>
                            </div>
                            
                            <h4>Transverse Direction</h4>
                            <div class="direction-config">
                                <input type="number" id="transBuffer" name="trans_buffer" placeholder="Buffer value (lbs)" value="100" step="1" min="0">
                                <select id="transRounding" name="trans_rounding">
                                    <option value="0">No rounding</option>
                                    <option value="1">Round to nearest 1</option>
                                    <option value="10">Round to nearest 10</option>
                                    <option value="100" selected>Round to nearest 100</option>
                                    <option value="1000">Round to nearest 1000</option>
                                </select>
                            </div>
                            
                            <h4>Longitudinal Direction</h4>
                            <div class="direction-config">
                                <input type="number" id="longBuffer" name="long_buffer" placeholder="Buffer value (lbs)" value="25" step="1" min="0">
                                <select id="longRounding" name="long_rounding">
                                    <option value="0">No rounding</option>
                                    <option value="1">Round to nearest 1</option>
                                    <option value="10" selected>Round to nearest 10</option>
                                    <option value="100">Round to nearest 100</option>
                                    <option value="1000">Round to nearest 1000</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    
                    <button type="button" id="applyBufferBtn" class="btn btn-primary">
                        <i class="fas fa-calculator"></i> Apply Buffer
                    </button>
                </form>
                
                <div id="bufferedResults" style="display: none; margin-top: 20px;">
                    <h4>Buffered Results</h4>
                    <div class="table-container">
                        <table id="bufferedLoadsTable">
                            <thead>
                                <tr>
                                    <th>Set No.</th>
                                    <th>Vert (lbs)</th>
                                    <th>Trans (lbs)</th>
                                    <th>Long (lbs)</th>
                                    <th>Resultant (lbs)</th>
                                </tr>
                            </thead>
                            <tbody>
                                <!-- Results will be populated by JavaScript -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        
            <div class="action-buttons">
                <button class="btn btn-primary" onclick="window.print()">
                    <i class="fas fa-print"></i> Print Report
                </button>

                <button class="btn btn-info" onclick="goToLoadConditions()">
                    <i class="fas fa-table"></i> Configure Load Conditions
                </button>

                <button class="btn btn-secondary" onclick="window.location.href='/'">
                    <i class="fas fa-home"></i> Back to Home
                </button>
            </div>
        {% endif %}
    </div>
        
            
        <footer>
            <p>Generated on {% now "F j, Y, g:i a" %} | Structural Analysis Tool</p>
        </footer>
    </div>

    <script>
    // JavaScript approach to highlight rows as a backup
    document.addEventListener('DOMContentLoaded', function() {
        // Check if we have max resultant indexes from Django
        {% if max_resultant_indexes %}
            const maxResultantIndexes = {
                {% for set_no, index in max_resultant_indexes.items %}
                    '{{ set_no }}': {{ index }},
                {% endfor %}
            };
            
            // Find all set containers
            const setContainers = document.querySelectorAll('.set-container');
            
            setContainers.forEach(container => {
                // Extract set number from header
                const header = container.querySelector('.set-header h4');
                if (header) {
                    const setText = header.textContent || header.innerText;
                    const setMatch = setText.match(/Set No\.\s*(\S+)/);
                    
                    if (setMatch && setMatch[1]) {
                        const setNo = setMatch[1].trim();
                        const maxIndex = maxResultantIndexes[setNo];
                        
                        if (maxIndex !== undefined) {
                            // Find the table rows in this set container
                            const rows = container.querySelectorAll('tbody tr');
                            if (rows.length > maxIndex) {
                                rows[maxIndex].classList.add('max-resultant-row');
                            }
                        }
                    }
                }
            });
        {% endif %}
    });
</script>

<script>
function goToLoadConditions() {
    const calculationData = {{ calculation_data_json|safe }};
    const processedSums = window.currentCustomSelection; // This contains the buffered sums
    
    // Create a form to submit the data
    const form = document.createElement('form');
    form.method = 'POST';
    form.action = "{% url 'load_condition' %}";
    
    // Add CSRF token
    const csrfToken = document.createElement('input');
    csrfToken.type = 'hidden';
    csrfToken.name = 'csrfmiddlewaretoken';
    csrfToken.value = '{{ csrf_token }}';
    form.appendChild(csrfToken);
    
    // Add calculation data
    const dataInput = document.createElement('input');
    dataInput.type = 'hidden';
    dataInput.name = 'calculation_data';
    dataInput.value = JSON.stringify(calculationData);
    form.appendChild(dataInput);
    
    // NEW: Add processed sums
    const processedSumsInput = document.createElement('input');
    processedSumsInput.type = 'hidden';
    processedSumsInput.name = 'processed_sums';
    processedSumsInput.value = JSON.stringify(processedSums);
    form.appendChild(processedSumsInput);
    
    // Submit the form
    document.body.appendChild(form);
    form.submit();
}
</script>


<script>
// Buffer Configuration Logic
// Corrected Buffer Configuration Logic
document.addEventListener('DOMContentLoaded', function() {
    // Toggle buffer settings visibility
    const applyBufferCheckbox = document.getElementById('applyBuffer');
    const bufferSettings = document.getElementById('bufferSettings');
    
    if (applyBufferCheckbox && bufferSettings) {
        applyBufferCheckbox.addEventListener('change', function() {
            bufferSettings.style.display = this.checked ? 'block' : 'none';
        });
    }
    
    // Handle buffer application
    const applyBufferBtn = document.getElementById('applyBufferBtn');
    if (applyBufferBtn) {
        applyBufferBtn.addEventListener('click', function() {
            applyBufferToResults();
        });
    }
    
    // Correct rounding function that handles both positive and negative numbers
    function roundToNearest(value, rounding) {
        if (rounding === 0) return value;
        return Math.sign(value) * Math.ceil(Math.abs(value) / rounding) * rounding;
    }
    
    function applyBufferToResults() {
        // Get buffer settings
        const applyBuffer = document.getElementById('applyBuffer').checked;
        const vertBuffer = parseFloat(document.getElementById('vertBuffer').value) || 0;
        const transBuffer = parseFloat(document.getElementById('transBuffer').value) || 0;
        const longBuffer = parseFloat(document.getElementById('longBuffer').value) || 0;
        const vertRounding = parseInt(document.getElementById('vertRounding').value) || 0;
        const transRounding = parseInt(document.getElementById('transRounding').value) || 0;
        const longRounding = parseInt(document.getElementById('longRounding').value) || 0;
        
        // Get the max resultant values from Django context
        const maxResultantValues = {
            {% for set_no, values in max_resultant_values.items %}
                '{{ set_no }}': {
                    vert: {{ values.vert }},
                    trans: {{ values.trans }},
                    long: {{ values.long }},
                    resultant: {{ values.resultant }}
                },
            {% endfor %}
        };
        
        // Get the original sum values
        const originalSumValues = {
            vert: {{ combined_vert }},
            trans: {{ combined_trans }},
            long: {{ combined_long }},
            resultant: {{ combined_sqrt }}
        };
        
        // Create processed sum values (initially same as original)
        let processedSumValues = {...originalSumValues};
        
        // Apply buffer and rounding only to sum values if enabled
        if (applyBuffer) {
            // Apply buffers to sum values
            processedSumValues.vert = applyBufferWithSign(originalSumValues.vert, vertBuffer);
            processedSumValues.trans = applyBufferWithSign(originalSumValues.trans, transBuffer);
            processedSumValues.long = applyBufferWithSign(originalSumValues.long, longBuffer);
            
            // Apply rounding to sum values using correct rounding function
            if (vertRounding > 0) {
                processedSumValues.vert = roundToNearest(processedSumValues.vert, vertRounding);
            }
            if (transRounding > 0) {
                processedSumValues.trans = roundToNearest(processedSumValues.trans, transRounding);
            }
            if (longRounding > 0) {
                processedSumValues.long = roundToNearest(processedSumValues.long, longRounding);
            }
            
            // Recalculate resultant after buffer and rounding
            processedSumValues.resultant = Math.sqrt(
                processedSumValues.vert**2 + 
                processedSumValues.trans**2 + 
                processedSumValues.long**2
            );
        }
        
        // Display buffered results
        displayBufferedResults(maxResultantValues, processedSumValues, originalSumValues, {
            applyBuffer,
            vertBuffer,
            transBuffer,
            longBuffer,
            vertRounding,
            transRounding,
            longRounding
        });
    }
    
    function displayBufferedResults(setValues, processedSumValues, originalSumValues, settings) {
        const tableBody = document.querySelector('#bufferedLoadsTable tbody');
        tableBody.innerHTML = '';
        
        // Add individual set rows (unchanged)
        for (const [setNo, values] of Object.entries(setValues)) {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${setNo}</td>
                <td>${values.vert.toFixed(2)}</td>
                <td>${values.trans.toFixed(2)}</td>
                <td>${values.long.toFixed(2)}</td>
                <td>${values.resultant.toFixed(2)}</td>
            `;
            tableBody.appendChild(row);
        }
        
        // Add original sum row
        const originalSumRow = document.createElement('tr');
        originalSumRow.classList.add('original-sum');
        originalSumRow.innerHTML = `
            <td><strong>Original Sum</strong></td>
            <td><strong>${originalSumValues.vert.toFixed(2)}</strong></td>
            <td><strong>${originalSumValues.trans.toFixed(2)}</strong></td>
            <td><strong>${originalSumValues.long.toFixed(2)}</strong></td>
            <td><strong>${originalSumValues.resultant.toFixed(2)}</strong></td>
        `;
        tableBody.appendChild(originalSumRow);
        
        // Add processed sum row (only if buffer was applied)
        if (settings.applyBuffer) {
            const processedSumRow = document.createElement('tr');
            processedSumRow.classList.add('highlight');
            processedSumRow.innerHTML = `
                <td><strong>Processed Sum</strong></td>
                <td><strong>${processedSumValues.vert.toFixed(2)}</strong></td>
                <td><strong>${processedSumValues.trans.toFixed(2)}</strong></td>
                <td><strong>${processedSumValues.long.toFixed(2)}</strong></td>
                <td><strong>${processedSumValues.resultant.toFixed(2)}</strong></td>
            `;
            tableBody.appendChild(processedSumRow);
        }
        
        // Add settings info
        if (settings.applyBuffer) {
            const settingsRow = document.createElement('tr');
            settingsRow.classList.add('settings-info');
            settingsRow.innerHTML = `
                <td colspan="5" style="text-align: left; font-style: italic;">
                    Applied settings: 
                    Vert: +${settings.vertBuffer} lbs, Round to ${settings.vertRounding} | 
                    Trans: +${settings.transBuffer} lbs, Round to ${settings.transRounding} | 
                    Long: +${settings.longBuffer} lbs, Round to ${settings.longRounding}
                </td>
            `;
            tableBody.appendChild(settingsRow);
        }
        
        // Show results section
        document.getElementById('bufferedResults').style.display = 'block';
    }

    const applyGroupBufferBtns = document.querySelectorAll('.apply-group-buffer');
    applyGroupBufferBtns.forEach(btn => {
        btn.addEventListener('click', function() {
            const groupName = this.getAttribute('data-group');
            applyBufferToGroup(groupName);
        });
    });

    window.groupWiseBufferedSums = {};
    
    // NEW: Function to apply buffer to a specific group
    function applyBufferToGroup(groupName) {
        // Get group sums from Django context
        const groupSums = {
            {% for group_name, sums in group_wise_set_max_sums.items %}
                '{{ group_name }}': {
                    vert: {{ sums.vert }},
                    trans: {{ sums.trans }},
                    long: {{ sums.long }},
                    resultant: {{ sums.resultant }}
                },
            {% endfor %}
        };
        
        if (!groupSums[groupName]) {
            alert(`No data available for group: ${groupName}`);
            return;
        }
        
        const originalValues = groupSums[groupName];
        
        // Get buffer inputs for this group
        const bufferControls = document.querySelector(`.apply-group-buffer[data-group="${groupName}"]`).closest('.buffer-controls');
        const vertBuffer = parseFloat(bufferControls.querySelector('.group-vert-buffer').value) || 0;
        const transBuffer = parseFloat(bufferControls.querySelector('.group-trans-buffer').value) || 0;
        const longBuffer = parseFloat(bufferControls.querySelector('.group-long-buffer').value) || 0;
        const vertRounding = parseInt(bufferControls.querySelector('.group-vert-rounding').value) || 0;
        const transRounding = parseInt(bufferControls.querySelector('.group-trans-rounding').value) || 0;
        const longRounding = parseInt(bufferControls.querySelector('.group-long-rounding').value) || 0;
        
        // Apply buffers with sign consideration
        let processedValues = {
            vert: applyBufferWithSign(originalValues.vert, vertBuffer),
            trans: applyBufferWithSign(originalValues.trans, transBuffer),
            long: applyBufferWithSign(originalValues.long, longBuffer)
        };
        
        // Apply rounding
        if (vertRounding > 0) processedValues.vert = roundToNearest(processedValues.vert, vertRounding);
        if (transRounding > 0) processedValues.trans = roundToNearest(processedValues.trans, transRounding);
        if (longRounding > 0) processedValues.long = roundToNearest(processedValues.long, longRounding);
        
        // Recalculate resultant
        processedValues.resultant = Math.sqrt(processedValues.vert**2 + processedValues.trans**2 + processedValues.long**2);
        
        // Display results
        displayGroupBufferedResults(groupName, originalValues, processedValues, { vertBuffer, transBuffer, longBuffer, vertRounding, transRounding, longRounding });
            window.groupWiseBufferedSums[groupName] = {
            vert: processedValues.vert,
            trans: processedValues.trans,
            long: processedValues.long,
            resultant: processedValues.resultant,
            groupName: groupName
        };
    }
    
    // NEW: Function to apply buffer based on sign (same as global)
    function applyBufferWithSign(originalValue, buffer) {
        return originalValue >= 0 ? originalValue + buffer : originalValue - buffer;
    }
    
    // NEW: Function to display buffered results for a group
    function displayGroupBufferedResults(groupName, originalValues, processedValues, settings) {
        const tableBody = document.getElementById(`bufferedBody${groupName}`);
        tableBody.innerHTML = '';
        
        // Vertical
        const vertRow = document.createElement('tr');
        vertRow.innerHTML = `
            <td>Vertical</td>
            <td>${originalValues.vert.toFixed(2)}</td>
            <td>${processedValues.vert.toFixed(2)}</td>
            <td>${(processedValues.vert - originalValues.vert).toFixed(2)}</td>
        `;
        tableBody.appendChild(vertRow);
        
        // Transverse
        const transRow = document.createElement('tr');
        transRow.innerHTML = `
            <td>Transverse</td>
            <td>${originalValues.trans.toFixed(2)}</td>
            <td>${processedValues.trans.toFixed(2)}</td>
            <td>${(processedValues.trans - originalValues.trans).toFixed(2)}</td>
        `;
        tableBody.appendChild(transRow);
        
        // Longitudinal
        const longRow = document.createElement('tr');
        longRow.innerHTML = `
            <td>Longitudinal</td>
            <td>${originalValues.long.toFixed(2)}</td>
            <td>${processedValues.long.toFixed(2)}</td>
            <td>${(processedValues.long - originalValues.long).toFixed(2)}</td>
        `;
        tableBody.appendChild(longRow);
        
        // Resultant
        const resultantRow = document.createElement('tr');
        resultantRow.classList.add('highlight');
        resultantRow.innerHTML = `
            <td><strong>Resultant</strong></td>
            <td><strong>${originalValues.resultant.toFixed(2)}</strong></td>
            <td><strong>${processedValues.resultant.toFixed(2)}</strong></td>
            <td><strong>${(processedValues.resultant - originalValues.resultant).toFixed(2)}</strong></td>
        `;
        tableBody.appendChild(resultantRow);
        
        // Settings info
        const settingsRow = document.createElement('tr');
        settingsRow.innerHTML = `
            <td colspan="4" style="text-align: left; font-style: italic;">
                Applied: Vert +${settings.vertBuffer} (round to ${settings.vertRounding}) | 
                Trans +${settings.transBuffer} (round to ${settings.transRounding}) | 
                Long +${settings.longBuffer} (round to ${settings.longRounding})
            </td>
        `;
        tableBody.appendChild(settingsRow);
        
        // Show the results section
        document.getElementById(`bufferedResults${groupName}`).style.display = 'block';
    }
});


</script>

<script>
// Custom Selection Logic
document.addEventListener('DOMContentLoaded', function() {
    // Initialize selection management
    initializeSelection();
    
    // Original buffer logic (keep as is)
    initializeBufferLogic();
});

function initializeSelection() {
    const checkboxes = document.querySelectorAll('.record-checkbox');
    const selectAllBtn = document.getElementById('selectAllBtn');
    const selectNoneBtn = document.getElementById('selectNoneBtn');
    const selectMaxResultantBtn = document.getElementById('selectMaxResultantBtn');
    const selectSetMaxResultantBtn = document.getElementById('selectSetMaxResultantBtn'); // NEW
    const selectGlobalSetMaxResultantBtn = document.getElementById('selectGlobalSetMaxResultantBtn');
    const selectedCountSpan = document.getElementById('selectedCount');
    
    // Update selection count and display
    function updateSelection() {
        const selectedCheckboxes = document.querySelectorAll('.record-checkbox:checked');
        selectedCountSpan.textContent = selectedCheckboxes.length;
        
        // Update row styling
        checkboxes.forEach(checkbox => {
            const row = checkbox.closest('tr');
            if (checkbox.checked) {
                row.classList.add('selected-record');
            } else {
                row.classList.remove('selected-record');
            }
        });
        
        // Update custom selection display
        updateCustomSelectionDisplay();
    }
    
    // Select all records
    selectAllBtn.addEventListener('click', function() {
        checkboxes.forEach(checkbox => {
            checkbox.checked = true;
        });
        updateSelection();
    });
    
    // Select none
    selectNoneBtn.addEventListener('click', function() {
        checkboxes.forEach(checkbox => {
            checkbox.checked = false;
        });
        updateSelection();
    });

    // Select set max resultant (within groups)
    selectSetMaxResultantBtn.addEventListener('click', function() {
        checkboxes.forEach(checkbox => {
            checkbox.checked = false;
        });
        
        // Check set max resultant rows (within groups)
        const setMaxResultantRows = document.querySelectorAll('.set-max-resultant-row');
        setMaxResultantRows.forEach(row => {
            const checkbox = row.querySelector('.record-checkbox');
            if (checkbox) {
                checkbox.checked = true;
            }
        });
        updateSelection();
    });

    // NEW: Select GLOBAL set max resultant (across all groups)
    selectGlobalSetMaxResultantBtn.addEventListener('click', function() {
        checkboxes.forEach(checkbox => {
            checkbox.checked = false;
        });
        
        // Check global set max resultant rows
        const globalSetMaxResultantRows = document.querySelectorAll('tr[data-record-id]');
        globalSetMaxResultantRows.forEach(row => {
            const checkbox = row.querySelector('.record-checkbox');
            // Check if this row has the global max resultant flag
            const recordId = row.dataset.recordId;
            if (checkbox && row.classList.contains('global-max-resultant-row')) {
                checkbox.checked = true;
            }
        });
        updateSelection();
    });
    
    // Select max resultant records (group-wise)
    selectMaxResultantBtn.addEventListener('click', function() {
        checkboxes.forEach(checkbox => {
            checkbox.checked = false;
        });
        
        // Check max resultant rows
        const maxResultantRows = document.querySelectorAll('.max-resultant-row');
        maxResultantRows.forEach(row => {
            const checkbox = row.querySelector('.record-checkbox');
            if (checkbox) {
                checkbox.checked = true;
            }
        });
        updateSelection();
    });
    
    // Add event listeners to checkboxes
    checkboxes.forEach(checkbox => {
        checkbox.addEventListener('change', updateSelection);
    });
    
    // Initial update
    updateSelection();
}


function updateCustomSelectionDisplay() {
    const selectedCheckboxes = document.querySelectorAll('.record-checkbox:checked');
    const statsGrid = document.getElementById('customSelectionStats');
    const tableBody = document.getElementById('customSelectionBody');
    const tableFooter = document.getElementById('customSelectionFooter');
    
    // Clear previous content
    statsGrid.innerHTML = '';
    tableBody.innerHTML = '';
    tableFooter.innerHTML = '';
    
    if (selectedCheckboxes.length === 0) {
        statsGrid.innerHTML = '<p>No records selected. Please select records using the checkboxes above.</p>';
        return;
    }
    
    let totalVert = 0;
    let totalTrans = 0;
    let totalLong = 0;
    const selectedRecords = [];
    
    // Process selected records
    selectedCheckboxes.forEach(checkbox => {
        const vert = parseFloat(checkbox.dataset.vert) || 0;
        const trans = parseFloat(checkbox.dataset.trans) || 0;
        const long = parseFloat(checkbox.dataset.long) || 0;
        const resultant = parseFloat(checkbox.dataset.resultant) || 0;
        const setNo = checkbox.dataset.setNo || 'Unknown';
        const recordId = checkbox.dataset.recordId;
        
        totalVert += vert;
        totalTrans += trans;
        totalLong += long;
        
        selectedRecords.push({
            setNo,
            recordId,
            vert,
            trans,
            long,
            resultant
        });
    });
    
    // Calculate final resultant
    const finalResultant = Math.sqrt(totalVert**2 + totalTrans**2 + totalLong**2);
    
    // Update stats grid
    statsGrid.innerHTML = `
        <div class="stat-card">
            <div class="stat-label">Selected Records</div>
            <div class="stat-value">${selectedCheckboxes.length}</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Total Vert</div>
            <div class="stat-value">${totalVert.toFixed(2)}</div>
            <div class="stat-label">(lbs)</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Total Trans</div>
            <div class="stat-value">${totalTrans.toFixed(2)}</div>
            <div class="stat-label">(lbs)</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Total Long</div>
            <div class="stat-value">${totalLong.toFixed(2)}</div>
            <div class="stat-label">(lbs)</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Resultant</div>
            <div class="stat-value">${finalResultant.toFixed(2)}</div>
            <div class="stat-label">(lbs)</div>
        </div>
    `;
    
    // Update table body
    selectedRecords.forEach(record => {
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${record.setNo}</td>
            <td>${record.recordId}</td>
            <td>${record.vert.toFixed(2)}</td>
            <td>${record.trans.toFixed(2)}</td>
            <td>${record.long.toFixed(2)}</td>
            <td>${record.resultant.toFixed(2)}</td>
        `;
        tableBody.appendChild(row);
    });
    
    // Update table footer with totals
    tableFooter.innerHTML = `
        <tr class="highlight">
            <td colspan="2"><strong>Custom Selection Sum</strong></td>
            <td><strong>${totalVert.toFixed(2)}</strong></td>
            <td><strong>${totalTrans.toFixed(2)}</strong></td>
            <td><strong>${totalLong.toFixed(2)}</strong></td>
            <td><strong>${finalResultant.toFixed(2)}</strong></td>
        </tr>
    `;
    
    // Store current custom selection for buffer calculations
    window.currentCustomSelection = {
        totalVert,
        totalTrans,
        totalLong,
        finalResultant,
        selectedRecords
    };
}

function initializeBufferLogic() {
    // Toggle buffer settings visibility
    const applyBufferCheckbox = document.getElementById('applyBuffer');
    const bufferSettings = document.getElementById('bufferSettings');
    
    if (applyBufferCheckbox && bufferSettings) {
        applyBufferCheckbox.addEventListener('change', function() {
            bufferSettings.style.display = this.checked ? 'block' : 'none';
        });
    }
    
    // Correct rounding function that handles both positive and negative numbers
    function roundToNearest(value, rounding) {
        if (rounding === 0) return value;
        return Math.sign(value) * Math.ceil(Math.abs(value) / rounding) * rounding;
    }
    
    // Handle buffer application
    const applyBufferBtn = document.getElementById('applyBufferBtn');
    if (applyBufferBtn) {
        applyBufferBtn.addEventListener('click', function() {
            applyBufferToCustomSelection();
        });
    }
    
    function applyBufferToCustomSelection() {
        if (!window.currentCustomSelection) {
            alert('Please select some records first.');
            return;
        }
        
        // Get buffer settings
        const applyBuffer = document.getElementById('applyBuffer').checked;
        const vertBuffer = parseFloat(document.getElementById('vertBuffer').value) || 0;
        const transBuffer = parseFloat(document.getElementById('transBuffer').value) || 0;
        const longBuffer = parseFloat(document.getElementById('longBuffer').value) || 0;
        const vertRounding = parseInt(document.getElementById('vertRounding').value) || 0;
        const transRounding = parseInt(document.getElementById('transRounding').value) || 0;
        const longRounding = parseInt(document.getElementById('longRounding').value) || 0;
        
        const originalValues = window.currentCustomSelection;
        
        // Create processed values (initially same as original)
        let processedValues = {...originalValues};
        
        // Apply buffer and rounding only if enabled
        if (applyBuffer) {
            // CORRECTED: Apply buffers with sign consideration
            processedValues.totalVert = applyBufferWithSign(originalValues.totalVert, vertBuffer);
            processedValues.totalTrans = applyBufferWithSign(originalValues.totalTrans, transBuffer);
            processedValues.totalLong = applyBufferWithSign(originalValues.totalLong, longBuffer);
            
            // Apply rounding to sum values using correct rounding function
            if (vertRounding > 0) {
                processedValues.totalVert = roundToNearest(processedValues.totalVert, vertRounding);
            }
            if (transRounding > 0) {
                processedValues.totalTrans = roundToNearest(processedValues.totalTrans, transRounding);
            }
            if (longRounding > 0) {
                processedValues.totalLong = roundToNearest(processedValues.totalLong, longRounding);
            }
            
            // Recalculate resultant after buffer and rounding
            processedValues.finalResultant = Math.sqrt(
                processedValues.totalVert**2 + 
                processedValues.totalTrans**2 + 
                processedValues.totalLong**2
            );
            
            // CRITICAL FIX: Update window.currentCustomSelection with PROCESSED values
            window.currentCustomSelection = processedValues;
        }
        
        // Display buffered results
        displayBufferedResults(processedValues, originalValues, {
            applyBuffer,
            vertBuffer,
            transBuffer,
            longBuffer,
            vertRounding,
            transRounding,
            longRounding
        });
    }
    
    // NEW: Function to apply buffer based on sign
    function applyBufferWithSign(originalValue, buffer) {
        if (originalValue >= 0) {
            // For positive values: add buffer
            return originalValue + buffer;
        } else {
            // For negative values: subtract buffer
            return originalValue - buffer;
        }
    }
    
    // NEW: Function to get buffer operation symbol for display
    function getBufferSymbol(originalValue) {
        return originalValue >= 0 ? '+' : '-';
    }
    
    function displayBufferedResults(processedValues, originalValues, settings) {
    const tableBody = document.querySelector('#bufferedLoadsTable tbody');
    tableBody.innerHTML = '';
    
    // Add individual record rows
    originalValues.selectedRecords.forEach(record => {
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${record.setNo}</td>
            <td>${record.vert.toFixed(2)}</td>
            <td>${record.trans.toFixed(2)}</td>
            <td>${record.long.toFixed(2)}</td>
            <td>${record.resultant.toFixed(2)}</td>
        `;
        tableBody.appendChild(row);
    });
    
    // Add original sum row
    const originalSumRow = document.createElement('tr');
    originalSumRow.classList.add('original-sum');
    originalSumRow.innerHTML = `
        <td><strong>Original Sum</strong></td>
        <td><strong>${originalValues.totalVert.toFixed(2)}</strong></td>
        <td><strong>${originalValues.totalTrans.toFixed(2)}</strong></td>
        <td><strong>${originalValues.totalLong.toFixed(2)}</strong></td>
        <td><strong>${originalValues.finalResultant.toFixed(2)}</strong></td>
    `;
    tableBody.appendChild(originalSumRow);
    
    // Add processed sum row (only if buffer was applied)
    if (settings.applyBuffer) {
        const processedSumRow = document.createElement('tr');
        processedSumRow.classList.add('highlight');
        processedSumRow.innerHTML = `
            <td><strong>Processed Sum</strong></td>
            <td><strong>${processedValues.totalVert.toFixed(2)}</strong></td>
            <td><strong>${processedValues.totalTrans.toFixed(2)}</strong></td>
            <td><strong>${processedValues.totalLong.toFixed(2)}</strong></td>
            <td><strong>${processedValues.finalResultant.toFixed(2)}</strong></td>
        `;
        tableBody.appendChild(processedSumRow);
        
        // CRITICAL: Ensure the processed values are stored for Load Conditions
        window.currentCustomSelection = processedValues;
        
        // Add settings info with correct symbols
        const settingsRow = document.createElement('tr');
        settingsRow.classList.add('settings-info');
        settingsRow.innerHTML = `
            <td colspan="5" style="text-align: left; font-style: italic;">
                Applied settings: 
                Vert: ${getBufferSymbol(originalValues.totalVert)}${settings.vertBuffer} lbs, Round to ${settings.vertRounding} | 
                Trans: ${getBufferSymbol(originalValues.totalTrans)}${settings.transBuffer} lbs, Round to ${settings.transRounding} | 
                Long: ${getBufferSymbol(originalValues.totalLong)}${settings.longBuffer} lbs, Round to ${settings.longRounding}
            </td>
        `;
        tableBody.appendChild(settingsRow);
    }
    
    // Show results section
    document.getElementById('bufferedResults').style.display = 'block';
}
}

// Keep the existing JavaScript functions (goToLoadConditions, etc.)
function goToLoadConditions() {
    const calculationData = {{ calculation_data_json|safe }};
    
    // Determine which data to send based on what was calculated
    let processedSums = null;
    let groupWiseSums = null;
    
    // Check if group-wise buffered sums exist (for "Select Set Max Resultant Within Groups")
    if (window.groupWiseBufferedSums && Object.keys(window.groupWiseBufferedSums).length > 0) {
        groupWiseSums = window.groupWiseBufferedSums;
        console.log('Sending group-wise buffered sums:', groupWiseSums);
    }
    // Check if custom selection with buffer exists (for "Select Group Max Resultant")
    else if (window.currentCustomSelection && window.currentCustomSelection.totalVert !== undefined) {
        processedSums = window.currentCustomSelection;
        console.log('Sending processed sums from custom selection:', processedSums);
    }
    // Fallback to original custom selection without buffer
    else if (window.currentCustomSelection) {
        processedSums = window.currentCustomSelection;
        console.log('Sending original custom selection:', processedSums);
    }

    // Create a form to submit the data
    const form = document.createElement('form');
    form.method = 'POST';
    form.action = "{% url 'load_condition' %}";
    
    // Add CSRF token
    const csrfToken = document.createElement('input');
    csrfToken.type = 'hidden';
    csrfToken.name = 'csrfmiddlewaretoken';
    csrfToken.value = '{{ csrf_token }}';
    form.appendChild(csrfToken);
    
    // Add calculation data
    const dataInput = document.createElement('input');
    dataInput.type = 'hidden';
    dataInput.name = 'calculation_data';
    dataInput.value = JSON.stringify(calculationData);
    form.appendChild(dataInput);
    
    // Add processed sums (for "Select Group Max Resultant")
    if (processedSums) {
        const processedSumsInput = document.createElement('input');
        processedSumsInput.type = 'hidden';
        processedSumsInput.name = 'processed_sums';
        processedSumsInput.value = JSON.stringify(processedSums);
        form.appendChild(processedSumsInput);
    }
    
    // Add group-wise buffered sums (for "Select Set Max Resultant Within Groups")
    if (groupWiseSums) {
        const groupWiseSumsInput = document.createElement('input');
        groupWiseSumsInput.type = 'hidden';
        groupWiseSumsInput.name = 'group_wise_buffered_sums';
        groupWiseSumsInput.value = JSON.stringify(groupWiseSums);
        form.appendChild(groupWiseSumsInput);
    }
    
    // Submit the form
    document.body.appendChild(form);
    form.submit();
}
</script>"