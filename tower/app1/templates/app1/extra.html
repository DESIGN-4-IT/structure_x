
first read complete promt and act as experience developer 
in hdata1 page is shows previously selected load cases filter data so i wanted to select filter Load Values: table 
data for Calculation.add check box for all table records only on selected records from this hdata1 page i wanted to 
perform Calculation i explain you how to perform Calculation when i select any number of records from 
table like user select 3 records of Hurricane NL+ that contain same Set No. 9 and now user select same 3 records 
that contain Set No. 10 this records may be of same Hurricane NL+ load case or different but user need to select 
1,1   2,2   3,3 etc records from load case that contain different Set No. so all this records contain Structure Loads Vert. (lbs),
Structure Loads Trans. (lbs),and Structure Loads Long. (lbs) values so get max values of Structure Loads Vert. (lbs),
Structure Loads Trans. (lbs),and Structure Loads Long. (lbs) from all load cases if user select 3 record from 
Hurricane NL+ that contain 9 Set No. then we find max values of Structure Loads Vert. (lbs),
Structure Loads Trans. (lbs),and Structure Loads Long. (lbs) from all 3 record and same for other load case that we select for 
example of 10 Set No.  and realated excel contain n number of load cases and Set No. 
after this now we have 3 max values of set no. 9 and and 10 like this 
            set no 9            set no 10 
max_v   =   a   b   c           a   b   c    then here we add Structure Loads Vert. (lbs) from set no 9 + Structure Loads Vert. (lbs) from set no 10 same for
Structure Loads Trans. (lbs),and Structure Loads Long. (lbs) max values so all this calculation i wanted to show 
in new page with selected all data so user understand how calculation does 
and i want one more calculation for selected Vert,Trans,Long records using this excel formula =SQRT(Structure Loads Vert. (lbs)^2 + Structure Loads Trans. (lbs)^2 + Structure Loads Long. (lbs)^2)
like this 

this is model 
"class hUploadedFile1(models.Model)
    structure = models.ForeignKey(ListOfStructure, on_delete=models.CASCADE, related_name='huploaded_files1')
    file = models.FileField(upload_to='uploads/')
    uploaded_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.file.name} ({self.structure.structure})"

    class Meta:
        constraints = [
            models.UniqueConstraint(fields=['structure'], name='hunique_file_per_structure1')
            
        ]"
this is views 
"def hdata1(request):
    # Get selected values from session
    selected_values = request.session.get('selected_values', {})
    structure_id = selected_values.get('structure_id')
    button_type = selected_values.get('button_type', '')
    selected_load_cases = selected_values.get('load_cases', [])
    
    # If coming directly from buttons without specific filters
    if not structure_id and 'go_button' in request.POST:
        structure_id = request.POST.get('structure_id')
        button_type = request.POST.get('go_button')
        load_case_values = request.POST.get('load_case_values', '')
        
        # Convert comma-separated string to list
        if load_case_values:
            selected_load_cases = [case.strip() for case in load_case_values.split(',') if case.strip()]
        else:
            selected_load_cases = []
            
        if structure_id:
            selected_values = {
                'structure_id': structure_id,
                'button_type': button_type,
                'load_cases': selected_load_cases
            }
            request.session['selected_values'] = selected_values
    
    if structure_id:
        try:
            structure = ListOfStructure.objects.get(id=structure_id)
            latest_file = hUploadedFile1.objects.filter(structure=structure).latest('uploaded_at')
            df = pd.read_excel(latest_file.file.path, engine='openpyxl')

            # Filter by selected load cases if any are selected
            if selected_load_cases and 'Load Case Description' in df.columns:
                print(f"Filtering by load cases: {selected_load_cases}")  # Debug print
                # Filter the dataframe to include only selected load cases
                df = df[df['Load Case Description'].isin(selected_load_cases)]
                print(f"Filtered dataframe shape: {df.shape}")  # Debug print

            # Prepare complete data for table display - include ALL columns
            load_data = []
            for _, row in df.iterrows():
                row_data = {}
                # Add all columns from the dataframe
                for col in df.columns:
                    if pd.notna(row[col]):
                        # Convert numeric values to appropriate types
                        if pd.api.types.is_numeric_dtype(df[col]):
                            row_data[col] = float(row[col])
                        else:
                            row_data[col] = str(row[col])
                    else:
                        row_data[col] = '' if pd.api.types.is_string_dtype(df[col]) else 0
                load_data.append(row_data)

            # Get unique values for display based on filtered data
            joint_labels = [str(label) for label in df['Attach. Joint Labels'].unique()] if 'Attach. Joint Labels' in df.columns else []
            set_numbers = [str(num) for num in df['Set No.'].dropna().unique()] if 'Set No.' in df.columns else []
            phase_numbers = [str(num) for num in df['Phase No.'].dropna().unique()] if 'Phase No.' in df.columns else []

        except Exception as e:
            joint_labels = []
            set_numbers = []
            phase_numbers = []
            load_data = []
            print(f"Error processing Excel file: {str(e)}")
    else:
        joint_labels = []
        set_numbers = []
        phase_numbers = []
        load_data = []

    return render(request, 'app1/hdata1.html', {
        'joint_labels': joint_labels,
        'set_numbers': set_numbers,
        'phase_numbers': phase_numbers,
        'load_data': load_data,
        'load_data_json': json.dumps(load_data),
        'selected_values': selected_values,
        'all_columns': list(df.columns) if structure_id and 'df' in locals() else [],
        'button_type': button_type
    })
    "

    this is hdata1.html 
    "<div class="container">
    <h3>OVERHEAD LOAD DESIGN CRITERIA</h3>
    
    <div class="row">
        <!-- Left side - Selection Options -->
        <div class="col-md-4">
            {% if button_type == 'joint_labels' %}
            <!-- Show only joint labels section when joint labels button was clicked -->
            <div class="form-group">
                <label for="joint-labels">Attach. Joint Labels:</label>
                <div class="checkbox-list" id="joint-labels">
                    {% for label in joint_labels %}
                        <label draggable="true" class="drag-item" data-type="joint" data-value="{{ label }}">
                            <input type="checkbox" name="joint-labels" value="{{ label }}"> {{ label }}
                        </label>
                    {% endfor %}
                </div>
            </div>
            {% elif button_type == 'set_phase' %}
            <!-- Show only set/phase sections when set/phase button was clicked -->
            <div class="form-group">
                <label for="set-numbers">Set No.:</label>
                <div class="checkbox-list" id="set-numbers">
                    {% for num in set_numbers %}
                        <label draggable="true" class="drag-item" data-type="set" data-value="{{ num }}">
                            <input type="checkbox" name="set-numbers" value="{{ num }}"> {{ num }}
                        </label>
                    {% endfor %}
                </div>
            </div>
            
            <div class="form-group">
                <label for="phase-numbers">Phase No.:</label>
                <div class="checkbox-list" id="phase-numbers">
                    {% for num in phase_numbers %}
                        <label draggable="true" class="drag-item" data-type="phase" data-value="{{ num }}">
                            <input type="checkbox" name="phase-numbers" value="{{ num }}"> {{ num }}
                        </label>
                    {% endfor %}
                </div>
            </div>
            {% endif %}
                        
            <!-- Load Display Table -->
            <div id="load-display" class="mt-4">
                <h5>Load Values:</h5>
                <div style="overflow-x: auto;">
                    <table class="table table-bordered" id="load-table">
                        <thead>
                            <tr>
                                <!-- Dynamically generate column headers for ALL columns -->
                                {% for column in all_columns %}
                                    <th>{{ column }}</th>
                                {% endfor %}
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>
        </div>
        
        <!-- Right side - 3D Model Viewer -->
        <div class="col-md-8">
            <div id="model-viewer" style="height: 600px; border: 1px solid #ccc; position: relative;">
                <canvas id="model-canvas"></canvas>
                <div id="joint-markers-container"></div>
                <div id="set-markers-container"></div>
                <div id="phase-markers-container"></div>
                <div id="load-displays-container"></div>
            </div>
        </div>
    </div>
</div>

<script>
    // Load data passed from Django
    const loadData = JSON.parse('{{ load_data_json|escapejs }}');
    
    // Three.js variables
    let scene, camera, renderer, model, controls;
    const jointMarkers = {};
    const selectedJoints = new Set();
    const loadDisplays = {};
    const setMarkers = {};
    const phaseMarkers = {};
    const selectedSets = new Set();
    const selectedPhases = new Set();
    let activeJoint = null;

    
    // Initialize the 3D model viewer
    function initModelViewer() {
        // Create scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);
        
        // Create camera
        camera = new THREE.PerspectiveCamera(75, 800 / 600, 0.1, 1000);
        camera.position.set(5, 5, 5);
        
        // Create renderer
        const canvas = document.getElementById('model-canvas');
        renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(canvas.parentElement.clientWidth, canvas.parentElement.clientHeight);
        
        // Add controls
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;
        
        // Add lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);
        
        // Load GLB model
        const loader = new THREE.GLTFLoader();
        loader.load(
            "{% static 'app1/images/tower3d.glb' %}",
            function (gltf) {
                model = gltf.scene;
                scene.add(model);
                
                // Center the model
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                model.position.sub(center);
                
                // Auto-rotate
                model.rotation.y = Math.PI / 4;
                
                // Start animation loop
                animate();
            },
            undefined,
            function (error) {
                console.error('Error loading model:', error);
            }
        );
        
        // Handle window resize
        window.addEventListener('resize', onWindowResize);
    }
    
    // Add a marker for a joint on the 3D model
    function addJointMarker(jointLabel) {
        if (jointMarkers[jointLabel]) return; // Already exists
        
        // Find the load data for this joint
        const jointLoadData = loadData.find(item => item['Attach. Joint Labels'] === jointLabel);
        if (!jointLoadData) return;
        
        // Create a marker (smaller and without red dot)
        const geometry = new THREE.SphereGeometry(0.02, 16, 16); // Much smaller
        const material = new THREE.MeshBasicMaterial({ color: 0x333333 });
        const sphere = new THREE.Mesh(geometry, material);
        
        // Position the marker (you'll need to adjust this based on your model)
        sphere.position.set(
            (Math.random() - 0.5) * 2,
            Math.random() * 2,
            (Math.random() - 0.5) * 2
        );
        
        // Add label (HTML overlay)
        const markerDiv = document.createElement('div');
        markerDiv.className = 'joint-marker';
        markerDiv.textContent = jointLabel;
        markerDiv.style.position = 'absolute';
        markerDiv.style.cursor = 'move';
        markerDiv.style.pointerEvents = 'auto';
        markerDiv.dataset.jointLabel = jointLabel;
        document.getElementById('joint-markers-container').appendChild(markerDiv);
        
        // Click handler for the marker
        markerDiv.addEventListener('click', function(e) {
            e.stopPropagation();
            toggleLoadDisplay(jointLabel);
        });
        
        // Store references
        jointMarkers[jointLabel] = {
            mesh: sphere,
            div: markerDiv,
            loadData: jointLoadData,
            isDragging: false,
            fontSize: 12 // Default font size
        };
        
        scene.add(sphere);
        updateMarkerPosition(sphere, markerDiv);
        
        // Make marker draggable
        makeJointDraggable(markerDiv, jointLabel);
    }
    

    
    // Toggle load display visibility
    function toggleLoadDisplay(jointLabel) {
        if (loadDisplays[jointLabel]) {
            // Hide if already showing
            removeLoadDisplay(jointLabel);
            activeJoint = null;
        } else {
            // Show if hidden
            addLoadDisplay(jointLabel, jointMarkers[jointLabel].mesh.position);
            activeJoint = jointLabel;
            
            // Hide any other active displays
            Object.keys(loadDisplays).forEach(label => {
                if (label !== jointLabel) {
                    removeLoadDisplay(label);
                }
            });
        }
    }
    
    // Make joint marker draggable
    function makeJointDraggable(element, jointLabel) {
        let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
        
        element.onmousedown = dragMouseDown;
        
        function dragMouseDown(e) {
            e.preventDefault();
            e.stopPropagation();
            
            jointMarkers[jointLabel].isDragging = true;
            
            // Get the mouse cursor position at startup
            pos3 = e.clientX;
            pos4 = e.clientY;
            
            document.onmouseup = closeDragElement;
            document.onmousemove = elementDrag;
        }
        
        function elementDrag(e) {
            e.preventDefault();
            e.stopPropagation();
            
            // Calculate the new cursor position
            pos1 = pos3 - e.clientX;
            pos2 = pos4 - e.clientY;
            pos3 = e.clientX;
            pos4 = e.clientY;
            
            // Set the element's new position
            element.style.top = (element.offsetTop - pos2) + "px";
            element.style.left = (element.offsetLeft - pos1) + "px";
            
            // Update the 3D position
            update3DPositionFromScreen(jointLabel, parseInt(element.style.left), parseInt(element.style.top));
            
            // Update load display position if visible
            if (loadDisplays[jointLabel]) {
                updateLoadDisplayPosition(
                    loadDisplays[jointLabel].div, 
                    jointMarkers[jointLabel].mesh.position
                );
            }
        }

    
    function closeDragElement() {
            jointMarkers[jointLabel].isDragging = false;
            // Stop moving when mouse button is released
            document.onmouseup = null;
            document.onmousemove = null;
        }
    }
    
    // Update 3D position from screen coordinates
    function update3DPositionFromScreen(jointLabel, x, y) {
        const vector = new THREE.Vector3(
            (x / renderer.domElement.clientWidth) * 2 - 1,
            -(y / renderer.domElement.clientHeight) * 2 + 1,
            0.5
        );
        
        vector.unproject(camera);
        jointMarkers[jointLabel].mesh.position.copy(vector);
    }
    
    // Add load display for a joint
    function addLoadDisplay(jointLabel, position) {
        if (loadDisplays[jointLabel]) return; // Already exists
        
        const jointInfo = jointMarkers[jointLabel];
        if (!jointInfo) return;
        
        const displayDiv = document.createElement('div');
        displayDiv.className = 'load-display';
        displayDiv.dataset.jointLabel = jointLabel;
        displayDiv.style.position = 'absolute';
        displayDiv.style.pointerEvents = 'auto';
        
        displayDiv.innerHTML = `
            <div class="load-display-header">
                <span>${jointLabel}</span>
                <span class="close-btn" title="Remove">Ã—</span>
            </div>
            <div class="load-display-content">
                <div>Vert: <span class="editable" data-field="vert">${jointInfo.loadData['Structure Loads Vert. (lbs)'] || '0'}</span> lbs</div>
                <div>Trans: <span class="editable" data-field="trans">${jointInfo.loadData['Structure Loads Trans. (lbs)'] || '0'}</span> lbs</div>
                <div>Long: <span class="editable" data-field="long">${jointInfo.loadData['Structure Loads Long. (lbs)'] || '0'}</span> lbs</div>
            </div>
            <div class="size-controls">
                <div class="size-btn" data-action="increase">+</div>
                <div class="size-btn" data-action="decrease">-</div>
            </div>
        `;
        
        document.getElementById('load-displays-container').appendChild(displayDiv);
        
        // Position the display
        updateLoadDisplayPosition(displayDiv, position);
        
        // Store reference
        loadDisplays[jointLabel] = {
            div: displayDiv,
            position: position
        };
        
        // Add close button event
        displayDiv.querySelector('.close-btn').addEventListener('click', function(e) {
            e.stopPropagation();
            removeJointMarker(jointLabel);
            removeLoadDisplay(jointLabel);
            
            // Uncheck the checkbox
            const checkbox = document.querySelector(`input[value="${jointLabel}"]`);
            if (checkbox) {
                checkbox.checked = false;
                selectedJoints.delete(jointLabel);
                updateTable(Array.from(selectedJoints));
            }
        });
        
        // Add size control events
        displayDiv.querySelector('[data-action="increase"]').addEventListener('click', function(e) {
            e.stopPropagation();
            jointMarkers[jointLabel].fontSize = Math.min(24, jointMarkers[jointLabel].fontSize + 1);
            jointMarkers[jointLabel].div.style.fontSize = `${jointMarkers[jointLabel].fontSize}px`;
        });
        
        displayDiv.querySelector('[data-action="decrease"]').addEventListener('click', function(e) {
            e.stopPropagation();
            jointMarkers[jointLabel].fontSize = Math.max(8, jointMarkers[jointLabel].fontSize - 1);
            jointMarkers[jointLabel].div.style.fontSize = `${jointMarkers[jointLabel].fontSize}px`;
        });
        
        // Add editable fields (same as before)
        displayDiv.querySelectorAll('.editable').forEach(el => {
            el.addEventListener('click', function(e) {
                e.stopPropagation();
                const field = this.dataset.field;
                const currentValue = this.textContent;
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'value-edit';
                input.value = currentValue;
                
                this.textContent = '';
                this.appendChild(input);
                input.focus();
                
                input.addEventListener('blur', function() {
                    const newValue = parseFloat(this.value) || 0;
                    const parent = this.parentElement;
                    parent.textContent = newValue;
                    parent.classList.add('editable');
                    
                    // Update the data
                    const jointLabel = parent.closest('.load-display').dataset.jointLabel;
                    const jointInfo = jointMarkers[jointLabel];
                    if (jointInfo) {
                        if (field === 'vert') {
                            jointInfo.loadData['Structure Loads Vert. (lbs)'] = newValue;
                        } else if (field === 'trans') {
                            jointInfo.loadData['Structure Loads Trans. (lbs)'] = newValue;
                        } else if (field === 'long') {
                            jointInfo.loadData['Structure Loads Long. (lbs)'] = newValue;
                        }
                    }
                    
                    // Update the table
                    updateTable(Array.from(selectedJoints));
                });
                
                input.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        this.blur();
                    }
                });
            });
        });
        
        // Make the display draggable
        makeDraggable(displayDiv, jointLabel);
    }
    
    // Make load display draggable
    function makeDraggable(element, jointLabel) {
        let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
        
        element.onmousedown = dragMouseDown;
        
        function dragMouseDown(e) {
            e = e || window.event;
            e.preventDefault();
            
            // Get the mouse cursor position at startup
            pos3 = e.clientX;
            pos4 = e.clientY;
            
            document.onmouseup = closeDragElement;
            document.onmousemove = elementDrag;
        }
        
        function elementDrag(e) {
            e = e || window.event;
            e.preventDefault();
            
            // Calculate the new cursor position
            pos1 = pos3 - e.clientX;
            pos2 = pos4 - e.clientY;
            pos3 = e.clientX;
            pos4 = e.clientY;
            
            // Set the element's new position
            element.style.top = (element.offsetTop - pos2) + "px";
            element.style.left = (element.offsetLeft - pos1) + "px";
            
            // Update the marker position reference
            if (loadDisplays[jointLabel]) {
                loadDisplays[jointLabel].position = getPositionFromScreen(
                    parseInt(element.style.left), 
                    parseInt(element.style.top)
                );
            }
        }
        
        function closeDragElement() {
            // Stop moving when mouse button is released
            document.onmouseup = null;
            document.onmousemove = null;
        }
    }
    
    // Convert screen coordinates to 3D position
    function getPositionFromScreen(x, y) {
        const vector = new THREE.Vector3(
            (x / renderer.domElement.clientWidth) * 2 - 1,
            -(y / renderer.domElement.clientHeight) * 2 + 1,
            0.5
        );
        
        vector.unproject(camera);
        return vector;
    }
    
    // Remove load display
    function removeLoadDisplay(jointLabel) {
        if (!loadDisplays[jointLabel]) return;
        
        document.getElementById('load-displays-container').removeChild(loadDisplays[jointLabel].div);
        delete loadDisplays[jointLabel];
    }
    
    // Update HTML marker position based on 3D position
    function updateMarkerPosition(mesh, div) {
        const vector = mesh.position.clone();
        vector.project(camera);
        
        const x = (vector.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
        const y = (-(vector.y * 0.5) + 0.5) * renderer.domElement.clientHeight;
        
        div.style.left = `${x}px`;
        div.style.top = `${y}px`;
    }
    
    // Update load display position based on 3D position
    function updateLoadDisplayPosition(div, position) {
        const vector = position.clone();
        vector.project(camera);
        
        const x = (vector.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
        const y = (-(vector.y * 0.5) + 0.5) * renderer.domElement.clientHeight;
        
        div.style.left = `${x + 20}px`; // Offset slightly from the marker
        div.style.top = `${y}px`;
    }
    
    // Remove a joint marker
    function removeJointMarker(jointLabel) {
        if (!jointMarkers[jointLabel]) return;
        
        scene.remove(jointMarkers[jointLabel].mesh);
        document.getElementById('joint-markers-container').removeChild(jointMarkers[jointLabel].div);
        delete jointMarkers[jointLabel];
    }
    
    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        
        // Update marker positions
        for (const jointLabel in jointMarkers) {
            updateMarkerPosition(jointMarkers[jointLabel].mesh, jointMarkers[jointLabel].div);
            
            // Update load display positions if they exist
            if (loadDisplays[jointLabel]) {
                updateLoadDisplayPosition(
                    loadDisplays[jointLabel].div, 
                    jointMarkers[jointLabel].mesh.position
                );
            }
        }
        
        renderer.render(scene, camera);
    }
    
    function onWindowResize() {
        const container = document.getElementById('model-viewer');
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    }
    
    // Clear table
    function clearTable() {
        document.getElementById('load-table').getElementsByTagName('tbody')[0].innerHTML = '';
    }
    
    // Update table with selected labels
function updateTable() {
    clearTable();
    const tbody = document.getElementById('load-table').getElementsByTagName('tbody')[0];
    
    // Get all column names from the table headers
    const columns = Array.from(document.querySelectorAll('#load-table thead th'))
        .map(th => th.textContent.trim());
    
    // Add new rows from the filtered data
    loadData.forEach(item => {
        const row = tbody.insertRow();
        
        // Add cells for each column
        columns.forEach(column => {
            const cell = row.insertCell();
            cell.textContent = item[column] !== undefined ? item[column] : '';
        });
    });
    
    // Only add joints if we're in joint labels mode and joints are selected
    {% if button_type == 'joint_labels' %}
    Array.from(selectedJoints).forEach(label => {
        const loadInfo = loadData.find(item => item['Attach. Joint Labels'] === label);
        if (loadInfo) {
            const newRow = tbody.insertRow();
            
            // Add cells for each column
            columns.forEach(column => {
                const cell = newRow.insertCell();
                cell.textContent = loadInfo[column] !== undefined ? loadInfo[column] : '';
            });
        }
    });
    {% endif %}
    
    // Only add sets if we're in set/phase mode and sets are selected
    {% if button_type == 'set_phase' %}
    Array.from(selectedSets).forEach(setNum => {
        // Find all rows with this set number
        const setData = loadData.filter(item => item['Set No.'] == setNum);
        
        if (setData.length > 0) {
            // Add a header row for the set
            const headerRow = tbody.insertRow();
            const headerCell = headerRow.insertCell();
            headerCell.colSpan = columns.length;
            headerCell.textContent = `Set ${setNum}`;
            headerCell.style.textAlign = 'center';
            headerCell.style.backgroundColor = '#e6f2ff';
            headerCell.style.fontWeight = 'bold';
            
            // Add all data rows for this set
            setData.forEach(item => {
                const row = tbody.insertRow();
                columns.forEach(column => {
                    const cell = row.insertCell();
                    cell.textContent = item[column] !== undefined ? item[column] : '';
                });
            });
        }
    });
    
    // Only add phases if we're in set/phase mode and phases are selected
    Array.from(selectedPhases).forEach(phaseNum => {
        // Find all rows with this phase number
        const phaseData = loadData.filter(item => item['Phase No.'] == phaseNum);
        
        if (phaseData.length > 0) {
            // Add a header row for the phase
            const headerRow = tbody.insertRow();
            const headerCell = headerRow.insertCell();
            headerCell.colSpan = columns.length;
            headerCell.textContent = `Phase ${phaseNum}`;
            headerCell.style.textAlign = 'center';
            headerCell.style.backgroundColor = '#e6ffe6';
            headerCell.style.fontWeight = 'bold';
            
            // Add all data rows for this phase
            phaseData.forEach(item => {
                const row = tbody.insertRow();
                columns.forEach(column => {
                    const cell = row.insertCell();
                    cell.textContent = item[column] !== undefined ? item[column] : '';
                });
            });
        }
    });
    {% endif %}
}

    
    // Set up event listeners
    function addMarker(itemType, itemValue) {
    if (itemType === 'joint') {
        if (jointMarkers[itemValue]) return;
        addJointMarker(itemValue);
    } 
    else if (itemType === 'set') {
        if (setMarkers[itemValue]) return;
        addSetMarker(itemValue);
    }
    else if (itemType === 'phase') {
        if (phaseMarkers[itemValue]) return;
        addPhaseMarker(itemValue);
    }
}

// Function to add a set marker
function addSetMarker(setNumber) {
    const geometry = new THREE.SphereGeometry(0.03, 16, 16);
    const material = new THREE.MeshBasicMaterial({ color: 0x0000ff }); // Blue for sets
    const sphere = new THREE.Mesh(geometry, material);
    
    // Position the marker
    sphere.position.set(
        (Math.random() - 0.5) * 2,
        Math.random() * 2,
        (Math.random() - 0.5) * 2
    );
    
    // Add label
    const markerDiv = document.createElement('div');
    markerDiv.className = 'set-marker';
    markerDiv.textContent = `Set ${setNumber}`;
    markerDiv.style.position = 'absolute';
    markerDiv.style.color = 'blue';
    markerDiv.dataset.setNumber = setNumber;
    document.getElementById('set-markers-container').appendChild(markerDiv);
    
    setMarkers[setNumber] = {
        mesh: sphere,
        div: markerDiv,
        isDragging: false
    };
    
    scene.add(sphere);
    updateMarkerPosition(sphere, markerDiv);
    makeDraggable(markerDiv, setNumber, 'set');
}

// Function to add a phase marker
function addPhaseMarker(phaseNumber) {
    const geometry = new THREE.SphereGeometry(0.03, 16, 16);
    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // Green for phases
    const sphere = new THREE.Mesh(geometry, material);
    
    // Position the marker
    sphere.position.set(
        (Math.random() - 0.5) * 2,
        Math.random() * 2,
        (Math.random() - 0.5) * 2
    );
    
    // Add label
    const markerDiv = document.createElement('div');
    markerDiv.className = 'phase-marker';
    markerDiv.textContent = `Phase ${phaseNumber}`;
    markerDiv.style.position = 'absolute';
    markerDiv.style.color = 'green';
    markerDiv.dataset.phaseNumber = phaseNumber;
    document.getElementById('phase-markers-container').appendChild(markerDiv);
    
    phaseMarkers[phaseNumber] = {
        mesh: sphere,
        div: markerDiv,
        isDragging: false
    };
    
    scene.add(sphere);
    updateMarkerPosition(sphere, markerDiv);
    makeDraggable(markerDiv, phaseNumber, 'phase');
}

    // Set up event listeners
    document.addEventListener('DOMContentLoaded', function() {
    // Initialize 3D viewer
    initModelViewer();
    updateTable();

    // Handle checkbox changes for all types
    ['joint', 'set', 'phase'].forEach(type => {
        const container = document.getElementById(`${type}-${type === 'joint' ? 'labels' : 'numbers'}`);
        if (container) {
            container.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    const itemValue = this.value;
                    
                    if (type === 'joint') {
                        if (this.checked) {
                            selectedJoints.add(itemValue);
                            addMarker('joint', itemValue);
                        } else {
                            selectedJoints.delete(itemValue);
                            removeJointMarker(itemValue);
                        }
                    } 
                    else if (type === 'set') {
                        if (this.checked) {
                            selectedSets.add(itemValue);
                            addMarker('set', itemValue);
                        } else {
                            selectedSets.delete(itemValue);
                            if (setMarkers[itemValue]) {
                                scene.remove(setMarkers[itemValue].mesh);
                                document.getElementById('set-markers-container').removeChild(setMarkers[itemValue].div);
                                delete setMarkers[itemValue];
                            }
                        }
                    }
                    else if (type === 'phase') {
                        if (this.checked) {
                            selectedPhases.add(itemValue);
                            addMarker('phase', itemValue);
                        } else {
                            selectedPhases.delete(itemValue);
                            if (phaseMarkers[itemValue]) {
                                scene.remove(phaseMarkers[itemValue].mesh);
                                document.getElementById('phase-markers-container').removeChild(phaseMarkers[itemValue].div);
                                delete phaseMarkers[itemValue];
                            }
                        }
                    }
                    
                    updateTable();
                });
            });
        }
    });


        
        // Make labels draggable
         document.querySelectorAll('.drag-item').forEach(item => {
        item.addEventListener('dragstart', function(e) {
            e.dataTransfer.setData('type', this.dataset.type);
            e.dataTransfer.setData('value', this.dataset.value);
            e.dataTransfer.effectAllowed = 'copy';
        });
    });
        
        // Set up drop zone on model viewer
        const modelCanvas = document.getElementById('model-canvas');
    modelCanvas.addEventListener('dragover', function(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'copy';
    });
    
    modelCanvas.addEventListener('drop', function(e) {
        e.preventDefault();
        const itemType = e.dataTransfer.getData('type');
        const itemValue = e.dataTransfer.getData('value');
        
        // Find the corresponding checkbox and check it
        let checkbox;
        if (itemType === 'joint') {
            checkbox = document.querySelector(`input[name="joint-labels"][value="${itemValue}"]`);
            if (checkbox && !checkbox.checked) {
                checkbox.checked = true;
                const event = new Event('change');
                checkbox.dispatchEvent(event);
            }
        }
        else if (itemType === 'set') {
            checkbox = document.querySelector(`input[name="set-numbers"][value="${itemValue}"]`);
            if (checkbox && !checkbox.checked) {
                checkbox.checked = true;
                const event = new Event('change');
                checkbox.dispatchEvent(event);
            }
        }
        else if (itemType === 'phase') {
            checkbox = document.querySelector(`input[name="phase-numbers"][value="${itemValue}"]`);
            if (checkbox && !checkbox.checked) {
                checkbox.checked = true;
                const event = new Event('change');
                checkbox.dispatchEvent(event);
            }
        }
    });
});
        
       
</script>"