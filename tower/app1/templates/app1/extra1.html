Read the complete code of both pages and act as an experienced developer.

I want to use the buffer values Vert (lbs), Trans (lbs), and Long (lbs) (these are the Processed Sum results from the previous page calculation) to calculate the Factored Loads on the load condition page.

Right now the load condition page only shows “Calculating…” and no result.
Check both pages’ code, find why the factored load calculation is not running, and fix the issue.

Also, suggest the correct calculation logic where to add/modify i am beginer 

this is load condition page complete code 

this is views 
"def load_condition_view(request):
    calculation_data = []
    processed_sums = {}
    
    # Try to get calculation data from multiple sources
    if request.method == 'POST':
        # Get calculation data from POST request (initial load)
        calculation_data_json = request.POST.get('calculation_data')
        processed_sums_json = request.POST.get('processed_sums')  # NEW: Get processed sums
        if calculation_data_json:
            try:
                calculation_data = json.loads(calculation_data_json)
                # Store in session for future requests
                request.session['calculation_data'] = calculation_data
                
                if processed_sums_json:
                    processed_sums = json.loads(processed_sums_json)
                    request.session['processed_sums'] = processed_sums
                    
            except json.JSONDecodeError:
                # Try to get from session if POST fails
                calculation_data = request.session.get('calculation_data', [])
                processed_sums = request.session.get('processed_sums', {})
    else:
        # For GET requests (like redirects from create/edit/delete), get from session
        calculation_data = request.session.get('calculation_data', [])
        processed_sums = request.session.get('processed_sums', {})
    
    # Get all load conditions
    load_conditions = LoadCondition.objects.all().order_by('id')
    
    # Get all attachment loads grouped by load case
    attachment_loads = {}
    for lc in AttachmentLoad.LOAD_CASE_CHOICES:
        loads = AttachmentLoad.objects.filter(load_case=lc[0]).order_by('attachment')
        if loads.exists():
            attachment_loads[lc[0]] = {
                'name': lc[1],
                'loads': loads
            }
    
    # Process calculation data only if it exists
    if calculation_data:
        # Add record_id and clean keys to calculation data for template access
        for index, record in enumerate(calculation_data):
            record['record_id'] = f"record_{index}"
            # Add clean keys for template access
            record['Structure_Loads_Vert'] = float(record.get('Structure Loads Vert. (lbs)', 0) or 0)
            record['Structure_Loads_Trans'] = float(record.get('Structure Loads Trans. (lbs)', 0) or 0)
            record['Structure_Loads_Long'] = float(record.get('Structure Loads Long. (lbs)', 0) or 0)
            record['Resultant'] = float(record.get('Resultant (lbs)', 0) or 0)
            # Store Set No. in data attribute
            record['Set_No'] = record.get('Set No.', 'Unknown')
        
        # Group calculation data by Set No. for debug display
        grouped_calculation_data = {}
        for record in calculation_data:
            set_no = record.get('Set No.', 'Unknown')
            if set_no not in grouped_calculation_data:
                grouped_calculation_data[set_no] = []
            grouped_calculation_data[set_no].append(record)
    else:
        grouped_calculation_data = {}
    
    # Calculate factored loads for each load condition - CORRECTED LOGIC
    factored_loads_by_condition = {}
    
    # PRIORITY: Use processed sums if available (NEW LOGIC)
    if processed_sums:  
        for condition in load_conditions:
            # Apply overload factors directly to processed sums
            from decimal import Decimal
            
            # Use processed sums as base loads
            base_vert = Decimal(str(processed_sums.get('totalVert', 0)))
            base_trans = Decimal(str(processed_sums.get('totalTrans', 0)))
            base_long = Decimal(str(processed_sums.get('totalLong', 0)))
            
            # Apply overload factors
            factored_vert = base_vert * Decimal(str(condition.vertical_factor))
            factored_trans = base_trans * Decimal(str(condition.transverse_factor))
            factored_long = base_long * Decimal(str(condition.longitudinal_factor))
            
            # Convert to float
            factored_vert = float(factored_vert)
            factored_trans = float(factored_trans)
            factored_long = float(factored_long)
            
            # Recalculate resultant
            factored_resultant = math.sqrt(factored_vert**2 + factored_trans**2 + factored_long**2)
            
            factored_loads_by_condition[condition.description] = {
                'base_loads': {  # Store original processed sums for reference
                    'vert': float(base_vert),
                    'trans': float(base_trans),
                    'long': float(base_long),
                    'resultant': processed_sums.get('finalResultant', 0)
                },
                'factored_loads': {
                    'vert': factored_vert,
                    'trans': factored_trans,
                    'long': factored_long,
                    'resultant': factored_resultant
                },
                'factors': {
                    'vertical': condition.vertical_factor,
                    'transverse': condition.transverse_factor,
                    'longitudinal': condition.longitudinal_factor
                },
                'calculation_type': 'processed_sums'  # Track which logic was used
            }
    
    # FALLBACK: Use individual records if no processed sums available (OLD LOGIC)
    elif calculation_data:
        for condition in load_conditions:
            factored_records = []
            
            # Process each record individually
            for record in calculation_data:
                # Create a copy of the record
                factored_record = record.copy()
                
                # Extract the correct load values from the record
                vert = float(record.get('Structure Loads Vert. (lbs)', 0) or 0)
                trans = float(record.get('Structure Loads Trans. (lbs)', 0) or 0)
                long = float(record.get('Structure Loads Long. (lbs)', 0) or 0)
                
                # Apply overload factors - use Decimal for precise multiplication
                from decimal import Decimal
                factored_vert = Decimal(str(vert)) * Decimal(str(condition.vertical_factor))
                factored_trans = Decimal(str(trans)) * Decimal(str(condition.transverse_factor))
                factored_long = Decimal(str(long)) * Decimal(str(condition.longitudinal_factor))
                
                # Convert back to float for consistency
                factored_vert = float(factored_vert)
                factored_trans = float(factored_trans)
                factored_long = float(factored_long)
                
                # Update the record with factored values
                factored_record['Structure Loads Vert. (lbs)'] = round(factored_vert, 2)
                factored_record['Structure Loads Trans. (lbs)'] = round(factored_trans, 2)
                factored_record['Structure Loads Long. (lbs)'] = round(factored_long, 2)
                
                # Recalculate resultant
                factored_resultant = math.sqrt(factored_vert**2 + factored_trans**2 + factored_long**2)
                factored_record['Resultant (lbs)'] = round(factored_resultant, 2)
                
                factored_records.append(factored_record)
            
            # Group factored records by Set No.
            grouped_factored_data = {}
            for record in factored_records:
                set_no = record.get('Set No.', 'Unknown')
                if set_no not in grouped_factored_data:
                    grouped_factored_data[set_no] = []
                grouped_factored_data[set_no].append(record)
            
            factored_loads_by_condition[condition.description] = {
                'grouped_data': grouped_factored_data,
                'factors': {
                    'vertical': condition.vertical_factor,
                    'transverse': condition.transverse_factor,
                    'longitudinal': condition.longitudinal_factor
                },
                'all_records': factored_records,  # Store all records for JavaScript filtering
                'calculation_type': 'individual_records'  # Track which logic was used
            }
    
    context = {
        'load_conditions': load_conditions,
        'attachment_loads': attachment_loads,
        'calculation_data': calculation_data,
        'calculation_data_json': json.dumps(calculation_data),  # For JavaScript
        'factored_loads_by_condition': factored_loads_by_condition,
        'has_factored_loads': bool(factored_loads_by_condition),
        'grouped_calculation_data': grouped_calculation_data,
        'processed_sums': processed_sums,  # NEW: Pass to template
        'using_processed_sums': bool(processed_sums)  # NEW: Flag for template
    }
    
    return render(request, 'app1/load_condition.html', context)"

this is load_condition.html 
"<div class="container">
    <header>
        <h2><i class="fas fa-table"></i> Load Conditions</h2>
        <p>Configure and apply load conditions to your calculations</p>
    </header>

    {% if calculation_data %}
    <!-- Selection Controls -->
    <div class="card">
        <h3><i class="fas fa-mouse-pointer"></i> Record Selection</h3>
        <div class="selection-controls">
            <button type="button" id="selectAllBtn" class="btn btn-outline-primary">
                <i class="fas fa-check-square"></i> Select All
            </button>
            <button type="button" id="selectNoneBtn" class="btn btn-outline-secondary">
                <i class="fas fa-square"></i> Select None
            </button>
            <span class="selection-count">Selected: <span id="selectedCount">{{ calculation_data|length }}</span> records</span>
        </div>
    </div>

     <div class="card">
        <h3><i class="fas fa-list-ol"></i> Calculation Data Records</h3>
        
        {% for set_no, records in grouped_calculation_data.items %}
        <div class="set-container">
            <div class="set-header">
                <h4><i class="fas fa-cubes"></i> Set No. {{ set_no }} <span class="badge badge-primary">{{ records|length }} records</span></h4>
            </div>
            
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th>Select</th>
                            {% for key in records.0.keys %}
                                {% if key != 'max_resultant_flag' and key != 'record_id' and key != 'Structure_Loads_Vert' and key != 'Structure_Loads_Trans' and key != 'Structure_Loads_Long' and key != 'Resultant' and key != 'Set_No' %}
                                    <th>{{ key }}</th>
                                {% endif %}
                            {% endfor %}
                        </tr>
                    </thead>
                    <tbody>
                        {% for record in records %}
                            <tr data-record-id="{{ record.record_id }}">
                                <td>
                                    <input type="checkbox" class="record-checkbox" 
                                        data-record-id="{{ record.record_id }}"
                                        data-set-no="{{ record.Set_No }}"
                                        data-vert="{{ record.Structure_Loads_Vert }}"
                                        data-trans="{{ record.Structure_Loads_Trans }}"
                                        data-long="{{ record.Structure_Loads_Long }}"
                                        data-resultant="{{ record.Resultant }}"
                                        checked>
                                </td>
                                {% for key, value in record.items %}
                                    {% if key != 'max_resultant_flag' and key != 'record_id' and key != 'Structure_Loads_Vert' and key != 'Structure_Loads_Trans' and key != 'Structure_Loads_Long' and key != 'Resultant' and key != 'Set_No' %}
                                        {% if key == 'Resultant (lbs)' or 'Structure Loads' in key %}
                                            <td class="resultant-cell">{{ value }}</td>
                                        {% else %}
                                            <td>{{ value }}</td>
                                        {% endif %}
                                    {% endif %}
                                {% endfor %}
                            </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>
        </div>
        {% if not forloop.last %}<hr>{% endif %}
        {% endfor %}
    </div>

     <div class="card">
        <h3><i class="fas fa-cog"></i> Load Condition Parameters</h3>
        
        <!-- Add Parameter Button -->
        <div class="action-buttons" style="justify-content: flex-start; margin-bottom: 20px;">
            <a href="{% url 'create_load_condition' %}" class="btn btn-primary">
                <i class="fas fa-plus-circle"></i> Add New Parameter
            </a>
        </div>
        
        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th>Description</th>
                        <th>°F</th>
                        <th>Radial (in)</th>
                        <th>Pressure (psf)</th>
                        <th>ANGLE</th>
                        <th>TRANSVERSE</th>
                        <th>VERTICAL</th>
                        <th>LONGITUDINAL</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody>
                    {% for condition in load_conditions %}
                    <tr>
                        <td>{{ condition.description }}</td>
                        <td>{{ condition.temperature }}</td>
                        <td>{{ condition.ice_radial }}</td>
                        <td>{{ condition.wind_pressure }}</td>
                        <td>{{ condition.angle_factor }}</td>
                        <td>{{ condition.transverse_factor }}</td>
                        <td>{{ condition.vertical_factor }}</td>
                        <td>{{ condition.longitudinal_factor }}</td>
                        <td>
                            <div style="display: flex; gap: 5px;">
                                <a href="{% url 'edit_load_condition' condition.pk %}" 
                                class="btn btn-sm btn-outline-primary" 
                                style="padding: 5px 10px; font-size: 0.8rem;">
                                    <i class="fas fa-edit"></i>
                                </a>
                                <button onclick="deleteLoadCondition({{ condition.pk }})" 
                                        class="btn btn-sm btn-outline-danger" 
                                        style="padding: 5px 10px; font-size: 0.8rem;">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                        </td>
                    </tr>
                    {% empty %}
                    <tr>
                        <td colspan="9" style="text-align: center; color: #6c757d;">
                            <i class="fas fa-info-circle"></i> No load conditions configured yet.
                        </td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
    </div>
    
    <!-- Processed Sums Display -->
    {% if using_processed_sums %}
    <div class="card alert alert-info">
        <h3><i class="fas fa-info-circle"></i> Using Processed Sums as Base Loads</h3>
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-label">Base Vert</div>
                <div class="stat-value">{{ processed_sums.totalVert|floatformat:2 }}</div>
                <div class="stat-label">(lbs)</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Base Trans</div>
                <div class="stat-value">{{ processed_sums.totalTrans|floatformat:2 }}</div>
                <div class="stat-label">(lbs)</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Base Long</div>
                <div class="stat-value">{{ processed_sums.totalLong|floatformat:2 }}</div>
                <div class="stat-label">(lbs)</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Base Resultant</div>
                <div class="stat-value">{{ processed_sums.finalResultant|floatformat:2 }}</div>
                <div class="stat-label">(lbs)</div>
            </div>
        </div>
    </div>
    {% endif %}

    <!-- Factored Loads Display - SINGLE SECTION -->
    {% if has_factored_loads %}
        {% for condition_name, condition_data in factored_loads_by_condition.items %}
        <div class="card factored-loads-section">
            <h3><i class="fas fa-calculator"></i> Factored Loads for {{ condition_name }}</h3>
            
            <!-- Show base and factored loads comparison -->
            <div class="loads-comparison">
                {% if condition_data.calculation_type == 'processed_sums' %}
                <div class="base-loads">
                    <h5>Base Loads (Processed Sums)</h5>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">Vert</div>
                            <div class="stat-value">{{ condition_data.base_loads.vert|floatformat:2 }}</div>
                            <div class="stat-label">(lbs)</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Trans</div>
                            <div class="stat-value">{{ condition_data.base_loads.trans|floatformat:2 }}</div>
                            <div class="stat-label">(lbs)</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Long</div>
                            <div class="stat-value">{{ condition_data.base_loads.long|floatformat:2 }}</div>
                            <div class="stat-label">(lbs)</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Resultant</div>
                            <div class="stat-value">{{ condition_data.base_loads.resultant|floatformat:2 }}</div>
                            <div class="stat-label">(lbs)</div>
                        </div>
                    </div>
                </div>
                {% endif %}
                
                <div class="factored-loads">
                    <h5>Factored Loads (×{{ condition_data.factors.vertical }}, ×{{ condition_data.factors.transverse }}, ×{{ condition_data.factors.longitudinal }})</h5>
                    <div class="stats-grid">
                        <div class="stat-card highlighted">
                            <div class="stat-label">Vert</div>
                            <div class="stat-value">
                                {% if condition_data.calculation_type == 'processed_sums' %}
                                    {{ condition_data.factored_loads.vert|floatformat:2 }}
                                {% else %}
                                    <!-- For individual records, show calculated total -->
                                    Calculating...
                                {% endif %}
                            </div>
                            <div class="stat-label">(lbs)</div>
                        </div>
                        <div class="stat-card highlighted">
                            <div class="stat-label">Trans</div>
                            <div class="stat-value">
                                {% if condition_data.calculation_type == 'processed_sums' %}
                                    {{ condition_data.factored_loads.trans|floatformat:2 }}
                                {% else %}
                                    Calculating...
                                {% endif %}
                            </div>
                            <div class="stat-label">(lbs)</div>
                        </div>
                        <div class="stat-card highlighted">
                            <div class="stat-label">Long</div>
                            <div class="stat-value">
                                {% if condition_data.calculation_type == 'processed_sums' %}
                                    {{ condition_data.factored_loads.long|floatformat:2 }}
                                {% else %}
                                    Calculating...
                                {% endif %}
                            </div>
                            <div class="stat-label">(lbs)</div>
                        </div>
                        <div class="stat-card highlighted">
                            <div class="stat-label">Resultant</div>
                            <div class="stat-value">
                                {% if condition_data.calculation_type == 'processed_sums' %}
                                    {{ condition_data.factored_loads.resultant|floatformat:2 }}
                                {% else %}
                                    Calculating...
                                {% endif %}
                            </div>
                            <div class="stat-label">(lbs)</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Individual Records Table (for individual records calculation) -->
            {% if condition_data.calculation_type == 'individual_records' and condition_data.grouped_data %}
            <div class="individual-records-section">
                <h5>Individual Factored Records</h5>
                {% for set_no, records in condition_data.grouped_data.items %}
                <div class="set-container">
                    <div class="set-header">
                        <h6><i class="fas fa-cubes"></i> Set No. {{ set_no }} <span class="badge badge-secondary">{{ records|length }} records</span></h6>
                    </div>
                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    {% for key in records.0.keys %}
                                        {% if key != 'max_resultant_flag' and key != 'record_id' and key != 'Structure_Loads_Vert' and key != 'Structure_Loads_Trans' and key != 'Structure_Loads_Long' and key != 'Resultant' and key != 'Set_No' %}
                                            <th>{{ key }}</th>
                                        {% endif %}
                                    {% endfor %}
                                </tr>
                            </thead>
                            <tbody>
                                {% for record in records %}
                                <tr>
                                    {% for key, value in record.items %}
                                        {% if key != 'max_resultant_flag' and key != 'record_id' and key != 'Structure_Loads_Vert' and key != 'Structure_Loads_Trans' and key != 'Structure_Loads_Long' and key != 'Resultant' and key != 'Set_No' %}
                                            {% if key == 'Resultant (lbs)' or 'Structure Loads' in key %}
                                                <td class="resultant-cell">{{ value }}</td>
                                            {% else %}
                                                <td>{{ value }}</td>
                                            {% endif %}
                                        {% endif %}
                                    {% endfor %}
                                </tr>
                                {% endfor %}
                            </tbody>
                        </table>
                    </div>
                </div>
                {% endfor %}
            </div>
            {% endif %}
        </div>
        {% endfor %}
    {% endif %}

    <!-- Original Calculation Data Records -->
    <div class="card">
        <h3><i class="fas fa-list-ol"></i> Calculation Data Records</h3>
        
        {% for set_no, records in grouped_calculation_data.items %}
        <div class="set-container">
            <div class="set-header">
                <h4><i class="fas fa-cubes"></i> Set No. {{ set_no }} <span class="badge badge-primary">{{ records|length }} records</span></h4>
            </div>
            
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th>Select</th>
                            {% for key in records.0.keys %}
                                {% if key != 'max_resultant_flag' and key != 'record_id' and key != 'Structure_Loads_Vert' and key != 'Structure_Loads_Trans' and key != 'Structure_Loads_Long' and key != 'Resultant' and key != 'Set_No' %}
                                    <th>{{ key }}</th>
                                {% endif %}
                            {% endfor %}
                        </tr>
                    </thead>
                    <tbody>
                        {% for record in records %}
                            <tr data-record-id="{{ record.record_id }}">
                                <td>
                                    <input type="checkbox" class="record-checkbox" 
                                        data-record-id="{{ record.record_id }}"
                                        data-set-no="{{ record.Set_No }}"
                                        data-vert="{{ record.Structure_Loads_Vert }}"
                                        data-trans="{{ record.Structure_Loads_Trans }}"
                                        data-long="{{ record.Structure_Loads_Long }}"
                                        data-resultant="{{ record.Resultant }}"
                                        checked>
                                </td>
                                {% for key, value in record.items %}
                                    {% if key != 'max_resultant_flag' and key != 'record_id' and key != 'Structure_Loads_Vert' and key != 'Structure_Loads_Trans' and key != 'Structure_Loads_Long' and key != 'Resultant' and key != 'Set_No' %}
                                        {% if key == 'Resultant (lbs)' or 'Structure Loads' in key %}
                                            <td class="resultant-cell">{{ value }}</td>
                                        {% else %}
                                            <td>{{ value }}</td>
                                        {% endif %}
                                    {% endif %}
                                {% endfor %}
                            </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>
        </div>
        {% if not forloop.last %}<hr>{% endif %}
        {% endfor %}
    </div>

    <!-- Custom Selection Results -->
    <div class="card">
        <h3><i class="fas fa-layer-group"></i> Selected Records Summary</h3>
        
        <div class="stats-grid" id="customSelectionStats">
            <!-- Will be populated by JavaScript -->
        </div>
        
        <div class="table-container">
            <table id="customSelectionTable">
                <thead>
                    <tr>
                        <th>Set No.</th>
                        <th>Record ID</th>
                        <th>Vert (lbs)</th>
                        <th>Trans (lbs)</th>
                        <th>Long (lbs)</th>
                        <th>Resultant (lbs)</th>
                    </tr>
                </thead>
                <tbody id="customSelectionBody">
                    <!-- Will be populated by JavaScript -->
                </tbody>
                <tfoot id="customSelectionFooter">
                    <!-- Will be populated by JavaScript -->
                </tfoot>
            </table>
        </div>
    </div>
    {% endif %}
    


    <div class="action-buttons">
        <button class="btn btn-secondary" onclick="window.history.back()">
            <i class="fas fa-arrow-left"></i> Back to Previous
        </button>
        <button class="btn btn-primary" onclick="window.print()">
            <i class="fas fa-print"></i> Print Report
        </button>
        <button class="btn btn-info" onclick="window.location.href='/'">
            <i class="fas fa-home"></i> Back to Home
        </button>
    </div>
</div>

<footer>
    <p>Generated on {% now "F j, Y, g:i a" %} | Structural Analysis Tool</p>
</footer>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // Toggle buffer settings visibility
    const applyBufferCheckbox = document.getElementById('applyBuffer');
    const bufferSettings = document.getElementById('bufferSettings');
    
    applyBufferCheckbox.addEventListener('change', function() {
        bufferSettings.style.display = this.checked ? 'block' : 'none';
    });
    
    // Handle final calculation
    const calculateButton = document.getElementById('calculateFinalLoads');
    calculateButton.addEventListener('click', function() {
        // Get calculation data from previous step (you'll need to pass this from the previous view)
        const calculationData = JSON.parse('{{ calculation_data_json|escapejs }}' || '[]');
        
        // Get form data
        const formData = new FormData(document.getElementById('finalCalculationForm'));
        
        // Add calculation data to form data
        formData.append('calculation_data', JSON.stringify(calculationData));
        
        // Show loading indicator
        calculateButton.disabled = true;
        calculateButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Calculating...';
        
        // Send AJAX request
        fetch('{% url "calculate_final_loads" %}', {
            method: 'POST',
            body: formData,
            headers: {
                'X-CSRFToken': '{{ csrf_token }}'
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Display results
                displayFinalResults(data.max_resultant_values);
            } else {
                alert('Error: ' + data.error);
            }
        })
        .catch(error => {
            alert('Error: ' + error.message);
        })
        .finally(() => {
            // Reset button
            calculateButton.disabled = false;
            calculateButton.innerHTML = '<i class="fas fa-calculator"></i> Calculate Final Loads';
        });
    });
    
    function displayFinalResults(results) {
        const tableBody = document.querySelector('#finalLoadsTable tbody');
        tableBody.innerHTML = '';
        
        let totalVert = 0;
        let totalTrans = 0;
        let totalLong = 0;
        
        for (const [setNo, values] of Object.entries(results)) {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${setNo}</td>
                <td>${values.vert.toFixed(2)}</td>
                <td>${values.trans.toFixed(2)}</td>
                <td>${values.long.toFixed(2)}</td>
                <td>${values.resultant.toFixed(2)}</td>
            `;
            tableBody.appendChild(row);
            
            totalVert += values.vert;
            totalTrans += values.trans;
            totalLong += values.long;
        }
        
        // Add total row
        const totalResultant = Math.sqrt(totalVert**2 + totalTrans**2 + totalLong**2);
        const totalRow = document.createElement('tr');
        totalRow.classList.add('highlight');
        totalRow.innerHTML = `
            <td><strong>Total</strong></td>
            <td><strong>${totalVert.toFixed(2)}</strong></td>
            <td><strong>${totalTrans.toFixed(2)}</strong></td>
            <td><strong>${totalLong.toFixed(2)}</strong></td>
            <td><strong>${totalResultant.toFixed(2)}</strong></td>
        `;
        tableBody.appendChild(totalRow);
        
        // Show results section
        document.getElementById('finalResults').style.display = 'block';
    }
});
</script>

<script>
// Store factored loads data from Django
const factoredLoadsData = {
    {% for condition_name, condition_data in factored_loads_by_condition.items %}
    '{{ condition_name }}': {
        factors: {{ condition_data.factors|safe }},
        {% if condition_data.calculation_type == 'individual_records' %}
        allRecords: {{ condition_data.all_records|safe }},
        {% else %}
        allRecords: [], // No individual records when using processed sums
        {% endif %}
        calculationType: '{{ condition_data.calculation_type }}'
    },
    {% endfor %}
};

// Custom Selection Logic for Load Conditions Page
document.addEventListener('DOMContentLoaded', function() {
    initializeSelection();
});

function initializeSelection() {
    const checkboxes = document.querySelectorAll('.record-checkbox');
    const selectAllBtn = document.getElementById('selectAllBtn');
    const selectNoneBtn = document.getElementById('selectNoneBtn');
    const selectedCountSpan = document.getElementById('selectedCount');
    
    // Update selection count and display
    function updateSelection() {
        const selectedCheckboxes = document.querySelectorAll('.record-checkbox:checked');
        selectedCountSpan.textContent = selectedCheckboxes.length;
        
        // Update row styling
        checkboxes.forEach(checkbox => {
            const row = checkbox.closest('tr');
            if (checkbox.checked) {
                row.classList.add('selected-record');
            } else {
                row.classList.remove('selected-record');
            }
        });
        
        // Update custom selection display and factored loads
        updateCustomSelectionDisplay();
        updateFactoredLoadsDisplay();
    }
    
    // Select all records
    selectAllBtn.addEventListener('click', function() {
        checkboxes.forEach(checkbox => {
            checkbox.checked = true;
        });
        updateSelection();
    });
    
    // Select none
    selectNoneBtn.addEventListener('click', function() {
        checkboxes.forEach(checkbox => {
            checkbox.checked = false;
        });
        updateSelection();
    });
    
    // Add event listeners to checkboxes
    checkboxes.forEach(checkbox => {
        checkbox.addEventListener('change', updateSelection);
    });
    
    // Initial update
    updateSelection();
}

function updateCustomSelectionDisplay() {
    const selectedCheckboxes = document.querySelectorAll('.record-checkbox:checked');
    const statsGrid = document.getElementById('customSelectionStats');
    const tableBody = document.getElementById('customSelectionBody');
    const tableFooter = document.getElementById('customSelectionFooter');
    
    // Clear previous content
    statsGrid.innerHTML = '';
    tableBody.innerHTML = '';
    tableFooter.innerHTML = '';
    
    if (selectedCheckboxes.length === 0) {
        statsGrid.innerHTML = '<p>No records selected. Please select records using the checkboxes above.</p>';
        return;
    }
    
    let totalVert = 0;
    let totalTrans = 0;
    let totalLong = 0;
    const selectedRecords = [];
    
    // Process selected records
    selectedCheckboxes.forEach(checkbox => {
        const vert = parseFloat(checkbox.dataset.vert) || 0;
        const trans = parseFloat(checkbox.dataset.trans) || 0;
        const long = parseFloat(checkbox.dataset.long) || 0;
        const resultant = parseFloat(checkbox.dataset.resultant) || 0;
        const setNo = checkbox.dataset.setNo || 'Unknown';
        const recordId = checkbox.dataset.recordId;
        
        totalVert += vert;
        totalTrans += trans;
        totalLong += long;
        
        selectedRecords.push({
            setNo,
            recordId,
            vert,
            trans,
            long,
            resultant
        });
    });
    
    // Calculate final resultant
    const finalResultant = Math.sqrt(totalVert**2 + totalTrans**2 + totalLong**2);
    
    // Update stats grid
    statsGrid.innerHTML = `
        <div class="stat-card">
            <div class="stat-label">Selected Records</div>
            <div class="stat-value">${selectedCheckboxes.length}</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Total Vert</div>
            <div class="stat-value">${totalVert.toFixed(2)}</div>
            <div class="stat-label">(lbs)</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Total Trans</div>
            <div class="stat-value">${totalTrans.toFixed(2)}</div>
            <div class="stat-label">(lbs)</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Total Long</div>
            <div class="stat-value">${totalLong.toFixed(2)}</div>
            <div class="stat-label">(lbs)</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Resultant</div>
            <div class="stat-value">${finalResultant.toFixed(2)}</div>
            <div class="stat-label">(lbs)</div>
        </div>
    `;
    
    // Update table body
    selectedRecords.forEach(record => {
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${record.setNo}</td>
            <td>${record.recordId}</td>
            <td>${record.vert.toFixed(2)}</td>
            <td>${record.trans.toFixed(2)}</td>
            <td>${record.long.toFixed(2)}</td>
            <td>${record.resultant.toFixed(2)}</td>
        `;
        tableBody.appendChild(row);
    });
    
    // Update table footer with totals
    tableFooter.innerHTML = `
        <tr class="highlight">
            <td colspan="2"><strong>Selected Records Sum</strong></td>
            <td><strong>${totalVert.toFixed(2)}</strong></td>
            <td><strong>${totalTrans.toFixed(2)}</strong></td>
            <td><strong>${totalLong.toFixed(2)}</strong></td>
            <td><strong>${finalResultant.toFixed(2)}</strong></td>
        </tr>
    `;
    
    // Store current custom selection for further calculations
    window.currentCustomSelection = {
        totalVert,
        totalTrans,
        totalLong,
        finalResultant,
        selectedRecords
    };
}

function updateFactoredLoadsDisplay() {
    const selectedCheckboxes = document.querySelectorAll('.record-checkbox:checked');
    
    if (selectedCheckboxes.length === 0) {
        // Hide all factored loads sections
        document.querySelectorAll('.factored-loads-section').forEach(section => {
            section.style.display = 'none';
        });
        return;
    }
    
    // Get selected record IDs
    const selectedRecordIds = Array.from(selectedCheckboxes).map(checkbox => checkbox.dataset.recordId);
    
    // Process each load condition
    Object.keys(factoredLoadsData).forEach((conditionName, index) => {
        const conditionData = factoredLoadsData[conditionName];
        const container = document.getElementById(`factoredResults${index + 1}`);
        const section = document.querySelector(`.factored-loads-section[data-condition="${conditionName}"]`);
        
        if (!container || !section) return;
        
        // Filter records to only show selected ones
        const selectedFactoredRecords = conditionData.allRecords.filter(record => 
            selectedRecordIds.includes(record.record_id)
        );
        
        // Group by Set No.
        const groupedData = {};
        selectedFactoredRecords.forEach(record => {
            const setNo = record['Set No.'] || 'Unknown';
            if (!groupedData[setNo]) {
                groupedData[setNo] = [];
            }
            groupedData[setNo].push(record);
        });
        
        // Build HTML for factored loads
        let html = '';
        
        Object.keys(groupedData).forEach(setNo => {
            const records = groupedData[setNo];
            html += `
                <div class="set-container">
                    <div class="set-header">
                        <h4><i class="fas fa-cubes"></i> Set No. ${setNo} <span class="badge badge-primary">${records.length} records</span></h4>
                    </div>
                    
                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
            `;
            
            // Add headers (exclude internal fields)
            if (records.length > 0) {
                Object.keys(records[0]).forEach(key => {
                    if (!['max_resultant_flag', 'record_id', 'Structure_Loads_Vert', 'Structure_Loads_Trans', 'Structure_Loads_Long', 'Resultant', 'Set_No'].includes(key)) {
                        html += `<th>${key}</th>`;
                    }
                });
            }
            
            html += `
                                </tr>
                            </thead>
                            <tbody>
            `;
            
            // Add rows
            records.forEach(record => {
                html += `<tr>`;
                Object.keys(record).forEach(key => {
                    if (!['max_resultant_flag', 'record_id', 'Structure_Loads_Vert', 'Structure_Loads_Trans', 'Structure_Loads_Long', 'Resultant', 'Set_No'].includes(key)) {
                        const value = record[key];
                        if (key === 'Resultant (lbs)' || key.includes('Structure Loads')) {
                            html += `<td class="resultant-cell">${value}</td>`;
                        } else {
                            html += `<td>${value}</td>`;
                        }
                    }
                });
                html += `</tr>`;
            });
            
            html += `
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
        });
        
        container.innerHTML = html;
        section.style.display = 'block';
    });
}

function deleteLoadCondition(pk) {
    if (confirm('Are you sure you want to delete this load condition?')) {
        // Create a form and submit it via POST
        const form = document.createElement('form');
        form.method = 'POST';
        form.action = `/load-condition/${pk}/delete/`;
        
        const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]');
        if (csrfToken) {
            form.appendChild(csrfToken.cloneNode(true));
        } else {
            const csrfInput = document.createElement('input');
            csrfInput.type = 'hidden';
            csrfInput.name = 'csrfmiddlewaretoken';
            csrfInput.value = '{{ csrf_token }}';
            form.appendChild(csrfInput);
        }
        
        document.body.appendChild(form);
        form.submit();
    }
}
</script>"

this is complete code of calculation page 
this is view
"def calculation_view(request):
    # Initialize context with default values to avoid UnboundLocalError
    context = {'error': None}
    
    if request.method == 'POST':  # Handle POST requests
        # Get calculation data and selection source from POST parameters
        calculation_data_json = request.POST.get('calculation_data')
        selection_source = request.POST.get('selection_source', 'imported')
        custom_groups_json = request.POST.get('custom_groups_data', '{}')  # NEW: Get custom groups data
        
        if calculation_data_json:
            try:
                calculation_data = json.loads(calculation_data_json)
                custom_groups_data = json.loads(custom_groups_json)  # NEW: Parse custom groups
                
                # Add resultant calculation and unique ID to each record
                for index, record in enumerate(calculation_data):
                    vert = float(record.get('Structure Loads Vert. (lbs)', 0) or 0)
                    trans = float(record.get('Structure Loads Trans. (lbs)', 0) or 0)
                    long = float(record.get('Structure Loads Long. (lbs)', 0) or 0)
                    
                    # Calculate SQRT(Vert² + Trans² + Long²) for each record
                    resultant = math.sqrt(vert**2 + trans**2 + long**2)
                    record['Resultant'] = round(resultant, 2)
                    # Add unique ID for checkbox identification
                    record['record_id'] = f"record_{index}"
                    
                    # Add clean keys for template access
                    record['Structure_Loads_Vert'] = vert
                    record['Structure_Loads_Trans'] = trans
                    record['Structure_Loads_Long'] = long
                    # Store Set No. in data attribute
                    record['Set_No'] = record.get('Set No.', 'Unknown')
                    # Store Load Case Description for grouping
                    record['Load_Case_Description'] = record.get('Load Case Description', 'Unknown')
                
                # NEW: Group data based on selection source with custom groups support
                grouped_data = group_calculation_data(calculation_data, selection_source, custom_groups_data)
                
                # NEW: Create set-wise grouping within each group
                set_wise_data = {}
                set_max_resultants = {}
                
                for group_name, records in grouped_data.items():
                    set_wise_data[group_name] = {}
                    set_max_resultants[group_name] = {}
                    
                    # Group records by Set No. within this group
                    for record in records:
                        set_no = record.get('Set_No', 'Unknown')
                        if set_no not in set_wise_data[group_name]:
                            set_wise_data[group_name][set_no] = []
                        set_wise_data[group_name][set_no].append(record)
                    
                    # Calculate max resultant for each set within this group
                    for set_no, set_records in set_wise_data[group_name].items():
                        resultant_values = [record['Resultant'] for record in set_records]
                        max_resultant = max(resultant_values)
                        max_index = resultant_values.index(max_resultant)
                        
                        set_max_resultants[group_name][set_no] = {
                            'vert': set_records[max_index]['Structure_Loads_Vert'],
                            'trans': set_records[max_index]['Structure_Loads_Trans'],
                            'long': set_records[max_index]['Structure_Loads_Long'],
                            'resultant': max_resultant,
                            'record_id': set_records[max_index]['record_id']
                        }
                        
                        # Add max resultant flag to set records
                        for i, record in enumerate(set_records):
                            if resultant_values[i] == max_resultant:
                                record['set_max_resultant_flag'] = 'yes'
                            else:
                                record['set_max_resultant_flag'] = 'no'
                                
                global_set_max_resultants = {}
                all_records = []
                
                # Collect all records from all groups
                for group_name, records in grouped_data.items():
                    all_records.extend(records)
                
                # Group all records by Set No. globally
                global_set_records = {}
                for record in all_records:
                    set_no = record.get('Set_No', 'Unknown')
                    if set_no not in global_set_records:
                        global_set_records[set_no] = []
                    global_set_records[set_no].append(record)
                
                # Find max resultant for each set across all groups
                for set_no, records in global_set_records.items():
                    resultant_values = [record['Resultant'] for record in records]
                    max_resultant = max(resultant_values)
                    max_index = resultant_values.index(max_resultant)
                    
                    global_set_max_resultants[set_no] = {
                        'vert': records[max_index]['Structure_Loads_Vert'],
                        'trans': records[max_index]['Structure_Loads_Trans'],
                        'long': records[max_index]['Structure_Loads_Long'],
                        'resultant': max_resultant,
                        'record_id': records[max_index]['record_id'],
                        'group_name': None  # We don't track which group it came from for global max
                    }
                    
                    # Add global max resultant flag to ALL records (not just within groups)
                    for record in records:
                        if record['Resultant'] == max_resultant:
                            record['global_set_max_resultant_flag'] = 'yes'
                        else:
                            record['global_set_max_resultant_flag'] = 'no'
                
                # Calculate max values for each group and flag max resultant rows
                group_max_values = {}
                max_resultant_values = {}  # Store the actual values that created the max resultant
                max_resultant_indexes = {}  # Store indexes for JavaScript approach
                
                for group_name, records in grouped_data.items():
                    vert_values = [float(record.get('Structure Loads Vert. (lbs)', 0) or 0) for record in records]
                    trans_values = [float(record.get('Structure Loads Trans. (lbs)', 0) or 0) for record in records]
                    long_values = [float(record.get('Structure Loads Long. (lbs)', 0) or 0) for record in records]
                    resultant_values = [record['Resultant'] for record in records]
                    
                    # Find the maximum resultant value
                    max_resultant = max(resultant_values)
                    max_index = resultant_values.index(max_resultant)
                    
                    # Store the actual values that created the max resultant
                    max_resultant_values[group_name] = {
                        'vert': vert_values[max_index],
                        'trans': trans_values[max_index],
                        'long': long_values[max_index],
                        'resultant': max_resultant,
                        'record_id': records[max_index]['record_id']  # Add record ID
                    }
                    
                    # Store index for JavaScript approach
                    max_resultant_indexes[group_name] = max_index
                    
                    # Add a simple flag to each record (as a string to avoid underscore issues)
                    for i, record in enumerate(records):
                        if resultant_values[i] == max_resultant:
                            record['max_resultant_flag'] = 'yes'
                        else:
                            record['max_resultant_flag'] = 'no'
                    
                    group_max_values[group_name] = {
                        'max_vert': max(vert_values),
                        'max_trans': max(trans_values),
                        'max_long': max(long_values),
                        'max_resultant': max_resultant,
                        'count': len(records)
                    }
                
                # Calculate combined values across all groups using the actual values that created max resultants
                combined_vert = sum([values['vert'] for values in max_resultant_values.values()])
                combined_trans = sum([values['trans'] for values in max_resultant_values.values()])
                combined_long = sum([values['long'] for values in max_resultant_values.values()])
                
                # Calculate the SQRT formula for combined values
                combined_sqrt = math.sqrt(combined_vert**2 + combined_trans**2 + combined_long**2)
                
                # Prepare context for template
                context = {
                    'grouped_data': grouped_data,
                    'group_max_values': group_max_values,
                    'max_resultant_values': max_resultant_values,
                    'global_set_max_resultants': global_set_max_resultants,
                    'set_wise_data': set_wise_data,  # NEW: Set-wise grouped data
                    'set_max_resultants': set_max_resultants,  # NEW: Set max resultants
                    'combined_vert': combined_vert,
                    'combined_trans': combined_trans,
                    'combined_long': combined_long,
                    'combined_sqrt': combined_sqrt,
                    'calculation_data': calculation_data,
                    'max_resultant_indexes': max_resultant_indexes,
                    'calculation_data_json': json.dumps(calculation_data),
                    'selection_source': selection_source,
                    'custom_groups_data': custom_groups_data,  # NEW: Pass to template for reference
                    'error': None
                }
                
            except json.JSONDecodeError:
                context['error'] = 'Invalid calculation data format'
            except Exception as e:
                context['error'] = f'Error processing data: {str(e)}'
        else:
            context['error'] = 'No calculation data provided'
    
    # Handle GET requests
    elif request.method == 'GET':
        calculation_data_json = request.GET.get('calculation_data')
        selection_source = request.GET.get('selection_source', 'imported')
        custom_groups_json = request.GET.get('custom_groups_data', '{}')  # NEW: Get custom groups data
        
        if calculation_data_json:
            try:
                calculation_data = json.loads(calculation_data_json)
                custom_groups_data = json.loads(custom_groups_json)  # NEW: Parse custom groups
                
                # Add resultant calculation and unique ID to each record
                for index, record in enumerate(calculation_data):
                    vert = float(record.get('Structure Loads Vert. (lbs)', 0) or 0)
                    trans = float(record.get('Structure Loads Trans. (lbs)', 0) or 0)
                    long = float(record.get('Structure Loads Long. (lbs)', 0) or 0)
                    
                    resultant = math.sqrt(vert**2 + trans**2 + long**2)
                    record['Resultant'] = round(resultant, 2)
                    record['record_id'] = f"record_{index}"
                    record['Structure_Loads_Vert'] = vert
                    record['Structure_Loads_Trans'] = trans
                    record['Structure_Loads_Long'] = long
                    record['Set_No'] = record.get('Set No.', 'Unknown')
                    record['Load_Case_Description'] = record.get('Load Case Description', 'Unknown')
                
                # NEW: Group data based on selection source with custom groups support
                grouped_data = group_calculation_data(calculation_data, selection_source, custom_groups_data)
                
                # NEW: Create set-wise grouping within each group for GET requests
                set_wise_data = {}
                set_max_resultants = {}
                
                for group_name, records in grouped_data.items():
                    set_wise_data[group_name] = {}
                    set_max_resultants[group_name] = {}
                    
                    # Group records by Set No. within this group
                    for record in records:
                        set_no = record.get('Set_No', 'Unknown')
                        if set_no not in set_wise_data[group_name]:
                            set_wise_data[group_name][set_no] = []
                        set_wise_data[group_name][set_no].append(record)
                    
                    # Calculate max resultant for each set within this group
                    for set_no, set_records in set_wise_data[group_name].items():
                        resultant_values = [record['Resultant'] for record in set_records]
                        max_resultant = max(resultant_values)
                        max_index = resultant_values.index(max_resultant)
                        
                        set_max_resultants[group_name][set_no] = {
                            'vert': set_records[max_index]['Structure_Loads_Vert'],
                            'trans': set_records[max_index]['Structure_Loads_Trans'],
                            'long': set_records[max_index]['Structure_Loads_Long'],
                            'resultant': max_resultant,
                            'record_id': set_records[max_index]['record_id']
                        }
                        
                        # Add max resultant flag to set records
                        for i, record in enumerate(set_records):
                            if resultant_values[i] == max_resultant:
                                record['set_max_resultant_flag'] = 'yes'
                            else:
                                record['set_max_resultant_flag'] = 'no'
                
                # Calculate max values
                group_max_values = {}
                max_resultant_values = {}
                max_resultant_indexes = {}
                
                for group_name, records in grouped_data.items():
                    vert_values = [float(record.get('Structure Loads Vert. (lbs)', 0) or 0) for record in records]
                    trans_values = [float(record.get('Structure Loads Trans. (lbs)', 0) or 0) for record in records]
                    long_values = [float(record.get('Structure Loads Long. (lbs)', 0) or 0) for record in records]
                    resultant_values = [record['Resultant'] for record in records]
                    
                    max_resultant = max(resultant_values)
                    max_index = resultant_values.index(max_resultant)
                    
                    max_resultant_values[group_name] = {
                        'vert': vert_values[max_index],
                        'trans': trans_values[max_index],
                        'long': long_values[max_index],
                        'resultant': max_resultant,
                        'record_id': records[max_index]['record_id']
                    }
                    
                    max_resultant_indexes[group_name] = max_index
                    
                    for i, record in enumerate(records):
                        if resultant_values[i] == max_resultant:
                            record['max_resultant_flag'] = 'yes'
                        else:
                            record['max_resultant_flag'] = 'no'
                    
                    group_max_values[group_name] = {
                        'max_vert': max(vert_values),
                        'max_trans': max(trans_values),
                        'max_long': max(long_values),
                        'max_resultant': max_resultant,
                        'count': len(records)
                    }
                    
                global_set_max_resultants = {}
                all_records = []
                
                # Collect all records from all groups
                for group_name, records in grouped_data.items():
                    all_records.extend(records)
                
                # Group all records by Set No. globally
                global_set_records = {}
                for record in all_records:
                    set_no = record.get('Set_No', 'Unknown')
                    if set_no not in global_set_records:
                        global_set_records[set_no] = []
                    global_set_records[set_no].append(record)
                
                # Find max resultant for each set across all groups
                for set_no, records in global_set_records.items():
                    resultant_values = [record['Resultant'] for record in records]
                    max_resultant = max(resultant_values)
                    max_index = resultant_values.index(max_resultant)
                    
                    global_set_max_resultants[set_no] = {
                        'vert': records[max_index]['Structure_Loads_Vert'],
                        'trans': records[max_index]['Structure_Loads_Trans'],
                        'long': records[max_index]['Structure_Loads_Long'],
                        'resultant': max_resultant,
                        'record_id': records[max_index]['record_id'],
                        'group_name': None
                    }
                    
                    # Add global max resultant flag to ALL records
                    for record in records:
                        if record['Resultant'] == max_resultant:
                            record['global_set_max_resultant_flag'] = 'yes'
                        else:
                            record['global_set_max_resultant_flag'] = 'no'
                
                # Calculate combined values
                combined_vert = sum([values['vert'] for values in max_resultant_values.values()])
                combined_trans = sum([values['trans'] for values in max_resultant_values.values()])
                combined_long = sum([values['long'] for values in max_resultant_values.values()])
                combined_sqrt = math.sqrt(combined_vert**2 + combined_trans**2 + combined_long**2)
                
                context = {
                    'grouped_data': grouped_data,
                    'group_max_values': group_max_values,
                    'max_resultant_values': max_resultant_values,
                    'global_set_max_resultants': global_set_max_resultants,
                    'set_wise_data': set_wise_data,  # NEW: Set-wise grouped data
                    'set_max_resultants': set_max_resultants,  # NEW: Set max resultants
                    'combined_vert': combined_vert,
                    'combined_trans': combined_trans,
                    'combined_long': combined_long,
                    'combined_sqrt': combined_sqrt,
                    'calculation_data': calculation_data,
                    'max_resultant_indexes': max_resultant_indexes,
                    'calculation_data_json': json.dumps(calculation_data),
                    'selection_source': selection_source,
                    'custom_groups_data': custom_groups_data,  # NEW: Pass to template
                    'error': None
                }
                
            except json.JSONDecodeError:
                context['error'] = 'Invalid calculation data format'
            except Exception as e:
                context['error'] = f'Error processing data: {str(e)}'
        else:
            context['error'] = 'No calculation data provided'
    else:
        context['error'] = 'Invalid request method'
    
    return render(request, 'app1/calculation.html', context)"

this is calculation.html 
"  <div class="container">
        <header>
            <h2><i class="fas fa-calculator"></i> Calculation Results</h2>
            <p>Detailed analysis of structural load calculations</p>
        </header>
        
        {% if error %}
            <div class="error">
                <i class="fas fa-exclamation-circle"></i> {{ error }}
            </div>
        {% else %}
            <!-- Selection Controls -->
            <div class="card">
                <h3><i class="fas fa-mouse-pointer"></i> Record Selection</h3>
                <!-- In the selection controls section -->
                <div class="selection-controls">
                    <button type="button" id="selectAllBtn" class="btn btn-outline-primary">
                        <i class="fas fa-check-square"></i> Select All
                    </button>
                    <button type="button" id="selectNoneBtn" class="btn btn-outline-secondary">
                        <i class="fas fa-square"></i> Select None
                    </button>
                    <button type="button" id="selectMaxResultantBtn" class="btn btn-outline-info">
                        <i class="fas fa-star"></i> Select Group Max Resultant
                    </button>
                    <button type="button" id="selectSetMaxResultantBtn" class="btn btn-outline-warning">
                        <i class="fas fa-layer-group"></i> Select Set Max Resultant (Within Groups)
                    </button>
                    <!-- NEW BUTTON -->
                    <button type="button" id="selectGlobalSetMaxResultantBtn" class="btn btn-outline-success">
                        <i class="fas fa-globe"></i> Select Global Set Max Resultant
                    </button>
                    <span class="selection-count">Selected: <span id="selectedCount">0</span> records</span>
                </div>
            </div>

          <div class="card">
    <h3><i class="fas fa-list-ol"></i> Selected Records 
        {% if selection_source == 'imported' %}Grouped by Load Case{% endif %}
        {% if selection_source == 'group' %}Grouped by Load Case Groups{% endif %}
        {% if selection_source == 'custom' %}Grouped by Custom Groups{% endif %}
        {% if not selection_source %}Grouped by Set Number{% endif %}
    </h3>
    
    {% for group_name, records in grouped_data.items %}
        <div class="set-container">
            <div class="set-header">
                <h4>
                    <i class="fas fa-cubes"></i> 
                    {% if selection_source == 'imported' %}Load Case: {{ group_name }}{% endif %}
                    {% if selection_source == 'group' %}Group: {{ group_name }}{% endif %}
                    {% if selection_source == 'custom' %}Custom Group: {{ group_name }}{% endif %}
                    {% if not selection_source %}Set No. {{ group_name }}{% endif %}
                    <span class="badge badge-primary">{{ records|length }} records</span>
                </h4>
            </div>

            <!-- Group-wise table showing ALL records -->
            <div class="group-wise-section">
                <h5><i class="fas fa-chart-line"></i> Group Records (All Records)</h5>
                <div class="table-container">
                    <table class="group-records-table">
                        <thead>
                            <tr>
                                <th>Select</th>
                                {% for key in records.0.keys %}
                                    {% if key != 'max_resultant_flag' and key != 'record_id' and key != 'Structure_Loads_Vert' and key != 'Structure_Loads_Trans' and key != 'Structure_Loads_Long' and key != 'Set_No' and key != 'set_max_resultant_flag' %}
                                        <th>{{ key }}</th>
                                    {% endif %}
                                {% endfor %}
                            </tr>
                        </thead>
                        <tbody>
                            {% for record in records %}
                            <tr class="{% if record.max_resultant_flag == 'yes' %}max-resultant-row{% endif %} 
                                    {% if record.global_set_max_resultant_flag == 'yes' %}global-max-resultant-row{% endif %}" 
                                data-record-id="{{ record.record_id }}">
                                <td>
                                    <input type="checkbox" class="record-checkbox" 
                                        data-record-id="{{ record.record_id }}"
                                        data-set-no="{{ record.Set_No }}"
                                        data-vert="{{ record.Structure_Loads_Vert }}"
                                        data-trans="{{ record.Structure_Loads_Trans }}"
                                        data-long="{{ record.Structure_Loads_Long }}"
                                        data-resultant="{{ record.Resultant }}"
                                        {% if record.max_resultant_flag == 'yes' %}checked{% endif %}>
                                    {% if record.global_set_max_resultant_flag == 'yes' %}
                                    <span class="global-max-badge" title="Global Max for Set {{ record.Set_No }}"></span>
                                    {% endif %}
                                </td>
                                {% for key, value in record.items %}
                                    {% if key != 'max_resultant_flag' and key != 'record_id' and key != 'Structure_Loads_Vert' and key != 'Structure_Loads_Trans' and key != 'Structure_Loads_Long' and key != 'Set_No' and key != 'set_max_resultant_flag' %}
                                        {% if key == 'Resultant' %}
                                            <td class="resultant-cell">{{ value }}</td>
                                        {% else %}
                                            <td>{{ value }}</td>
                                        {% endif %}
                                    {% endif %}
                                {% endfor %}
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Set-wise tables for this group -->
            <div class="set-wise-section">
                <h5><i class="fas fa-layer-group"></i> Set-wise Records</h5>
                
                {% for set_no, set_records in set_wise_data.items %}
                    {% if set_no == group_name %}
                        {% for inner_set_no, inner_set_records in set_records.items %}
                        <div class="set-subgroup">
                            <h6>
                                <i class="fas fa-cube"></i> Set {{ inner_set_no }}
                                <span class="badge badge-secondary">{{ inner_set_records|length }} records</span>
                            </h6>
                            
                            <div class="table-container">
                                <table class="set-records-table">
                                    <thead>
                                        <tr>
                                            <th>Select</th>
                                            {% for key in inner_set_records.0.keys %}
                                                {% if key != 'max_resultant_flag' and key != 'record_id' and key != 'Structure_Loads_Vert' and key != 'Structure_Loads_Trans' and key != 'Structure_Loads_Long' and key != 'Set_No' and key != 'set_max_resultant_flag' %}
                                                    <th>{{ key }}</th>
                                                {% endif %}
                                            {% endfor %}
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {% for record in inner_set_records %}
                                        <tr class="{% if record.set_max_resultant_flag == 'yes' %}set-max-resultant-row{% endif %}" 
                                            data-record-id="{{ record.record_id }}">
                                            <td>
                                                <input type="checkbox" class="record-checkbox set-record-checkbox" 
                                                    data-record-id="{{ record.record_id }}"
                                                    data-set-no="{{ record.Set_No }}"
                                                    data-vert="{{ record.Structure_Loads_Vert }}"
                                                    data-trans="{{ record.Structure_Loads_Trans }}"
                                                    data-long="{{ record.Structure_Loads_Long }}"
                                                    data-resultant="{{ record.Resultant }}"
                                                    {% if record.set_max_resultant_flag == 'yes' %}checked{% endif %}>
                                            </td>
                                            {% for key, value in record.items %}
                                                {% if key != 'max_resultant_flag' and key != 'record_id' and key != 'Structure_Loads_Vert' and key != 'Structure_Loads_Trans' and key != 'Structure_Loads_Long' and key != 'Set_No' and key != 'set_max_resultant_flag' %}
                                                    {% if key == 'Resultant' %}
                                                        <td class="resultant-cell">{{ value }}</td>
                                                    {% else %}
                                                        <td>{{ value }}</td>
                                                    {% endif %}
                                                {% endif %}
                                            {% endfor %}
                                        </tr>
                                        {% endfor %}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        {% if not forloop.last %}<hr class="set-divider">{% endif %}
                        {% endfor %}
                    {% endif %}
                {% empty %}
                    <p>No set-wise data available.</p>
                {% endfor %}
            </div>
        </div>
        {% if not forloop.last %}<hr>{% endif %}
    {% endfor %}
</div>
            
            <!-- Custom Selection Results Card -->
            <div class="card">
                <h3><i class="fas fa-layer-group"></i> Custom Selection Results</h3>
                
                <div class="stats-grid" id="customSelectionStats">
                    <!-- Will be populated by JavaScript -->
                </div>
                
                <div class="table-container">
                    <table id="customSelectionTable">
                        <thead>
                            <tr>
                                <th>Set No.</th>
                                <th>Record ID</th>
                                <th>Vert (lbs)</th>
                                <th>Trans (lbs)</th>
                                <th>Long (lbs)</th>
                                <th>Resultant (lbs)</th>
                            </tr>
                        </thead>
                        <tbody id="customSelectionBody">
                            <!-- Will be populated by JavaScript -->
                        </tbody>
                        <tfoot id="customSelectionFooter">
                            <!-- Will be populated by JavaScript -->
                        </tfoot>
                    </table>
                </div>
            </div>



            <div class="card">
                <h3><i class="fas fa-calculator"></i> Buffer Configuration</h3>
                
                <form id="bufferConfigurationForm">
                    <div class="form-group">
                        <label for="bufferConfig">Apply Buffer</label>
                        <div class="checkbox-group">
                            <input type="checkbox" id="applyBuffer" name="apply_buffer">
                            <label for="applyBuffer">Apply buffer to combined loads</label>
                        </div>
                        
                        <div id="bufferSettings" style="display: none; margin-top: 10px;">
                            <h4>Vertical Direction</h4>
                            <div class="direction-config">
                                <input type="number" id="vertBuffer" name="vert_buffer" placeholder="Buffer value (lbs)" value="100" step="1" min="0">
                                <select id="vertRounding" name="vert_rounding">
                                    <option value="0">No rounding</option>
                                    <option value="1">Round to nearest 1</option>
                                    <option value="10">Round to nearest 10</option>
                                    <option value="100" selected>Round to nearest 100</option>
                                    <option value="1000">Round to nearest 1000</option>
                                </select>
                            </div>
                            
                            <h4>Transverse Direction</h4>
                            <div class="direction-config">
                                <input type="number" id="transBuffer" name="trans_buffer" placeholder="Buffer value (lbs)" value="100" step="1" min="0">
                                <select id="transRounding" name="trans_rounding">
                                    <option value="0">No rounding</option>
                                    <option value="1">Round to nearest 1</option>
                                    <option value="10">Round to nearest 10</option>
                                    <option value="100" selected>Round to nearest 100</option>
                                    <option value="1000">Round to nearest 1000</option>
                                </select>
                            </div>
                            
                            <h4>Longitudinal Direction</h4>
                            <div class="direction-config">
                                <input type="number" id="longBuffer" name="long_buffer" placeholder="Buffer value (lbs)" value="25" step="1" min="0">
                                <select id="longRounding" name="long_rounding">
                                    <option value="0">No rounding</option>
                                    <option value="1">Round to nearest 1</option>
                                    <option value="10" selected>Round to nearest 10</option>
                                    <option value="100">Round to nearest 100</option>
                                    <option value="1000">Round to nearest 1000</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    
                    <button type="button" id="applyBufferBtn" class="btn btn-primary">
                        <i class="fas fa-calculator"></i> Apply Buffer
                    </button>
                </form>
                
                <div id="bufferedResults" style="display: none; margin-top: 20px;">
                    <h4>Buffered Results</h4>
                    <div class="table-container">
                        <table id="bufferedLoadsTable">
                            <thead>
                                <tr>
                                    <th>Set No.</th>
                                    <th>Vert (lbs)</th>
                                    <th>Trans (lbs)</th>
                                    <th>Long (lbs)</th>
                                    <th>Resultant (lbs)</th>
                                </tr>
                            </thead>
                            <tbody>
                                <!-- Results will be populated by JavaScript -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        
            <div class="action-buttons">
                <button class="btn btn-primary" onclick="window.print()">
                    <i class="fas fa-print"></i> Print Report
                </button>

                <button class="btn btn-info" onclick="goToLoadConditions()">
                    <i class="fas fa-table"></i> Configure Load Conditions
                </button>

                <button class="btn btn-secondary" onclick="window.location.href='/'">
                    <i class="fas fa-home"></i> Back to Home
                </button>
            </div>
        {% endif %}
    </div>
        
            
        <footer>
            <p>Generated on {% now "F j, Y, g:i a" %} | Structural Analysis Tool</p>
        </footer>
    </div>

    <script>
    // JavaScript approach to highlight rows as a backup
    document.addEventListener('DOMContentLoaded', function() {
        // Check if we have max resultant indexes from Django
        {% if max_resultant_indexes %}
            const maxResultantIndexes = {
                {% for set_no, index in max_resultant_indexes.items %}
                    '{{ set_no }}': {{ index }},
                {% endfor %}
            };
            
            // Find all set containers
            const setContainers = document.querySelectorAll('.set-container');
            
            setContainers.forEach(container => {
                // Extract set number from header
                const header = container.querySelector('.set-header h4');
                if (header) {
                    const setText = header.textContent || header.innerText;
                    const setMatch = setText.match(/Set No\.\s*(\S+)/);
                    
                    if (setMatch && setMatch[1]) {
                        const setNo = setMatch[1].trim();
                        const maxIndex = maxResultantIndexes[setNo];
                        
                        if (maxIndex !== undefined) {
                            // Find the table rows in this set container
                            const rows = container.querySelectorAll('tbody tr');
                            if (rows.length > maxIndex) {
                                rows[maxIndex].classList.add('max-resultant-row');
                            }
                        }
                    }
                }
            });
        {% endif %}
    });
</script>

<script>
function goToLoadConditions() {
    const calculationData = {{ calculation_data_json|safe }};
    const processedSums = window.currentCustomSelection; // This contains the buffered sums
    
    // Create a form to submit the data
    const form = document.createElement('form');
    form.method = 'POST';
    form.action = "{% url 'load_condition' %}";
    
    // Add CSRF token
    const csrfToken = document.createElement('input');
    csrfToken.type = 'hidden';
    csrfToken.name = 'csrfmiddlewaretoken';
    csrfToken.value = '{{ csrf_token }}';
    form.appendChild(csrfToken);
    
    // Add calculation data
    const dataInput = document.createElement('input');
    dataInput.type = 'hidden';
    dataInput.name = 'calculation_data';
    dataInput.value = JSON.stringify(calculationData);
    form.appendChild(dataInput);
    
    // NEW: Add processed sums
    const processedSumsInput = document.createElement('input');
    processedSumsInput.type = 'hidden';
    processedSumsInput.name = 'processed_sums';
    processedSumsInput.value = JSON.stringify(processedSums);
    form.appendChild(processedSumsInput);
    
    // Submit the form
    document.body.appendChild(form);
    form.submit();
}
</script>


<script>
// Buffer Configuration Logic
// Corrected Buffer Configuration Logic
document.addEventListener('DOMContentLoaded', function() {
    // Toggle buffer settings visibility
    const applyBufferCheckbox = document.getElementById('applyBuffer');
    const bufferSettings = document.getElementById('bufferSettings');
    
    if (applyBufferCheckbox && bufferSettings) {
        applyBufferCheckbox.addEventListener('change', function() {
            bufferSettings.style.display = this.checked ? 'block' : 'none';
        });
    }
    
    // Handle buffer application
    const applyBufferBtn = document.getElementById('applyBufferBtn');
    if (applyBufferBtn) {
        applyBufferBtn.addEventListener('click', function() {
            applyBufferToResults();
        });
    }
    
    // Correct rounding function that handles both positive and negative numbers
    function roundToNearest(value, rounding) {
        if (rounding === 0) return value;
        return Math.sign(value) * Math.ceil(Math.abs(value) / rounding) * rounding;
    }
    
    function applyBufferToResults() {
        // Get buffer settings
        const applyBuffer = document.getElementById('applyBuffer').checked;
        const vertBuffer = parseFloat(document.getElementById('vertBuffer').value) || 0;
        const transBuffer = parseFloat(document.getElementById('transBuffer').value) || 0;
        const longBuffer = parseFloat(document.getElementById('longBuffer').value) || 0;
        const vertRounding = parseInt(document.getElementById('vertRounding').value) || 0;
        const transRounding = parseInt(document.getElementById('transRounding').value) || 0;
        const longRounding = parseInt(document.getElementById('longRounding').value) || 0;
        
        // Get the max resultant values from Django context
        const maxResultantValues = {
            {% for set_no, values in max_resultant_values.items %}
                '{{ set_no }}': {
                    vert: {{ values.vert }},
                    trans: {{ values.trans }},
                    long: {{ values.long }},
                    resultant: {{ values.resultant }}
                },
            {% endfor %}
        };
        
        // Get the original sum values
        const originalSumValues = {
            vert: {{ combined_vert }},
            trans: {{ combined_trans }},
            long: {{ combined_long }},
            resultant: {{ combined_sqrt }}
        };
        
        // Create processed sum values (initially same as original)
        let processedSumValues = {...originalSumValues};
        
        // Apply buffer and rounding only to sum values if enabled
        if (applyBuffer) {
            // Apply buffers to sum values
            processedSumValues.vert = applyBufferWithSign(originalSumValues.vert, vertBuffer);
            processedSumValues.trans = applyBufferWithSign(originalSumValues.trans, transBuffer);
            processedSumValues.long = applyBufferWithSign(originalSumValues.long, longBuffer);
            
            // Apply rounding to sum values using correct rounding function
            if (vertRounding > 0) {
                processedSumValues.vert = roundToNearest(processedSumValues.vert, vertRounding);
            }
            if (transRounding > 0) {
                processedSumValues.trans = roundToNearest(processedSumValues.trans, transRounding);
            }
            if (longRounding > 0) {
                processedSumValues.long = roundToNearest(processedSumValues.long, longRounding);
            }
            
            // Recalculate resultant after buffer and rounding
            processedSumValues.resultant = Math.sqrt(
                processedSumValues.vert**2 + 
                processedSumValues.trans**2 + 
                processedSumValues.long**2
            );
        }
        
        // Display buffered results
        displayBufferedResults(maxResultantValues, processedSumValues, originalSumValues, {
            applyBuffer,
            vertBuffer,
            transBuffer,
            longBuffer,
            vertRounding,
            transRounding,
            longRounding
        });
    }
    
    function displayBufferedResults(setValues, processedSumValues, originalSumValues, settings) {
        const tableBody = document.querySelector('#bufferedLoadsTable tbody');
        tableBody.innerHTML = '';
        
        // Add individual set rows (unchanged)
        for (const [setNo, values] of Object.entries(setValues)) {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${setNo}</td>
                <td>${values.vert.toFixed(2)}</td>
                <td>${values.trans.toFixed(2)}</td>
                <td>${values.long.toFixed(2)}</td>
                <td>${values.resultant.toFixed(2)}</td>
            `;
            tableBody.appendChild(row);
        }
        
        // Add original sum row
        const originalSumRow = document.createElement('tr');
        originalSumRow.classList.add('original-sum');
        originalSumRow.innerHTML = `
            <td><strong>Original Sum</strong></td>
            <td><strong>${originalSumValues.vert.toFixed(2)}</strong></td>
            <td><strong>${originalSumValues.trans.toFixed(2)}</strong></td>
            <td><strong>${originalSumValues.long.toFixed(2)}</strong></td>
            <td><strong>${originalSumValues.resultant.toFixed(2)}</strong></td>
        `;
        tableBody.appendChild(originalSumRow);
        
        // Add processed sum row (only if buffer was applied)
        if (settings.applyBuffer) {
            const processedSumRow = document.createElement('tr');
            processedSumRow.classList.add('highlight');
            processedSumRow.innerHTML = `
                <td><strong>Processed Sum</strong></td>
                <td><strong>${processedSumValues.vert.toFixed(2)}</strong></td>
                <td><strong>${processedSumValues.trans.toFixed(2)}</strong></td>
                <td><strong>${processedSumValues.long.toFixed(2)}</strong></td>
                <td><strong>${processedSumValues.resultant.toFixed(2)}</strong></td>
            `;
            tableBody.appendChild(processedSumRow);
        }
        
        // Add settings info
        if (settings.applyBuffer) {
            const settingsRow = document.createElement('tr');
            settingsRow.classList.add('settings-info');
            settingsRow.innerHTML = `
                <td colspan="5" style="text-align: left; font-style: italic;">
                    Applied settings: 
                    Vert: +${settings.vertBuffer} lbs, Round to ${settings.vertRounding} | 
                    Trans: +${settings.transBuffer} lbs, Round to ${settings.transRounding} | 
                    Long: +${settings.longBuffer} lbs, Round to ${settings.longRounding}
                </td>
            `;
            tableBody.appendChild(settingsRow);
        }
        
        // Show results section
        document.getElementById('bufferedResults').style.display = 'block';
    }
});
</script>

<script>
// Custom Selection Logic
document.addEventListener('DOMContentLoaded', function() {
    // Initialize selection management
    initializeSelection();
    
    // Original buffer logic (keep as is)
    initializeBufferLogic();
});

function initializeSelection() {
    const checkboxes = document.querySelectorAll('.record-checkbox');
    const selectAllBtn = document.getElementById('selectAllBtn');
    const selectNoneBtn = document.getElementById('selectNoneBtn');
    const selectMaxResultantBtn = document.getElementById('selectMaxResultantBtn');
    const selectSetMaxResultantBtn = document.getElementById('selectSetMaxResultantBtn'); // NEW
    const selectGlobalSetMaxResultantBtn = document.getElementById('selectGlobalSetMaxResultantBtn');
    const selectedCountSpan = document.getElementById('selectedCount');
    
    // Update selection count and display
    function updateSelection() {
        const selectedCheckboxes = document.querySelectorAll('.record-checkbox:checked');
        selectedCountSpan.textContent = selectedCheckboxes.length;
        
        // Update row styling
        checkboxes.forEach(checkbox => {
            const row = checkbox.closest('tr');
            if (checkbox.checked) {
                row.classList.add('selected-record');
            } else {
                row.classList.remove('selected-record');
            }
        });
        
        // Update custom selection display
        updateCustomSelectionDisplay();
    }
    
    // Select all records
    selectAllBtn.addEventListener('click', function() {
        checkboxes.forEach(checkbox => {
            checkbox.checked = true;
        });
        updateSelection();
    });
    
    // Select none
    selectNoneBtn.addEventListener('click', function() {
        checkboxes.forEach(checkbox => {
            checkbox.checked = false;
        });
        updateSelection();
    });

    // Select set max resultant (within groups)
    selectSetMaxResultantBtn.addEventListener('click', function() {
        checkboxes.forEach(checkbox => {
            checkbox.checked = false;
        });
        
        // Check set max resultant rows (within groups)
        const setMaxResultantRows = document.querySelectorAll('.set-max-resultant-row');
        setMaxResultantRows.forEach(row => {
            const checkbox = row.querySelector('.record-checkbox');
            if (checkbox) {
                checkbox.checked = true;
            }
        });
        updateSelection();
    });

    // NEW: Select GLOBAL set max resultant (across all groups)
    selectGlobalSetMaxResultantBtn.addEventListener('click', function() {
        checkboxes.forEach(checkbox => {
            checkbox.checked = false;
        });
        
        // Check global set max resultant rows
        const globalSetMaxResultantRows = document.querySelectorAll('tr[data-record-id]');
        globalSetMaxResultantRows.forEach(row => {
            const checkbox = row.querySelector('.record-checkbox');
            // Check if this row has the global max resultant flag
            const recordId = row.dataset.recordId;
            if (checkbox && row.classList.contains('global-max-resultant-row')) {
                checkbox.checked = true;
            }
        });
        updateSelection();
    });
    
    // Select max resultant records (group-wise)
    selectMaxResultantBtn.addEventListener('click', function() {
        checkboxes.forEach(checkbox => {
            checkbox.checked = false;
        });
        
        // Check max resultant rows
        const maxResultantRows = document.querySelectorAll('.max-resultant-row');
        maxResultantRows.forEach(row => {
            const checkbox = row.querySelector('.record-checkbox');
            if (checkbox) {
                checkbox.checked = true;
            }
        });
        updateSelection();
    });
    
    // Add event listeners to checkboxes
    checkboxes.forEach(checkbox => {
        checkbox.addEventListener('change', updateSelection);
    });
    
    // Initial update
    updateSelection();
}


function updateCustomSelectionDisplay() {
    const selectedCheckboxes = document.querySelectorAll('.record-checkbox:checked');
    const statsGrid = document.getElementById('customSelectionStats');
    const tableBody = document.getElementById('customSelectionBody');
    const tableFooter = document.getElementById('customSelectionFooter');
    
    // Clear previous content
    statsGrid.innerHTML = '';
    tableBody.innerHTML = '';
    tableFooter.innerHTML = '';
    
    if (selectedCheckboxes.length === 0) {
        statsGrid.innerHTML = '<p>No records selected. Please select records using the checkboxes above.</p>';
        return;
    }
    
    let totalVert = 0;
    let totalTrans = 0;
    let totalLong = 0;
    const selectedRecords = [];
    
    // Process selected records
    selectedCheckboxes.forEach(checkbox => {
        const vert = parseFloat(checkbox.dataset.vert) || 0;
        const trans = parseFloat(checkbox.dataset.trans) || 0;
        const long = parseFloat(checkbox.dataset.long) || 0;
        const resultant = parseFloat(checkbox.dataset.resultant) || 0;
        const setNo = checkbox.dataset.setNo || 'Unknown';
        const recordId = checkbox.dataset.recordId;
        
        totalVert += vert;
        totalTrans += trans;
        totalLong += long;
        
        selectedRecords.push({
            setNo,
            recordId,
            vert,
            trans,
            long,
            resultant
        });
    });
    
    // Calculate final resultant
    const finalResultant = Math.sqrt(totalVert**2 + totalTrans**2 + totalLong**2);
    
    // Update stats grid
    statsGrid.innerHTML = `
        <div class="stat-card">
            <div class="stat-label">Selected Records</div>
            <div class="stat-value">${selectedCheckboxes.length}</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Total Vert</div>
            <div class="stat-value">${totalVert.toFixed(2)}</div>
            <div class="stat-label">(lbs)</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Total Trans</div>
            <div class="stat-value">${totalTrans.toFixed(2)}</div>
            <div class="stat-label">(lbs)</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Total Long</div>
            <div class="stat-value">${totalLong.toFixed(2)}</div>
            <div class="stat-label">(lbs)</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Resultant</div>
            <div class="stat-value">${finalResultant.toFixed(2)}</div>
            <div class="stat-label">(lbs)</div>
        </div>
    `;
    
    // Update table body
    selectedRecords.forEach(record => {
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${record.setNo}</td>
            <td>${record.recordId}</td>
            <td>${record.vert.toFixed(2)}</td>
            <td>${record.trans.toFixed(2)}</td>
            <td>${record.long.toFixed(2)}</td>
            <td>${record.resultant.toFixed(2)}</td>
        `;
        tableBody.appendChild(row);
    });
    
    // Update table footer with totals
    tableFooter.innerHTML = `
        <tr class="highlight">
            <td colspan="2"><strong>Custom Selection Sum</strong></td>
            <td><strong>${totalVert.toFixed(2)}</strong></td>
            <td><strong>${totalTrans.toFixed(2)}</strong></td>
            <td><strong>${totalLong.toFixed(2)}</strong></td>
            <td><strong>${finalResultant.toFixed(2)}</strong></td>
        </tr>
    `;
    
    // Store current custom selection for buffer calculations
    window.currentCustomSelection = {
        totalVert,
        totalTrans,
        totalLong,
        finalResultant,
        selectedRecords
    };
}

function initializeBufferLogic() {
    // Toggle buffer settings visibility
    const applyBufferCheckbox = document.getElementById('applyBuffer');
    const bufferSettings = document.getElementById('bufferSettings');
    
    if (applyBufferCheckbox && bufferSettings) {
        applyBufferCheckbox.addEventListener('change', function() {
            bufferSettings.style.display = this.checked ? 'block' : 'none';
        });
    }
    
    // Correct rounding function that handles both positive and negative numbers
    function roundToNearest(value, rounding) {
        if (rounding === 0) return value;
        return Math.sign(value) * Math.ceil(Math.abs(value) / rounding) * rounding;
    }
    
    // Handle buffer application
    const applyBufferBtn = document.getElementById('applyBufferBtn');
    if (applyBufferBtn) {
        applyBufferBtn.addEventListener('click', function() {
            applyBufferToCustomSelection();
        });
    }
    
    function applyBufferToCustomSelection() {
        if (!window.currentCustomSelection) {
            alert('Please select some records first.');
            return;
        }
        
        // Get buffer settings
        const applyBuffer = document.getElementById('applyBuffer').checked;
        const vertBuffer = parseFloat(document.getElementById('vertBuffer').value) || 0;
        const transBuffer = parseFloat(document.getElementById('transBuffer').value) || 0;
        const longBuffer = parseFloat(document.getElementById('longBuffer').value) || 0;
        const vertRounding = parseInt(document.getElementById('vertRounding').value) || 0;
        const transRounding = parseInt(document.getElementById('transRounding').value) || 0;
        const longRounding = parseInt(document.getElementById('longRounding').value) || 0;
        
        const originalValues = window.currentCustomSelection;
        
        // Create processed values (initially same as original)
        let processedValues = {...originalValues};
        
        // Apply buffer and rounding only if enabled
        if (applyBuffer) {
            // CORRECTED: Apply buffers with sign consideration
            processedValues.totalVert = applyBufferWithSign(originalValues.totalVert, vertBuffer);
            processedValues.totalTrans = applyBufferWithSign(originalValues.totalTrans, transBuffer);
            processedValues.totalLong = applyBufferWithSign(originalValues.totalLong, longBuffer);
            
            // Apply rounding to sum values using correct rounding function
            if (vertRounding > 0) {
                processedValues.totalVert = roundToNearest(processedValues.totalVert, vertRounding);
            }
            if (transRounding > 0) {
                processedValues.totalTrans = roundToNearest(processedValues.totalTrans, transRounding);
            }
            if (longRounding > 0) {
                processedValues.totalLong = roundToNearest(processedValues.totalLong, longRounding);
            }
            
            // Recalculate resultant after buffer and rounding
            processedValues.finalResultant = Math.sqrt(
                processedValues.totalVert**2 + 
                processedValues.totalTrans**2 + 
                processedValues.totalLong**2
            );
        }
        
        // Display buffered results
        displayBufferedResults(processedValues, originalValues, {
            applyBuffer,
            vertBuffer,
            transBuffer,
            longBuffer,
            vertRounding,
            transRounding,
            longRounding
        });
    }
    
    // NEW: Function to apply buffer based on sign
    function applyBufferWithSign(originalValue, buffer) {
        if (originalValue >= 0) {
            // For positive values: add buffer
            return originalValue + buffer;
        } else {
            // For negative values: subtract buffer
            return originalValue - buffer;
        }
    }
    
    // NEW: Function to get buffer operation symbol for display
    function getBufferSymbol(originalValue) {
        return originalValue >= 0 ? '+' : '-';
    }
    
    function displayBufferedResults(processedValues, originalValues, settings) {
        const tableBody = document.querySelector('#bufferedLoadsTable tbody');
        tableBody.innerHTML = '';
        
        // Add individual record rows
        originalValues.selectedRecords.forEach(record => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${record.setNo}</td>
                <td>${record.vert.toFixed(2)}</td>
                <td>${record.trans.toFixed(2)}</td>
                <td>${record.long.toFixed(2)}</td>
                <td>${record.resultant.toFixed(2)}</td>
            `;
            tableBody.appendChild(row);
        });
        
        // Add original sum row
        const originalSumRow = document.createElement('tr');
        originalSumRow.classList.add('original-sum');
        originalSumRow.innerHTML = `
            <td><strong>Original Sum</strong></td>
            <td><strong>${originalValues.totalVert.toFixed(2)}</strong></td>
            <td><strong>${originalValues.totalTrans.toFixed(2)}</strong></td>
            <td><strong>${originalValues.totalLong.toFixed(2)}</strong></td>
            <td><strong>${originalValues.finalResultant.toFixed(2)}</strong></td>
        `;
        tableBody.appendChild(originalSumRow);
        
        // Add processed sum row (only if buffer was applied)
        if (settings.applyBuffer) {
            const processedSumRow = document.createElement('tr');
            processedSumRow.classList.add('highlight');
            processedSumRow.innerHTML = `
                <td><strong>Processed Sum</strong></td>
                <td><strong>${processedValues.totalVert.toFixed(2)}</strong></td>
                <td><strong>${processedValues.totalTrans.toFixed(2)}</strong></td>
                <td><strong>${processedValues.totalLong.toFixed(2)}</strong></td>
                <td><strong>${processedValues.finalResultant.toFixed(2)}</strong></td>
            `;
            tableBody.appendChild(processedSumRow);
            
            // Add settings info with correct symbols
            const settingsRow = document.createElement('tr');
            settingsRow.classList.add('settings-info');
            settingsRow.innerHTML = `
                <td colspan="5" style="text-align: left; font-style: italic;">
                    Applied settings: 
                    Vert: ${getBufferSymbol(originalValues.totalVert)}${settings.vertBuffer} lbs, Round to ${settings.vertRounding} | 
                    Trans: ${getBufferSymbol(originalValues.totalTrans)}${settings.transBuffer} lbs, Round to ${settings.transRounding} | 
                    Long: ${getBufferSymbol(originalValues.totalLong)}${settings.longBuffer} lbs, Round to ${settings.longRounding}
                </td>
            `;
            tableBody.appendChild(settingsRow);
        }
        
        // Show results section
        document.getElementById('bufferedResults').style.display = 'block';
    }
}

// Keep the existing JavaScript functions (goToLoadConditions, etc.)
function goToLoadConditions() {
    const calculationData = {{ calculation_data_json|safe }};
    
    // Create a form to submit the data
    const form = document.createElement('form');
    form.method = 'POST';
    form.action = "{% url 'load_condition' %}";
    
    // Add CSRF token
    const csrfToken = document.createElement('input');
    csrfToken.type = 'hidden';
    csrfToken.name = 'csrfmiddlewaretoken';
    csrfToken.value = '{{ csrf_token }}';
    form.appendChild(csrfToken);
    
    // Add calculation data
    const dataInput = document.createElement('input');
    dataInput.type = 'hidden';
    dataInput.name = 'calculation_data';
    dataInput.value = JSON.stringify(calculationData);
    form.appendChild(dataInput);
    
    // Submit the form
    document.body.appendChild(form);
    form.submit();
}
</script>"