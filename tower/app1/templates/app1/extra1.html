First, read the complete code of the hdata1 page carefully and act as an experienced developer.

On this page, I create combinations of Set : Phase.

Case 1 (Working correctly):
When I create the combinations and directly click the ‚ÄúGo to Load Cases Selection‚Äù button, all the created combinations are fetched correctly on the next page.

Case 2 (Issue):
When I create the combinations, then drag the created combinations inside the canvas container and perform some actions with the Set : Phase values, and after that click the same ‚ÄúGo to Load Cases Selection‚Äù button, the next page does not receive all the created combinations.

Some combinations are missing, and not all created combinations are fetched correctly on the next page.

Please analyze why this happens and identify where the data is getting lost.

this is views 

"def hdata1(request):
    # DEBUG: Print all session data at the start of hdata1
    if 'selected_structure_type' not in request.session:
        # Try to get it from popup_selections
        popup_selections = request.session.get('popup_selections', {})
        structure_type = popup_selections.get('structure_type')
        if structure_type:
            request.session['selected_structure_type'] = structure_type
            print(f"‚ö†Ô∏è FIXED: Set selected_structure_type from popup_selections: {structure_type}")
            
    debug_session_selections(request.session)
    
    print(f"\nüìä DEBUG [hdata1 Page] - Detailed session data:")
    print(f"  1. Home Page Data:")
    print(f"     Structure Type: {request.session.get('selected_structure_type')}")
    print(f"     Structure ID: {request.session.get('selected_structure_id')}")
    print(f"     Active Popups: {request.session.get('active_popups', [])}")
    print(f"     Popup Selections: {request.session.get('popup_selections', {})}")
    
    print(f"  2. Circuit Definition Data:")
    circuit_definition = request.session.get('circuit_definition', {})
    print(f"     Num 3-Phase Circuits: {circuit_definition.get('num_3_phase_circuits')}")
    print(f"     Num Shield Wires: {circuit_definition.get('num_shield_wires')}")
    print(f"     Num 1-Phase Circuits: {circuit_definition.get('num_1_phase_circuits')}")
    print(f"     Num Communication Cables: {circuit_definition.get('num_communication_cables')}")
    print(f"     Circuit Model: {circuit_definition.get('circuit_model')}")
    print(f"     Circuit ID: {circuit_definition.get('circuit_id')}")
    
    print(f"  3. Selection Values:")
    print(f"     Selected Values: {request.session.get('selected_values', {})}")
    
    # ================== FIX 1: ADD TYPE CHECK FOR selected_values ==================
    # Get selected values from session - ensure it's always a dictionary
    selected_values = request.session.get('selected_values', {})
    
    # FIX: Ensure selected_values is a dictionary, not a list
    if isinstance(selected_values, list):
        print(f"‚ö†Ô∏è WARNING: selected_values is a list with {len(selected_values)} items, converting to dict")
        print(f"   List content: {selected_values}")
        request.session['selected_values'] = {}
        selected_values = {}
    # ===============================================================================
    
    # Find matching model based on all selections
    matching_model = find_matching_model(request.session)
    print(f"\nüîç DEBUG [hdata1] - Matching Results:")
    if matching_model:
        print(f"  ‚úì Found matching model: {matching_model.name}")
        print(f"    ID: {matching_model.id}")
        print(f"    Type: {matching_model.structure_type}")
        print(f"    Attachment: {matching_model.attachment_points}")
        print(f"    Configuration: {matching_model.configuration}")
        print(f"    Circuit: {matching_model.circuit_type}")
    else:
        print(f"  ‚ö† No matching model found")

    available_models = TowerModel.objects.all().order_by('name')
    selected_model_id = request.session.get('selected_model_id')
    
    # AUTO-SELECT matched model if available
    if matching_model:
        selected_model_id = matching_model.id
        request.session['selected_model_id'] = selected_model_id
        request.session['matched_model_id'] = matching_model.id
        print(f"  üéØ AUTO-SELECTING matched model ID: {selected_model_id} ({matching_model.name})")
    elif selected_model_id:
        # Keep existing selection if no match found
        print(f"  üîÑ Keeping existing selection ID: {selected_model_id}")
    
    # Handle POST requests for model selection
    if request.method == 'POST':
        # Handle manual model selection
        if 'selected_model' in request.POST:
            selected_model_id = request.POST.get('selected_model')
            if selected_model_id:
                request.session['selected_model_id'] = selected_model_id
                print(f"  üîÑ User manually selected model ID: {selected_model_id}")
                
                # Clear matched model flag since user made manual choice
                if 'matched_model_id' in request.session:
                    del request.session['matched_model_id']
            else:
                # Clear selection if "None" is selected
                request.session.pop('selected_model_id', None)
                # If user cleared selection, revert to matched model
                if matching_model:
                    selected_model_id = matching_model.id
                    request.session['selected_model_id'] = selected_model_id
                    request.session['matched_model_id'] = matching_model.id
                    print(f"  üîÑ User cleared selection, reverting to matched model")
        
        # Handle new model upload
        if 'tower_model_file' in request.FILES:
            model_name = request.POST.get('model_name', 'Unnamed Model')
            model_file = request.FILES['tower_model_file']
            
            # Validate file type
            if model_file.name.endswith(('.glb', '.gltf')):
                # Get categorization from form
                structure_type = request.POST.get('structure_type')
                attachment_points = request.POST.get('attachment_points')
                configuration = request.POST.get('configuration')
                circuit_type = request.POST.get('circuit_type')
                
                new_model = TowerModel.objects.create(
                    name=model_name,
                    model_file=model_file,
                    structure_type=structure_type,
                    attachment_points=attachment_points,
                    configuration=configuration,
                    circuit_type=circuit_type
                )
                
                # Optionally select the newly uploaded model
                request.session['selected_model_id'] = new_model.id
                selected_model_id = new_model.id
                print(f"  üì§ New model uploaded and selected: {new_model.name} (ID: {new_model.id})")
    
    # Get selected model if any
    selected_model = None
    if selected_model_id:
        try:
            selected_model = TowerModel.objects.get(id=selected_model_id)
            print(f"  üìä Current selected model: {selected_model.name} (ID: {selected_model.id})")
            print(f"    Details: {selected_model.structure_type}/{selected_model.attachment_points}/{selected_model.configuration}/{selected_model.circuit_type}")
        except TowerModel.DoesNotExist:
            print(f"  ‚ùå Selected model ID {selected_model_id} not found")
            selected_model = None
            
    # ENSURE we always have a selected model
    if not selected_model:
        if matching_model:
            selected_model = matching_model
            print(f"  üÜò Fallback to matching model: {selected_model.name}")
        elif available_models.exists():
            selected_model = available_models.first()
            print(f"  ‚ö† No match found, selecting first available: {selected_model.name}")
        else:
            print(f"  ‚ö† No models available in database")
    
    # Store model info in session for frontend
    if selected_model:
        request.session['selected_model_url'] = selected_model.get_file_url()
        request.session['selected_model_name'] = selected_model.name
        request.session['selected_model_details'] = {
            'structure_type': selected_model.structure_type,
            'attachment_points': selected_model.attachment_points,
            'configuration': selected_model.configuration,
            'circuit_type': selected_model.circuit_type
        }
    
    # Get all session data to pass to template - UPDATED with type check
    # Note: selected_values is already defined above with type checking
    active_combinations = selected_values.get('active_combinations', [])
    structure_id = selected_values.get('structure_id')
    button_type = selected_values.get('button_type', '')
    
    # Get circuit definition data from session
    circuit_definition = request.session.get('circuit_definition', {})
    
    # Process structure data if structure_id exists
    joint_labels = []
    set_numbers = []
    phase_numbers = []
    load_data = []
    df_columns = []
    
    if structure_id:
        try:
            structure = ListOfStructure.objects.get(id=structure_id)
            
            # Try to get the latest file from different models
            latest_file = None
            file_models = [
                tUploadedFile6, hUploadedFile1, tUploadedFile1, tUploadedFile2,
                tUploadedFile3, tUploadedFile4, tUploadedFile5, hUploadedFile2,
                hUploadedFile3, hUploadedFile4, tUploadedFile7, tUploadedFile8,
                tUploadedFile9, tUploadedFile10, tUploadedFile11, UploadedFile1,
                UploadedFile22, mUploadedFile5, mUploadedFile6, mUploadedFile7,
                mUploadedFile8, mUploadedFile9, mUploadedFile10, mUploadedFile11
            ]
            
            for model in file_models:
                if model.objects.filter(structure=structure).exists():
                    latest_file = model.objects.filter(structure=structure).latest('uploaded_at')
                    break
            
            if not latest_file:
                raise Exception("No uploaded file found for this structure")
                
            df = pd.read_excel(latest_file.file.path, engine='openpyxl')
            df_columns = list(df.columns)

            # Get selected load cases from session to filter data
            selected_load_cases = selected_values.get('load_cases', [])
            if selected_load_cases and 'Load Case Description' in df.columns:
                df = df[df['Load Case Description'].isin(selected_load_cases)]

            # Prepare complete data for table display
            load_data = []
            for _, row in df.iterrows():
                row_data = {}
                for col in df.columns:
                    if pd.notna(row[col]):
                        if pd.api.types.is_numeric_dtype(df[col]):
                            row_data[col] = float(row[col])
                        else:
                            row_data[col] = str(row[col])
                    else:
                        row_data[col] = '' if pd.api.types.is_string_dtype(df[col]) else 0
                load_data.append(row_data)

            # Get unique values for display
            joint_labels = [str(label) for label in df['Attach. Joint Labels'].unique()] if 'Attach. Joint Labels' in df.columns else []
            set_numbers = [str(num) for num in df['Set No.'].dropna().unique()] if 'Set No.' in df.columns else []
            phase_numbers = [str(num) for num in df['Phase No.'].dropna().unique()] if 'Phase No.' in df.columns else []

        except Exception as e:
            joint_labels = []
            set_numbers = []
            phase_numbers = []
            load_data = []
            df_columns = []
            print(f"Error processing Excel file: {str(e)}")
    
    # ================== FIX 2: ENSURE selected_values IS A DICT ==================
    # Initialize session storage for selections
    if 'selected_values' not in request.session:
        request.session['selected_values'] = {}
    
    # FIX: Ensure selected_values is always a dictionary
    if not isinstance(request.session.get('selected_values'), dict):
        print(f"‚ö†Ô∏è WARNING: selected_values in session is not a dict, resetting")
        request.session['selected_values'] = {}
    # =============================================================================
    
    # Initialize empty arrays if they don't exist
    if 'selected_joints' not in request.session['selected_values']:
        request.session['selected_values']['selected_joints'] = []
    
    if 'active_combinations' not in request.session['selected_values']:
        request.session['selected_values']['active_combinations'] = []
    
    # Get current selections from session
    selected_joints = request.session['selected_values'].get('selected_joints', [])
    active_combinations = request.session['selected_values'].get('active_combinations', [])
    
    # Build filter criteria
    filter_criteria = {}

    # Store joint labels if any are selected
    if selected_joints:
        filter_criteria['joint_labels'] = selected_joints
        # NEW: Also store joint labels in a display-friendly format
        filter_criteria['joint_labels_display'] = selected_joints

    # Store set-phase combinations if any are active - UPDATED to always use dicts
    set_phase_pairs = []
    if active_combinations:
        for combo in active_combinations:
            if isinstance(combo, str):
                # Format: "1-2-Ahead" -> extract set and phase
                parts = combo.split('-')
                if len(parts) >= 2:
                    set_phase_pairs.append({'set': parts[0], 'phase': parts[1]})
            elif isinstance(combo, dict):
                # Handle dictionary format (normalize values to strings)
                set_val = str(combo.get('set', ''))
                phase_val = str(combo.get('phase', ''))
                if set_val and phase_val:
                    set_phase_pairs.append({'set': set_val, 'phase': phase_val})

    if set_phase_pairs:
        filter_criteria['set_phase_combinations'] = set_phase_pairs
    
    # Store filter criteria in session
    request.session['selected_values']['filter_criteria'] = filter_criteria
    request.session.modified = True

    # Calculate total circuits for display
    total_circuits = 0
    if circuit_definition:
        num_3_phase = int(circuit_definition.get('num_3_phase_circuits', 0) or 0)
        num_1_phase = int(circuit_definition.get('num_1_phase_circuits', 0) or 0)
        total_circuits = num_3_phase + num_1_phase

    # Prepare context data including all session information
    context = {
        # Model selection context
        'available_models': available_models,
        'selected_model': selected_model,
        'matching_model': matching_model,
        
        # Structure data context
        'joint_labels': joint_labels,
        'set_numbers': set_numbers,
        'phase_numbers': phase_numbers,
        'load_data': load_data,
        'load_data_json': json.dumps(load_data),
        'all_columns': df_columns,
        
        # Selection context
        'selected_values': selected_values,  # This is now guaranteed to be a dict
        'button_type': button_type,
        'structure_id': structure_id,
        'filter_criteria': filter_criteria,
        'selected_joints': selected_joints,
        'active_combinations': active_combinations,
        
        # Session data from Home Page and Circuit Definition
        'session_structure_type': request.session.get('selected_structure_type', ''),
        'session_structure_id': request.session.get('selected_structure_id', ''),
        'session_active_popups': request.session.get('active_popups', []),
        'session_popup_selections': request.session.get('popup_selections', {}),
        'session_circuit_definition': circuit_definition,
        'session_total_circuits': total_circuits,
        
        # Model matching info
        'matched_model_info': {
            'structure_type': matching_model.structure_type if matching_model else None,
            'attachment_points': matching_model.attachment_points if matching_model else None,
            'configuration': matching_model.configuration if matching_model else None,
            'circuit_type': matching_model.circuit_type if matching_model else None,
        } if matching_model else None,
        
        # Selection comparison for debugging
        'selection_comparison': {
            'user_structure': request.session.get('selected_structure_type'),
            'user_attachment': request.session.get('popup_selections', {}).get('attachment_points'),
            'user_configuration': request.session.get('popup_selections', {}).get('configuration'),
            'model_structure': selected_model.structure_type if selected_model else None,
            'model_attachment': selected_model.attachment_points if selected_model else None,
            'model_configuration': selected_model.configuration if selected_model else None,
            'is_matched': selected_model == matching_model if selected_model and matching_model else False
        } if selected_model else {}
    }
    
    print(f"\n‚úÖ [hdata1] Context prepared:")
    print(f"  Selected Model: {selected_model.name if selected_model else 'None'}")
    print(f"  Matching Model: {matching_model.name if matching_model else 'None'}")
    print(f"  Models Match: {selected_model == matching_model if selected_model and matching_model else False}")
    print(f"  selected_values type: {type(selected_values)}")
    print(f"  selected_values content: {selected_values}")
    
    return render(request, 'app1/hdata1.html', context)

# Add this function to your views.py
def update_selection_session(request):
    if request.headers.get('x-requested-with') == 'XMLHttpRequest':
        if request.method == 'POST':
            selected_joints = request.POST.getlist('selected_joints[]')
            active_combinations_json = request.POST.get('active_combinations', '[]')
            
            try:
                active_combinations = json.loads(active_combinations_json)
            except json.JSONDecodeError:
                active_combinations = []
            
            print(f"DEBUG update_selection_session: Received {len(active_combinations)} raw combinations: {active_combinations}")  # NEW: Log raw input
            
            # Normalize combinations for consistent filtering
            normalized_combinations = []
            for combo in active_combinations:
                normalized_combo = {}
                for key, value in combo.items():
                    if isinstance(value, (int, float)):
                        if value == int(value):
                            normalized_combo[key] = str(int(value))
                        else:
                            normalized_combo[key] = str(value)
                    else:
                        normalized_combo[key] = str(value).strip()
                normalized_combinations.append(normalized_combo)
            
            print(f"DEBUG: Normalized to {len(normalized_combinations)} combinations: {normalized_combinations}")  # NEW: Log normalized output
            
            if 'selected_values' not in request.session:
                request.session['selected_values'] = {}
            
            request.session['selected_values']['selected_joints'] = selected_joints
            request.session['selected_values']['active_combinations'] = normalized_combinations  # Note: This overwrites with dicts
            
            # Build filter criteria
            filter_criteria = {}
            if selected_joints:
                filter_criteria['joint_labels'] = selected_joints
            if normalized_combinations:
                filter_criteria['set_phase_combinations'] = normalized_combinations
            
            request.session['selected_values']['filter_criteria'] = filter_criteria
            request.session.modified = True
            
            print(f"DEBUG: Updated session with {len(normalized_combinations)} combinations. Filter criteria: {filter_criteria}")  # NEW: Log final session update
            
            return JsonResponse({
                'success': True,
                'selected_joints': selected_joints,
                'active_combinations': normalized_combinations,
                'filter_criteria': filter_criteria
            })
    
    return JsonResponse({'success': False, 'error': 'Invalid request'})"


this is hdata1.html 
" <div class="container">
        <h3>OVERHEAD LOAD DESIGN CRITERIA</h3>
        
        <div class="row">
            <!-- Left side - Selection Options (reduced width) -->
            <div class="col-md-4">
                {% if button_type == 'joint_labels' %}
                <!-- Show only joint labels section when joint labels button was clicked -->
                <div class="form-group">
                    <label for="joint-labels">Attachment Joint Labels:</label>
                    <div class="checkbox-list" id="joint-labels">
                        {% for label in joint_labels %}
                            <label draggable="true" class="drag-item" data-type="joint" data-value="{{ label }}">
                                <input type="checkbox" name="joint-labels" value="{{ label }}"> {{ label }}
                            </label>
                        {% endfor %}
                    </div>
                </div>
                {% elif button_type == 'set_phase' %}
                <!-- Show only set/phase sections when set/phase button was clicked -->
                <div class="form-group">
                    <label for="set-select">Set No.:</label>
                    <select id="set-select" class="form-control" multiple size="4">
                        {% for num in set_numbers %}
                            <option value="{{ num|floatformat:0 }}">{{ num|floatformat:0 }}</option>
                        {% endfor %}
                    </select>
                    <small class="form-text text-muted">Hold Ctrl/Cmd to select multiple sets</small>
                </div>

                <div class="form-group">
                    <label for="phase-select">Phase No.:</label>
                    <select id="phase-select" class="form-control" multiple size="4">
                        {% for num in phase_numbers %}
                            <option value="{{ num|floatformat:0 }}">{{ num|floatformat:0 }}</option>
                        {% endfor %}
                    </select>
                    <small class="form-text text-muted">Hold Ctrl/Cmd to select multiple phases</small>
                </div>
                <!-- Combination Builder Section -->
                <div class="form-group">
                    <label>Create Set-Phase Combinations:</label>
                    <div class="combination-builder">
                        <div class="selected-items mb-2">
                            <strong>Selected Sets:</strong> 
                            <span id="selected-sets-display">None</span>
                        </div>
                        <div class="selected-items mb-2">
                            <strong>Selected Phases:</strong> 
                            <span id="selected-phases-display">None</span>
                        </div>
                        <button id="create-all-combinations" class="btn btn-primary btn-sm">
                            Create All Combinations
                        </button>
                        <button id="create-single-combination" class="btn btn-success btn-sm">
                            Create Single Combination
                        </button>
                        <button id="clear-combinations" class="btn btn-secondary btn-sm">
                            Clear All
                        </button>
                    </div>
                </div>

                <!-- Active Combinations Display -->
                <div class="form-group">
                    <label>Active Combinations:</label>
                    <div id="active-combinations" class="active-combinations-list">
                        <!-- Combinations will be displayed here -->
                    </div>
                </div>
                {% endif %}
            </div>
            
            <!-- Right side - 3D Model Viewer (increased width) -->
            <div class="col-md-8">
                <div class="model-viewer-container">
                    <div style="position: absolute; top: 10px; right: 10px; z-index: 100;">
                       
                        
                </div>
                    <canvas id="model-canvas"></canvas>
                    <div id="joint-markers-container"></div>
                    <div id="set-markers-container"></div>
                    <div id="phase-markers-container"></div>
                    <div id="load-displays-container"></div>
                </div>
            </div>
        </div>

        <div class="mb-3">
            <a href="{% url 'load_cases' %}" class="btn btn-outline-primary">
                ‚ö° Go to Load Cases Selection
            </a>
        </div>

        <!-- NEW: Compact Model Selection & Upload Section -->
        <div class="model-controls-container">
            <!-- Model Selection Card -->
            <div class="model-control-card">
                <div class="model-control-header">
                    <h6>Select 3D Tower Model</h6>
                </div>
                <div class="model-control-body">
                <form method="post" class="compact-form">
                    {% csrf_token %}
                    <div class="form-group-compact">
                        <label for="model-select">Model:</label>
                        <select name="selected_model" id="model-select" class="form-control-sm" onchange="this.form.submit()">
                            <option value="">-- Default Model --</option>
                            {% for model in available_models %}
                                <option value="{{ model.id }}" 
                                    {% if selected_model and selected_model.id == model.id %}selected{% endif %}>
                                    {{ model.name }}
                                </option>
                            {% endfor %}
                        </select>
                    </div>
                    <div class="model-status">
                        {% if selected_model %}
                            Currently viewing: <strong>{{ selected_model.name }}</strong>
                            {% if matching_model and selected_model.id == matching_model.id %}
                                <span class="badge badge-success ml-2">Auto-Matched</span>
                            {% else %}
                                <span class="badge badge-info ml-2">Manually Selected</span>
                            {% endif %}
                        {% else %}
                            Using default tower model
                        {% endif %}
                    </div>
                </form>
            </div>

            </div>

            <!-- Model Upload Card -->
            <div class="model-control-card">
    <div class="model-control-header">
        <h6>Upload New 3D Tower Model</h6>
    </div>
    <div class="model-control-body">
        <form method="post" enctype="multipart/form-data" class="compact-form">
            {% csrf_token %}
            <div class="form-row">
                <div class="form-group-compact">
                    <label for="model_name">Model Name:</label>
                    <input type="text" name="model_name" id="model_name" class="form-control-sm" placeholder="Enter model name" required>
                </div>
                <div class="form-group-compact">
                    <label for="tower_model_file">3D Model File:</label>
                    <div class="file-input-wrapper">
                        <input type="file" name="tower_model_file" id="tower_model_file" accept=".glb,.gltf" required>
                        <div class="file-input-display">
                            <span>Choose file...</span>
                            <span class="file-input-icon">üìÅ</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- ADD THESE FIELDS FOR CATEGORIZATION -->
            <div class="form-row">
                <div class="form-group-compact">
                    <label for="structure_type">Structure Type:</label>
                    <select name="structure_type" id="structure_type" class="form-control-sm" required>
                        <option value="">Select...</option>
                        <option value="towers">Towers</option>
                        <option value="hframes">H-Frames</option>
                        <option value="monopoles">Monopoles</option>
                    </select>
                </div>
                <div class="form-group-compact">
                    <label for="attachment_points">Attachment Points:</label>
                    <select name="attachment_points" id="attachment_points" class="form-control-sm" required>
                        <option value="">Select...</option>
                        <option value="deadend">Deadend</option>
                        <option value="tangent">Tangent</option>
                    </select>
                </div>
            </div>
            
            <div class="form-row">
                <div class="form-group-compact">
                    <label for="configuration">Configuration:</label>
                    <select name="configuration" id="configuration" class="form-control-sm" required>
                        <option value="">Select...</option>
                        <option value="vertical">Vertical</option>
                        <option value="horizontal">Horizontal</option>
                        <option value="delta">Delta</option>
                        <option value="hetic">Hetic</option>
                    </select>
                </div>
                <div class="form-group-compact">
                    <label for="circuit_type">Circuit Type:</label>
                    <select name="circuit_type" id="circuit_type" class="form-control-sm" required>
                        <option value="">Select...</option>
                        <option value="sc">Single Circuit</option>
                        <option value="dc">Double Circuit</option>
                        <option value="tc">Triple Circuit</option>
                    </select>
                </div>
            </div>
            
            <div class="form-group-compact">
                <button type="submit" class="btn-sm-compact btn-success-sm">Upload</button>
            </div>
            
            <div class="form-text">
                <small class="text-muted">Supported formats: .glb, .gltf (Max file size: 10MB)</small>
            </div>
        </form>
    </div>
</div>

        </div>
        
        <!-- Load Display Table - now placed below and full width -->
        <div id="load-display">
            <h5>Load Values</h5>
            <div class="btn-container">
                <button id="calculate-btn" class="calculation-btn" disabled>
                    <span>Calculate Selected Records</span>
                </button>
                <span id="selected-count" class="selected-count">0 selected</span>
            </div>

            <div class="table-container">
                <table class="table table-bordered" id="load-table">
                    <thead>
                        <tr>
                            <th>Select</th>
                            {% for column in all_columns %}
                                <th>{{ column }}</th>
                            {% endfor %}
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </div>

    <div class="modal fade" id="aheadBackModal" tabindex="-1" role="dialog" aria-labelledby="aheadBackModalLabel" aria-hidden="true">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="aheadBackModalLabel">Select Combination Direction</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">
                <p>Please select the direction for the following newly created Set-Phase combinations:</p>
                <ul id="new-combinations-list" class="list-group mb-3">
                    <!-- Combinations will be listed here -->
                </ul>
            </div>
            <div class="modal-footer">
                <!-- MODIFIED: Added Both button and updated styling -->
                <button type="button" class="btn btn-success" id="btn-ahead" data-dismiss="modal">Ahead</button>
                <button type="button" class="btn btn-warning" id="btn-back" data-dismiss="modal">Back</button>
            </div>
        </div>
    </div>
</div>
<div class="model-matching-info" style="background-color: #e8f5e8; padding: 15px; margin: 10px 0; border-radius: 5px; border-left: 4px solid #4CAF50;">
    <h5>üéØ 3D Model Matching</h5>
    
    <div class="row">
        <div class="col-md-6">
        <h6>User Selections:</h6>
        <ul>
            <li><strong>Structure Type:</strong> {{ session_structure_type|default:"Not set" }}</li>
            <li><strong>Attachment Points:</strong> {{ session_popup_selections.attachment_points|default:"Not set" }}</li>
            <li><strong>Configuration:</strong> {{ session_popup_selections.configuration|default:"Not set" }}</li>
            <li><strong>3-Phase Circuits:</strong> {{ session_circuit_definition.num_3_phase_circuits|default:"0" }}</li>
            <li><strong>Shield Wires:</strong> {{ session_circuit_definition.num_shield_wires|default:"0" }}</li>
            <li><strong>1-Phase Circuits:</strong> {{ session_circuit_definition.num_1_phase_circuits|default:"0" }}</li>
            <li><strong>Communication Cables:</strong> {{ session_circuit_definition.num_communication_cables|default:"0" }}</li>
            <li><strong>Total Circuits:</strong> 
                {% with num_3_phase=session_circuit_definition.num_3_phase_circuits|default:0|add:0 num_1_phase=session_circuit_definition.num_1_phase_circuits|default:0|add:0 num_comm=session_circuit_definition.num_communication_cables|default:0|add:0 %}
                    {{ num_3_phase|add:num_1_phase|add:num_comm }}
                {% endwith %}
            </li>
        </ul>
    </div>
        
        <div class="col-md-6">
            <h6>Matched 3D Model:</h6>
            {% if matching_model %}
                <div class="alert alert-success">
                    <strong>‚úì Model Found!</strong><br>
                    <strong>Name:</strong> {{ matching_model.name }}<br>
                    <strong>Type:</strong> {{ matching_model.get_structure_type_display }}<br>
                    <strong>Attachment:</strong> {{ matching_model.get_attachment_points_display|default:"-" }}<br>
                    <strong>Configuration:</strong> {{ matching_model.get_configuration_display|default:"-" }}<br>
                    <strong>Circuit:</strong> {{ matching_model.get_circuit_type_display|default:"-" }}
                </div>
            {% else %}
                <div class="alert alert-warning">
                    <strong>‚ö† No Exact Match Found</strong><br>
                    Using default model or manually selected model.
                </div>
            {% endif %}
        </div>
    </div>
</div>
<div class="session-debug" style="background-color: #e8f4f8; padding: 15px; margin: 10px 0; border-radius: 5px; border-left: 4px solid #2196F3;">
    <h5>üìä Session Data Summary</h5>
    
    <div class="row">
        <div class="col-md-6">
            <h6>Home Page Data:</h6>
            <ul>
               
                <li><strong>Active Popups:</strong> 
                    {% if session_active_popups %}
                        {{ session_active_popups|join:", " }}
                    {% else %}
                        None
                    {% endif %}
                </li>
            </ul>
            
            <h6>Popup Selections:</h6>
            <ul>
                {% for key, value in session_popup_selections.items %}
                    <li><strong>{{ key }}:</strong> {{ value }}</li>
                {% empty %}
                    <li>No popup selections</li>
                {% endfor %}
            </ul>
        </div>
        
        <div class="col-md-6">
            <h6>Circuit Definition Data:</h6>
            {% if session_circuit_definition %}
                <ul>
                    <li><strong>3-Phase Circuits:</strong> {{ session_circuit_definition.num_3_phase_circuits|default:"Not set" }}</li>
                    <li><strong>Shield Wires:</strong> {{ session_circuit_definition.num_shield_wires|default:"Not set" }}</li>
                    <li><strong>1-Phase Circuits:</strong> {{ session_circuit_definition.num_1_phase_circuits|default:"Not set" }}</li>
                    <li><strong>Communication Cables:</strong> {{ session_circuit_definition.num_communication_cables|default:"Not set" }}</li>
                  
                </ul>
            {% else %}
                <p>No circuit definition data available</p>
            {% endif %}
        </div>
    </div>
</div>

<!-- Include Three.js library -->
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/TransformControls.js"></script>
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.2/dist/js/bootstrap.bundle.min.js"></script>



<script>
    // Load data passed from Django
    const loadData = JSON.parse('{{ load_data_json|escapejs }}');
    
    // Three.js variables
    let scene, camera, renderer, model, controls, raycaster, mouse;
    const jointMarkers = {};
    const selectedJoints = new Set();
    const loadDisplays = {};
    const setMarkers = {};
    const phaseMarkers = {};
    const selectedSets = new Set();
    const selectedPhases = new Set();
    let activeJoint = null;
    const selectedRecords = new Set();
    let allTableData = [];
    const setPhaseCombinations = new Map(); // Track all active combinations
    let combinationCounter = 0; // Counter to make each combination unique
    const activeCombinations = new Map();
    let currentDroppingItem = null; // Stores data of the label being dragged from the sidebar
    let combinationsToConfirm = []; 
    const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value;
    let gridHelpers = []; // Array to store all grid helpers
    let isGridVisible = true;
    let transformControls;
    let selectedObject = null;
    let modelBoundingBox = null;
    let modelSize = new THREE.Vector3();
    let scaleFactor = 1;
    const BASE_MARKER_SIZE = 0.06; 
    const DRAG_UPDATE_THROTTLE = 16; // ~60fps
    let isSnapModeActive = false;
    let snapModeIndicator = null;
    // NEW: Enhanced movement and drag variables
    let isDragging = false;
    let dragStartPosition = new THREE.Vector3();
    let currentDragObject = null;
    let dragPlane = null;
    let dragOffset = new THREE.Vector3();
    let lastDragUpdate = 0;
    let dragAnimationFrame = null;
    let pendingDragUpdate = null;

    let dropMode = 'precise'; // 'precise' or 'free'
    let gridSnapValue = 0.25;
    let movementStep = 0.25;
    let isDragOverCanvas = false;
    
    document.addEventListener('DOMContentLoaded', function() {
    // Ensure the canvas container is visible and properly sized
    const canvasContainer = document.querySelector('.model-viewer-container');
    const canvas = document.getElementById('model-canvas');
    
    if (canvasContainer && canvas) {
        // Force the container to be visible and properly sized
        canvasContainer.style.display = 'block';
        canvas.style.display = 'block';
        
        // Initialize the model viewer regardless of button type
        initModelViewer();
        updateTable();
        
        // Initialize the appropriate selection based on button type
        {% if button_type == 'set_phase' %}
            initSetPhaseSelection();
        {% elif button_type == 'joint_labels' %}
            // Ensure joint labels functionality is initialized
            initJointLabelsSelection();
        {% endif %}
    }
});

// Add this function if it doesn't exist
function initJointLabelsSelection() {
    const jointContainer = document.getElementById('joint-labels');
    if (jointContainer) {
        jointContainer.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
            checkbox.addEventListener('change', function() {
                const jointValue = this.value;
                if (this.checked) {
                    selectedJoints.add(jointValue);
                    if (!jointMarkers[jointValue]) {
                        addJointMarker(jointValue);
                    }
                } else {
                    selectedJoints.delete(jointValue);
                    removeJointMarker(jointValue);
                }
                updateTable();
                syncSelectionsWithSession();
            });
        });
    }
}

// =============================================================================
// INITIALIZE SNAP SYSTEM
// =============================================================================
function initSnapSystem() {
    const canvas = renderer.domElement;
    
    // Method 1: Shift+Click to snap (PRIMARY - Most reliable)
    canvas.addEventListener('click', handleSnapClick, true); // Use capture phase
    
    // Method 2: Keep triple-click as alternative
    initTripleClickSnap();
    
    // Add snap mode indicator
    createSnapModeIndicator();
    
    // Add keyboard shortcut info
    addSnapInstructions();
    
    console.log('‚úì Snap system initialized');
    console.log('  - Hold SHIFT and click to snap marker to tower part');
    console.log('  - Or triple-click on tower part');
}

// =============================================================================
// PRIMARY METHOD: SHIFT+CLICK SNAP (MOST RELIABLE)
// =============================================================================
function handleSnapClick(e) {
    // Only process if Shift is held and we have a selected object
    if (!e.shiftKey || !selectedObject) {
        return;
    }
    
    e.preventDefault();
    e.stopPropagation();
    e.stopImmediatePropagation();
    
    console.log('üéØ Shift+Click detected - snapping marker');
    
    // Calculate mouse position
    const canvas = renderer.domElement;
    const rect = canvas.getBoundingClientRect();
    const mouseX = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    const mouseY = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    
    // Perform the snap
    performSnapToClick(mouseX, mouseY);
}

// =============================================================================
// ALTERNATIVE METHOD: TRIPLE-CLICK SNAP (BACKUP)
// =============================================================================
let clickHistory = [];
const TRIPLE_CLICK_WINDOW = 600; // ms

function initTripleClickSnap() {
    const canvas = renderer.domElement;
    
    canvas.addEventListener('mousedown', (e) => {
        const now = Date.now();
        
        // Clean old clicks
        clickHistory = clickHistory.filter(time => now - time < TRIPLE_CLICK_WINDOW);
        
        // Add current click
        clickHistory.push(now);
        
        // Check for triple-click
        if (clickHistory.length >= 3) {
            console.log('üéØ Triple-click detected - snapping marker');
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            const mouseY = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            
            performSnapToClick(mouseX, mouseY);
            
            // Clear history
            clickHistory = [];
            
            e.preventDefault();
            e.stopPropagation();
        }
    }, true);
}

// =============================================================================
// CORE SNAP LOGIC - IMPROVED RAYCASTING
// =============================================================================
function performSnapToClick(mouseX, mouseY) {
    if (!selectedObject) {
        showMessage('‚ö† No marker selected', 'warning');
        return;
    }
    
    // Update raycaster
    raycaster.setFromCamera({ x: mouseX, y: mouseY }, camera);
    
    // CRITICAL: Set raycaster params for better precision
    raycaster.params.Line.threshold = 0.1;
    raycaster.params.Points.threshold = 0.1;
    
    // Get intersections - ONLY from the model
    let intersects = [];
    if (model) {
        intersects = raycaster.intersectObject(model, true);
    }
    
    console.log(`Found ${intersects.length} intersections`);
    
    if (intersects.length === 0) {
        showMessage('‚ö† No tower part found - click closer to the structure', 'warning');
        return;
    }
    
    // Find the best intersection
    const bestPoint = findBestSnapPoint(intersects, mouseX, mouseY);
    
    if (bestPoint) {
        // Snap immediately
        snapMarkerImmediately(selectedObject, bestPoint);
        showMessage('‚úì Marker snapped successfully!', 'success');
    } else {
        showMessage('‚ö† Could not find valid snap point', 'warning');
    }
}

// =============================================================================
// IMPROVED INTERSECTION SELECTION
// =============================================================================
function findBestSnapPoint(intersects, mouseX, mouseY) {
    if (intersects.length === 0) return null;
    
    const cameraPos = camera.position.clone();
    const cameraDir = new THREE.Vector3();
    camera.getWorldDirection(cameraDir);
    
    // Score and filter intersections
    const scoredPoints = intersects
        .filter(hit => {
            // Must be a mesh
            if (!hit.object.isMesh) return false;
            
            // Must be visible
            if (!hit.object.visible) return false;
            
            // Must have a point
            if (!hit.point) return false;
            
            // Reasonable distance check
            if (hit.distance > 500) return false;
            
            return true;
        })
        .map(hit => {
            let score = 1000; // Base score
            
            // 1. Closer is better (most important)
            score -= hit.distance;
            
            // 2. Check if surface faces camera
            if (hit.face && hit.face.normal) {
                const normal = hit.face.normal.clone();
                hit.object.updateMatrixWorld(true);
                normal.transformDirection(hit.object.matrixWorld);
                normal.normalize();
                
                // Dot product: positive = facing camera
                const facing = -normal.dot(cameraDir);
                
                if (facing > 0.1) {
                    score += facing * 200; // Strongly prefer front-facing
                } else {
                    score -= 100; // Penalize back-facing
                }
            }
            
            // 3. Prefer objects with geometry
            if (hit.object.geometry && hit.object.geometry.attributes.position) {
                score += 50;
            }
            
            // 4. Prefer named objects (tower parts usually have names)
            if (hit.object.name && hit.object.name.length > 0) {
                score += 30;
            }
            
            return {
                point: hit.point.clone(),
                score: score,
                distance: hit.distance,
                object: hit.object
            };
        })
        .sort((a, b) => b.score - a.score);
    
    if (scoredPoints.length === 0) return null;
    
    const best = scoredPoints[0];
    console.log('Best snap point:', {
        score: best.score.toFixed(2),
        distance: best.distance.toFixed(2),
        position: best.point,
        objectName: best.object.name || 'unnamed'
    });
    
    return best.point;
}

// =============================================================================
// IMMEDIATE SNAP - NO ANIMATION DELAY
// =============================================================================
function snapMarkerImmediately(selectedObj, targetPosition) {
    const marker = selectedObj.object;
    const markerData = selectedObj.type === 'joint' ? 
        jointMarkers[selectedObj.value] : 
        setMarkers[selectedObj.value];
    
    if (!marker || !markerData) {
        console.error('Invalid marker data');
        return;
    }
    
    // Apply grid snapping if enabled
    const finalPosition = targetPosition.clone();
    if (typeof gridSnapValue !== 'undefined' && gridSnapValue > 0) {
        finalPosition.x = Math.round(finalPosition.x / gridSnapValue) * gridSnapValue;
        finalPosition.y = Math.round(finalPosition.y / gridSnapValue) * gridSnapValue;
        finalPosition.z = Math.round(finalPosition.z / gridSnapValue) * gridSnapValue;
    }
    
    console.log('Snapping marker to:', finalPosition);
    
    // IMMEDIATE position update - no animation
    marker.position.copy(finalPosition);
    
    // Update HTML marker position
    updateMarkerPosition(marker, markerData.div);
    
    // Update transform controls if attached
    if (transformControls && transformControls.object === marker) {
        transformControls.update();
    }
    
    // Visual feedback
    showSnapVisualFeedback(marker, markerData.div);
    
    console.log('‚úì Snap complete - marker at:', marker.position);
}

// =============================================================================
// VISUAL FEEDBACK
// =============================================================================
function showSnapVisualFeedback(marker, markerDiv) {
    // 1. Flash the marker
    markerDiv.style.transition = 'all 0.2s ease';
    markerDiv.style.transform = 'translate(-50%, -50%) scale(1.4)';
    markerDiv.style.boxShadow = '0 0 25px rgba(76, 175, 80, 1)';
    markerDiv.style.backgroundColor = '#4CAF50';
    markerDiv.style.color = 'white';
    
    setTimeout(() => {
        markerDiv.style.transform = 'translate(-50%, -50%) scale(1)';
        markerDiv.style.boxShadow = '';
        markerDiv.style.backgroundColor = '';
        markerDiv.style.color = '';
    }, 300);
    
    // 2. Create temporary 3D highlight
    const highlightGeom = new THREE.SphereGeometry(0.2 * (scaleFactor || 1), 16, 16);
    const highlightMat = new THREE.MeshBasicMaterial({
        color: 0x4CAF50,
        transparent: true,
        opacity: 0.7,
        depthTest: false
    });
    
    const highlight = new THREE.Mesh(highlightGeom, highlightMat);
    highlight.position.copy(marker.position);
    scene.add(highlight);
    
    // Animate highlight
    let scale = 1;
    const interval = setInterval(() => {
        scale += 0.15;
        highlight.scale.setScalar(scale);
        highlight.material.opacity = Math.max(0, 0.7 - (scale - 1) * 0.35);
        
        if (scale >= 3) {
            clearInterval(interval);
            scene.remove(highlight);
            highlightGeom.dispose();
            highlightMat.dispose();
        }
    }, 30);
}

// =============================================================================
// SNAP MODE INDICATOR
// =============================================================================
function createSnapModeIndicator() {
    snapModeIndicator = document.createElement('div');
    snapModeIndicator.id = 'snap-mode-indicator';
    snapModeIndicator.style.cssText = `
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(76, 175, 80, 0.95);
        color: white;
        padding: 10px 20px;
        border-radius: 6px;
        font-weight: bold;
        font-size: 14px;
        z-index: 1000;
        display: none;
        box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        pointer-events: none;
    `;
    snapModeIndicator.innerHTML = 'üéØ SNAP MODE: Click on tower part to snap selected marker';
    document.body.appendChild(snapModeIndicator);
    
    // Show/hide based on shift key
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Shift' && selectedObject) {
            snapModeIndicator.style.display = 'block';
        }
    });
    
    document.addEventListener('keyup', (e) => {
        if (e.key === 'Shift') {
            snapModeIndicator.style.display = 'none';
        }
    });
}

// =============================================================================
// INSTRUCTION PANEL
// =============================================================================
function addSnapInstructions() {
    const container = document.querySelector('.model-viewer-container');
    if (!container) return;
    
    const instructions = document.createElement('div');
    instructions.style.cssText = `
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 12px 16px;
        border-radius: 6px;
        font-size: 12px;
        z-index: 100;
        max-width: 280px;
        line-height: 1.6;
    `;
    
    instructions.innerHTML = `
        <strong>üìç Snap Controls:</strong><br>
        ‚Ä¢ Hold <kbd style="background:#333;padding:2px 6px;border-radius:3px;">SHIFT</kbd> + Click = Snap marker<br>
        ‚Ä¢ Triple-click = Also snaps<br>
        ‚Ä¢ Select marker first, then snap
    `;
    
    container.appendChild(instructions);
    
    // Auto-hide after 10 seconds
    setTimeout(() => {
        instructions.style.transition = 'opacity 0.5s';
        instructions.style.opacity = '0';
        setTimeout(() => instructions.remove(), 500);
    }, 10000);
}

// =============================================================================
// MESSAGE SYSTEM
// =============================================================================
function showMessage(text, type = 'info') {
    const messageDiv = document.createElement('div');
    
    const colors = {
        success: { bg: '#4CAF50', border: '#45a049' },
        warning: { bg: '#ff9800', border: '#f57c00' },
        error: { bg: '#f44336', border: '#d32f2f' },
        info: { bg: '#2196F3', border: '#1976D2' }
    };
    
    const color = colors[type] || colors.info;
    
    messageDiv.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${color.bg};
        color: white;
        padding: 12px 20px;
        border-left: 4px solid ${color.border};
        border-radius: 4px;
        font-weight: bold;
        font-size: 14px;
        z-index: 10000;
        box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        max-width: 300px;
        animation: slideIn 0.3s ease-out;
    `;
    
    messageDiv.textContent = text;
    document.body.appendChild(messageDiv);
    
    setTimeout(() => {
        messageDiv.style.transition = 'all 0.3s ease-out';
        messageDiv.style.transform = 'translateX(400px)';
        messageDiv.style.opacity = '0';
        setTimeout(() => document.body.removeChild(messageDiv), 300);
    }, 3000);
}

// =============================================================================
// CSS ANIMATIONS
// =============================================================================
const snapSystemStyles = `
    @keyframes slideIn {
        from {
            transform: translateX(400px);
            opacity: 0;
        }
        to {
            transform: translateX(0);
            opacity: 1;
        }
    }
    
    kbd {
        display: inline-block;
        padding: 3px 7px;
        font-family: monospace;
        font-size: 11px;
        background: #333;
        border: 1px solid #555;
        border-radius: 3px;
        box-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }
`;

// Add styles to document
if (!document.getElementById('snap-system-styles')) {
    const styleEl = document.createElement('style');
    styleEl.id = 'snap-system-styles';
    styleEl.textContent = snapSystemStyles;
    document.head.appendChild(styleEl);
}




function showSnapErrorFeedback() {
    const messageDiv = document.createElement('div');
    messageDiv.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(244, 67, 54, 0.95);
        color: white;
        padding: 15px 25px;
        border-radius: 8px;
        font-weight: bold;
        z-index: 10000;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    `;
    messageDiv.textContent = '‚ö† No valid snap point found - try clicking a tower part';
    document.body.appendChild(messageDiv);
    
    setTimeout(() => {
        messageDiv.style.opacity = '0';
        messageDiv.style.transition = 'opacity 0.3s';
        setTimeout(() => document.body.removeChild(messageDiv), 300);
    }, 2000);
}


function findOptimalSnapPosition(mouseX, mouseY) {
    // Update raycaster with mouse position
    mouse.x = mouseX;
    mouse.y = mouseY;
    raycaster.setFromCamera(mouse, camera);
    
    // Get ALL intersections with the model
    const intersects = raycaster.intersectObject(model, true);
    
    if (intersects.length === 0) {
        console.log('No direct intersections - finding nearest point');
        return findNearestModelPoint();
    }
    
    // CRITICAL FIX: Filter and rank intersections properly
    const validIntersects = filterValidIntersections(intersects);
    
    if (validIntersects.length === 0) {
        console.log('No valid intersections after filtering');
        return findNearestModelPoint();
    }
    
    // Return the best intersection point
    const bestIntersect = validIntersects[0];
    console.log('Found optimal intersection:', {
        distance: bestIntersect.distance.toFixed(2),
        point: bestIntersect.point,
        objectName: bestIntersect.object.name
    });
    
    return bestIntersect.point.clone();
}


function findNearestModelPoint() {
    if (!model || !selectedObject) return null;
    
    const currentPosition = selectedObject.object.position;
    let nearestPoint = null;
    let minDistance = Infinity;
    
    // Traverse all meshes in the model
    model.traverse((child) => {
        if (!child.isMesh || !child.geometry) return;
        
        // Get world bounding box
        const bbox = new THREE.Box3().setFromObject(child);
        
        // Find closest point on this bounding box to current position
        const closestPoint = new THREE.Vector3();
        bbox.clampPoint(currentPosition, closestPoint);
        
        const distance = currentPosition.distanceTo(closestPoint);
        
        if (distance < minDistance) {
            minDistance = distance;
            nearestPoint = closestPoint.clone();
        }
        
        // Also check the center of the bounding box
        const center = bbox.getCenter(new THREE.Vector3());
        const centerDistance = currentPosition.distanceTo(center);
        
        if (centerDistance < minDistance) {
            minDistance = centerDistance;
            nearestPoint = center.clone();
        }
    });
    
    console.log('Nearest point found:', {
        distance: minDistance.toFixed(2),
        point: nearestPoint
    });
    
    return nearestPoint;
}


function filterValidIntersections(intersects) {
    const cameraDirection = new THREE.Vector3();
    camera.getWorldDirection(cameraDirection);
    
    // Filter and score each intersection
    const scoredIntersects = intersects
        .filter(intersect => {
            // Must be visible
            if (!intersect.object.visible) return false;
            
            // Must have a valid point
            if (!intersect.point) return false;
            
            // Must be within reasonable distance
            if (intersect.distance > 1000) return false;
            
            return true;
        })
        .map(intersect => {
            let score = 0;
            
            // 1. Prefer closer intersections (primary factor)
            score += (1000 - intersect.distance) / 10;
            
            // 2. Prefer surfaces facing the camera
            if (intersect.face && intersect.face.normal) {
                const worldNormal = intersect.face.normal.clone();
                intersect.object.localToWorld(worldNormal);
                worldNormal.normalize();
                
                // Dot product: 1 = facing camera, -1 = facing away
                const facingScore = -worldNormal.dot(cameraDirection);
                if (facingScore > 0) {
                    score += facingScore * 100;
                } else {
                    score -= 50; // Penalize back-facing surfaces
                }
            }
            
            // 3. Prefer meshes (not helpers or other objects)
            if (intersect.object.isMesh) {
                score += 50;
            }
            
            // 4. Prefer named objects (typically structural parts)
            if (intersect.object.name && intersect.object.name !== '') {
                score += 30;
            }
            
            return { ...intersect, score };
        })
        .sort((a, b) => b.score - a.score); // Sort by score descending
    
    return scoredIntersects;
}


    // Initialize the 3D model viewer
        // Initialize the 3D model viewer
    function initModelViewer() {
        // Existing scene setup code remains the same until after renderer creation...
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);

        const axesHelper = new THREE.AxesHelper(5);
        scene.add(axesHelper);

        const canvasContainer = document.querySelector('.model-viewer-container');
        camera = new THREE.PerspectiveCamera(75, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 1000);
        camera.position.set(5, 5, 5);

        const canvas = document.getElementById('model-canvas');
        renderer = new THREE.WebGLRenderer({
            canvas,
            antialias: true,
            alpha: true
        });

        updateRendererSize();
        initTransformControls();
        initSnapSystem();
        
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight2.position.set(-1, -1, -1);
        scene.add(directionalLight2);

        // Load GLB model
        const loader = new THREE.GLTFLoader();

    function loadTowerModel(modelUrl) {
    // Remove existing model if any
    if (model) {
        scene.remove(model);
        model = null;
    }
    
    loader.load(
        modelUrl,
        function (gltf) {
            model = gltf.scene;
            scene.add(model);
            console.log('‚úÖ Model loaded successfully:', modelUrl);
            
            // Calculate model bounding box and size
            const box = new THREE.Box3().setFromObject(model);
            modelBoundingBox = box;
            modelSize = box.getSize(new THREE.Vector3());
            
            // Calculate scale factor based on model size
            // Use the largest dimension to determine scale
            const maxDimension = Math.max(modelSize.x, modelSize.y, modelSize.z);
            scaleFactor = Math.max(0.5, Math.min(3, maxDimension / 10)); // Normalize scale
            
            

            console.log('Model size:', modelSize);
            console.log('Scale factor:', scaleFactor);
            
            const center = box.getCenter(new THREE.Vector3());
            model.position.sub(center);
            
            create3DGridCage(box);
            model.rotation.y = Math.PI / 4;
            
            // Rescale existing markers if any
            rescaleAllMarkers();
            
            // Initialize event listeners
            initEnhancedEventListeners();
            animate();
        },
        undefined,
        function (error) {
            console.error('‚ùå Error loading model:', error);
            console.log('Trying to load fallback model...');
            
            // Try to load any available model as fallback
            {% if available_models and available_models.0 %}
                const fallbackUrl = "{{ available_models.0.get_file_url }}";
                console.log('Loading fallback model:', fallbackUrl);
                loadTowerModel(fallbackUrl);
            {% else %}
                // Ultimate fallback
                const defaultModelUrl = "{% static 'app1/images/powerTransmissionTower.glb' %}";
                console.log('Loading ultimate fallback model:', defaultModelUrl);
                loadTowerModel(defaultModelUrl);
            {% endif %}
        }
    );
}

{% if matching_model %}
    // Get URLs for both matched and selected models
    const matchedModelUrl = "{{ matching_model.get_file_url }}";
    const selectedModelUrl = "{{ selected_model.get_file_url|default:'' }}";
    
    console.log('üîç Model Loading Analysis:');
    console.log('  Matched Model:', "{{ matching_model.name }}", matchedModelUrl);
    console.log('  Selected Model:', "{{ selected_model.name|default:'None' }}", selectedModelUrl);
    
    // Verify they're the same
    if (selectedModelUrl && matchedModelUrl === selectedModelUrl) {
        console.log('‚úÖ Matched and selected models are the same');
        console.log('üéØ Auto-loading matched model:', matchedModelUrl);
        console.log('Model details:', {
            name: "{{ matching_model.name }}",
            type: "{{ matching_model.structure_type }}",
            attachment: "{{ matching_model.attachment_points }}",
            config: "{{ matching_model.configuration }}",
            circuit: "{{ matching_model.circuit_type }}"
        });
        loadTowerModel(matchedModelUrl);
    } else if (selectedModelUrl && selectedModelUrl !== matchedModelUrl) {
        console.log('‚ö†Ô∏è Matched and selected models differ!');
        console.log('Loading selected model (user choice overrides match):', selectedModelUrl);
        loadTowerModel(selectedModelUrl);
    } else {
        // No selected model, use matched model
        console.log('üéØ Auto-loading matched model:', matchedModelUrl);
        console.log('Model details:', {
            name: "{{ matching_model.name }}",
            type: "{{ matching_model.structure_type }}",
            attachment: "{{ matching_model.attachment_points }}",
            config: "{{ matching_model.configuration }}",
            circuit: "{{ matching_model.circuit_type }}"
        });
        loadTowerModel(matchedModelUrl);
    }
{% else %}
    // No matching model found, use selected or default
    {% if selected_model %}
        const selectedModelUrl = "{{ selected_model.get_file_url }}";
        console.log('üìå Loading manually selected model:', selectedModelUrl);
        loadTowerModel(selectedModelUrl);
    {% else %}
        const defaultModelUrl = "{% static 'app1/images/powerTransmissionTower.glb' %}";
        console.log('‚öô Loading default model:', defaultModelUrl);
        loadTowerModel(defaultModelUrl);
    {% endif %}
{% endif %}

// Function to rescale all existing markers based on current model size
function rescaleAllMarkers() {
    if (!modelBoundingBox) return;
    
    // Rescale joint markers
    Object.keys(jointMarkers).forEach(label => {
        const marker = jointMarkers[label];
        if (marker.mesh) {
            // Update sphere geometry with scaled size
            const newGeometry = new THREE.SphereGeometry(BASE_MARKER_SIZE * scaleFactor, 16, 16);
            marker.mesh.geometry.dispose();
            marker.mesh.geometry = newGeometry;
            
            // Update HTML font size
            const baseFontSize = 12;
            marker.div.style.fontSize = `${baseFontSize * scaleFactor}px`;
            marker.originalScale = scaleFactor;
        }
    });
    
    // Rescale set-phase markers
    Object.keys(setMarkers).forEach(id => {
        const marker = setMarkers[id];
        if (marker.mesh) {
            // Update sphere geometry with scaled size
            const newGeometry = new THREE.SphereGeometry(BASE_MARKER_SIZE * scaleFactor, 16, 16);
            marker.mesh.geometry.dispose();
            marker.mesh.geometry = newGeometry;
            
            // Update HTML font size
            const baseFontSize = 12;
            marker.div.style.fontSize = `${baseFontSize * scaleFactor}px`;
            marker.originalScale = scaleFactor;
        }
    });
}

// Function to load default model
function loadDefaultModel() {
    loader.load(
       modelUrl,
        function (gltf) {
            model = gltf.scene;
            scene.add(model);

            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            model.position.sub(center);

            create3DGridCage(box);
            model.rotation.y = Math.PI / 4;

            initEnhancedEventListeners();
            animate();
        },
        undefined,
        function (error) {
            console.error('Error loading default model:', error);
        }
    );
}


        window.addEventListener('resize', onWindowResize);
        renderer.domElement.addEventListener('click', onCanvasClick);
        
        // NEW: Add enhanced mouse event listeners for smooth dragging
        initEnhancedDragListeners();
    }

    function initEnhancedEventListeners() {
        // Drop mode selection
        const dropModeSelect = document.getElementById('drop-mode');
        if (dropModeSelect) {
            dropModeSelect.addEventListener('change', function(e) {
                dropMode = e.target.value;
            });
        }

        // Grid snapping
        const gridSnapSelect = document.getElementById('grid-snap');
        if (gridSnapSelect) {
            gridSnapSelect.addEventListener('change', function(e) {
                gridSnapValue = parseFloat(e.target.value);
            });
        }

        // Step size control
        const stepSizeInput = document.getElementById('step-size');
        const stepSizeValue = document.getElementById('step-size-value');
        if (stepSizeInput && stepSizeValue) {
            stepSizeInput.addEventListener('input', function(e) {
                movementStep = parseFloat(e.target.value);
                stepSizeValue.textContent = movementStep.toFixed(2) + ' units';
            });
        }

        // Movement buttons
        document.querySelectorAll('.movement-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                if (selectedObject) {
                    const axis = this.dataset.axis;
                    const direction = parseInt(this.dataset.direction);
                    moveSelectedObject(axis, direction * movementStep);
                }
            });
        });

        // Keyboard arrow key support
        document.addEventListener('keydown', function(event) {
            if (!selectedObject) return;
            
            const step = movementStep;
            switch(event.key) {
                case 'ArrowUp':
                    event.preventDefault();
                    moveSelectedObject('y', step);
                    break;
                case 'ArrowDown':
                    event.preventDefault();
                    moveSelectedObject('y', -step);
                    break;
                case 'ArrowLeft':
                    event.preventDefault();
                    moveSelectedObject('x', -step);
                    break;
                case 'ArrowRight':
                    event.preventDefault();
                    moveSelectedObject('x', step);
                    break;
                case 'PageUp':
                    event.preventDefault();
                    moveSelectedObject('z', step);
                    break;
                case 'PageDown':
                    event.preventDefault();
                    moveSelectedObject('z', -step);
                    break;
            }
        });
    }

    // NEW: Enhanced drag listeners for smooth dragging
    function initEnhancedDragListeners() {
        const canvas = renderer.domElement;
        
        // Remove old event listeners to prevent conflicts
        canvas.removeEventListener('dragover', handleDragOver);
        canvas.removeEventListener('drop', handleCanvasDrop);
        
        // Canvas drag-over for visual feedback
        canvas.addEventListener('dragover', handleDragOver);
        canvas.addEventListener('dragleave', handleDragLeave);
        canvas.addEventListener('drop', handleCanvasDrop);
        
        // Prevent default drag behavior
        canvas.addEventListener('dragenter', (e) => e.preventDefault());
    }

    function handleDragOver(e) {
        e.preventDefault();
        isDragOverCanvas = true;
        renderer.domElement.classList.add('drag-over');
    }

    function handleDragLeave(e) {
        isDragOverCanvas = false;
        renderer.domElement.classList.remove('drag-over');
    }

    // NEW: Start dragging marker
    function startMarkerDrag(e) {
        const marker = e.target;
        const jointLabel = marker.dataset.jointLabel;
        const combinedId = marker.dataset.combinedId;
        
        // Find the corresponding 3D object
        if (jointLabel && jointMarkers[jointLabel]) {
            currentDragObject = jointMarkers[jointLabel].mesh;
        } else if (combinedId && setMarkers[combinedId]) {
            currentDragObject = setMarkers[combinedId].mesh;
        }
        
        if (!currentDragObject) return;
        
        isDragging = true;
        marker.classList.add('dragging');
        renderer.domElement.style.cursor = 'grabbing';
        
        // Calculate the drag plane perpendicular to camera view
        const cameraDirection = new THREE.Vector3();
        camera.getWorldDirection(cameraDirection);
        dragPlane = new THREE.Plane().setFromNormalAndCoplanarPoint(
            cameraDirection.normalize(),
            currentDragObject.position
        );
        
        // Calculate initial offset between mouse and object
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        
        raycaster.setFromCamera(mouse, camera);
        const intersectionPoint = new THREE.Vector3();
        raycaster.ray.intersectPlane(dragPlane, intersectionPoint);
        
        if (intersectionPoint) {
            dragOffset.subVectors(currentDragObject.position, intersectionPoint);
        }
        
        // Attach event listeners
        document.addEventListener('mousemove', onMarkerDragThrottled);
        document.addEventListener('mouseup', stopMarkerDrag);
        
        // Disable orbit controls during drag
        if (controls) controls.enabled = false;
    }

    function onMarkerDragThrottled(e) {
        if (!isDragging || !currentDragObject) return;
        
        const now = performance.now();
        if (now - lastDragUpdate < DRAG_UPDATE_THROTTLE) {
            // Store pending update
            pendingDragUpdate = e;
            if (!dragAnimationFrame) {
                dragAnimationFrame = requestAnimationFrame(processPendingDragUpdate);
            }
            return;
        }
        
        processDragUpdate(e);
        lastDragUpdate = now;
    }

    function processPendingDragUpdate() {
        if (pendingDragUpdate) {
            processDragUpdate(pendingDragUpdate);
            pendingDragUpdate = null;
            lastDragUpdate = performance.now();
        }
        dragAnimationFrame = null;
    }

    function processDragUpdate(e) {
        if (!currentDragObject || !dragPlane) return;
        
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        
        raycaster.setFromCamera(mouse, camera);
        const intersectionPoint = new THREE.Vector3();
        
        if (raycaster.ray.intersectPlane(dragPlane, intersectionPoint)) {
            // Apply offset for smooth dragging
            intersectionPoint.add(dragOffset);
            
            // Apply grid snapping if enabled (only on final position)
            if (gridSnapValue > 0) {
                intersectionPoint.x = Math.round(intersectionPoint.x / gridSnapValue) * gridSnapValue;
                intersectionPoint.y = Math.round(intersectionPoint.y / gridSnapValue) * gridSnapValue;
                intersectionPoint.z = Math.round(intersectionPoint.z / gridSnapValue) * gridSnapValue;
            }
            
            // Smoothly update position
            currentDragObject.position.copy(intersectionPoint);
        }
    }

    // NEW: Handle marker dragging
    function onMarkerDrag(e) {
        if (!isDragging || !currentDragObject) return;
        
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        
        raycaster.setFromCamera(mouse, camera);
        
        // Create a plane at the object's current height for smooth dragging
        const dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -currentDragObject.position.y);
        const intersectionPoint = new THREE.Vector3();
        raycaster.ray.intersectPlane(dragPlane, intersectionPoint);
        
        if (intersectionPoint) {
            // Apply grid snapping if enabled
            if (gridSnapValue > 0) {
                intersectionPoint.x = Math.round(intersectionPoint.x / gridSnapValue) * gridSnapValue;
                intersectionPoint.y = Math.round(intersectionPoint.y / gridSnapValue) * gridSnapValue;
                intersectionPoint.z = Math.round(intersectionPoint.z / gridSnapValue) * gridSnapValue;
            }
            
            currentDragObject.position.copy(intersectionPoint);
        }
    }

    // NEW: Stop marker dragging
    function stopMarkerDrag() {
        isDragging = false;
        
        // Clean up
        if (dragAnimationFrame) {
            cancelAnimationFrame(dragAnimationFrame);
            dragAnimationFrame = null;
        }
        pendingDragUpdate = null;
        
        document.querySelectorAll('.value-marker').forEach(marker => {
            marker.classList.remove('dragging');
        });
        
        renderer.domElement.style.cursor = 'grab';
        
        // Re-enable orbit controls
        if (controls) controls.enabled = true;
        
        // Clean up event listeners
        document.removeEventListener('mousemove', onMarkerDragThrottled);
        document.removeEventListener('mouseup', stopMarkerDrag);
        
        // Clear drag state
        currentDragObject = null;
        dragPlane = null;
        dragOffset.set(0, 0, 0);
    }

    // NEW: Move selected object with arrow controls
    function moveSelectedObject(axis, distance) {
        if (!selectedObject) return;
        
        const newPosition = selectedObject.object.position.clone();
        
        switch(axis) {
            case 'x':
                newPosition.x += distance;
                break;
            case 'y':
                newPosition.y += distance;
                break;
            case 'z':
                newPosition.z += distance;
                break;
        }
        
        // Apply grid snapping
        if (gridSnapValue > 0) {
            newPosition.x = Math.round(newPosition.x / gridSnapValue) * gridSnapValue;
            newPosition.y = Math.round(newPosition.y / gridSnapValue) * gridSnapValue;
            newPosition.z = Math.round(newPosition.z / gridSnapValue) * gridSnapValue;
        }
        
        selectedObject.object.position.copy(newPosition);
        
        // Update associated HTML elements
        updateObjectUI(selectedObject);
    }

    // NEW: Update UI when object moves
    function updateObjectUI(selectedObj) {
        const object = selectedObj.object;
        const value = selectedObj.value;
        const type = selectedObj.type;
        
        if (type === 'joint' && jointMarkers[value]) {
            updateMarkerPosition(object, jointMarkers[value].div);
            if (loadDisplays[value]) {
                updateLoadDisplayPosition(loadDisplays[value].div, object.position);
            }
        } else if (type === 'set-phase' && setMarkers[value]) {
            updateMarkerPosition(object, setMarkers[value].div);
        }
        
        updateSelectedInfo(selectedObj);
    }

    // NEW: Update selected object info panel
    function updateSelectedInfo(selectedObj) {
        const infoDiv = document.getElementById('selected-info');
        if (!infoDiv) return;
        
        const pos = selectedObj.object.position;
        infoDiv.innerHTML = `
            <strong>Selected:</strong> ${selectedObj.value}<br>
            <strong>Position:</strong><br>
            X: ${pos.x.toFixed(2)}<br>
            Y: ${pos.y.toFixed(2)}<br>
            Z: ${pos.z.toFixed(2)}
        `;
    }

    // NEW: Enhanced canvas drop handler
    function handleCanvasDrop(e) {
    e.preventDefault();
        isDragOverCanvas = false;
        renderer.domElement.classList.remove('drag-over');
        
        let droppedData;
        try {
            droppedData = JSON.parse(e.dataTransfer.getData('text/plain'));
        } catch (error) {
            console.error('Error parsing dropped data:', error);
            return;
        }
        
        if (!droppedData) return;
        
        const itemType = droppedData.type;
        const itemValue = droppedData.value;
        
        // Calculate 3D position from drop location
        const rect = renderer.domElement.getBoundingClientRect();
        const mouseX = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        const mouseY = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        
        const position = getDropPosition(mouseX, mouseY);
        
        if (position) {
            placeItemAtPosition(itemType, itemValue, position);
            checkAndSelectSource(itemType, itemValue);
        }
        
        currentDroppingItem = null;
    }

    function getDropPosition(mouseX, mouseY) {
        mouse.x = mouseX;
        mouse.y = mouseY;
        
        raycaster.setFromCamera(mouse, camera);
        
        // Try to intersect with model first
        const modelIntersects = raycaster.intersectObject(model, true);
        if (modelIntersects.length > 0) {
            return modelIntersects[0].point;
        }
        
        // Fall back to a plane at the model center
        const cameraDirection = new THREE.Vector3();
        camera.getWorldDirection(cameraDirection);
        
        const center = modelBoundingBox ? 
            modelBoundingBox.getCenter(new THREE.Vector3()) : 
            new THREE.Vector3(0, 0, 0);
        
        const dropPlane = new THREE.Plane().setFromNormalAndCoplanarPoint(
            cameraDirection.normalize(),
            center
        );
        
        const intersectionPoint = new THREE.Vector3();
        if (raycaster.ray.intersectPlane(dropPlane, intersectionPoint)) {
            return intersectionPoint;
        }
        
        return null;
    }

    function makeMarkerDraggable(markerDiv) {
        markerDiv.style.cursor = 'grab';
        markerDiv.addEventListener('mousedown', startMarkerDrag);
        
        // Prevent text selection during drag
        markerDiv.addEventListener('selectstart', (e) => e.preventDefault());
    }

    function addJointMarkerEnhanced(jointLabel, position = null) {
        if (jointMarkers[jointLabel]) return;

        const markerSize = BASE_MARKER_SIZE * (scaleFactor || 1);
        const geometry = new THREE.SphereGeometry(markerSize, 16, 16);
        const material = new THREE.MeshBasicMaterial({ 
            color: 0xff0000,
            transparent: true,
            opacity: 0.7
        });
        const sphere = new THREE.Mesh(geometry, material);

        if (position) {
            sphere.position.copy(position);
        } else {
            const markerCount = Object.keys(jointMarkers).length;
            const gridSize = Math.ceil(Math.sqrt(markerCount + 1));
            const row = Math.floor(markerCount / gridSize);
            const col = markerCount % gridSize;

            sphere.position.set(
                (col - gridSize / 2) * 0.8,
                2 + row * 0.4,
                (row - gridSize / 2) * 0.4
            );
        }

        const markerDiv = document.createElement('div');
        markerDiv.className = 'value-marker joint-marker';
        markerDiv.textContent = jointLabel;
        markerDiv.style.position = 'absolute';
        markerDiv.style.color = 'black';
        markerDiv.style.padding = '2px 5px';
        markerDiv.style.fontWeight = 'bold';
        markerDiv.style.pointerEvents = 'auto';
        markerDiv.dataset.jointLabel = jointLabel;
        
        // Make draggable
        makeMarkerDraggable(markerDiv);
        
        document.getElementById('joint-markers-container').appendChild(markerDiv);

        jointMarkers[jointLabel] = {
            mesh: sphere,
            div: markerDiv,
            originalScale: scaleFactor || 1,
            fontSize: 12 * (scaleFactor || 1)
        };

        scene.add(sphere);
        updateMarkerPosition(sphere, markerDiv);
    }

    // Similarly update addSetPhaseMarker
    function addSetPhaseMarkerEnhanced(setNumber, phaseNumber, position = null) {
        const combination = Array.from(activeCombinations.values()).find(comb => 
            comb.set === setNumber && comb.phase === phaseNumber
        );
        
        if (!combination) return null;

        const uniqueId = `${combination.id}_${Date.now()}`;
        
        const markerSize = BASE_MARKER_SIZE * (scaleFactor || 1);
        const geometry = new THREE.SphereGeometry(markerSize, 16, 16);
        const material = new THREE.MeshBasicMaterial({ 
            color: 0x0000ff,
            transparent: true,
            opacity: 0.7
        });
        const sphere = new THREE.Mesh(geometry, material);

        if (position) {
            sphere.position.copy(position);
        } else {
            const markerCount = Object.keys(setMarkers).length;
            const gridSize = Math.ceil(Math.sqrt(markerCount + 1));
            const row = Math.floor(markerCount / gridSize);
            const col = markerCount % gridSize;

            sphere.position.set(
                (col - gridSize / 2) * 0.8,
                2 + row * 0.4,
                (row - gridSize / 2) * 0.4
            );
        }

        const markerDiv = document.createElement('div');
        markerDiv.className = 'value-marker set-phase-marker';
        markerDiv.textContent = `${setNumber}:${phaseNumber}`;
        markerDiv.style.position = 'absolute';
        markerDiv.style.color = 'black';
        markerDiv.style.padding = '2px 5px';
        markerDiv.style.fontWeight = 'bold';
        markerDiv.style.pointerEvents = 'auto';
        markerDiv.dataset.combinedId = uniqueId;
        markerDiv.dataset.baseCombination = `${setNumber}:${phaseNumber}`;
        
        // Make draggable
        makeMarkerDraggable(markerDiv);
        
        document.getElementById('set-markers-container').appendChild(markerDiv);

        setMarkers[uniqueId] = {
            mesh: sphere,
            div: markerDiv,
            setNumber: setNumber,
            phaseNumber: phaseNumber,
            baseCombination: `${setNumber}:${phaseNumber}`,
            uniqueId: uniqueId,
            combinationId: combination.id,
            originalScale: scaleFactor || 1,
            fontSize: 12 * (scaleFactor || 1)
        };

        scene.add(sphere);
        updateMarkerPosition(sphere, markerDiv);
        
        return uniqueId;
    }

    const smoothDragStyles = `
        .value-marker {
            transition: transform 0.1s ease-out;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .value-marker:hover {
            transform: scale(1.15);
            z-index: 1000;
        }
        
        .value-marker.dragging {
            transform: scale(1.2);
            opacity: 0.8;
            cursor: grabbing !important;
            z-index: 1001;
        }
        
        #model-canvas {
            cursor: grab;
        }
        
        #model-canvas.drag-over {
            background-color: rgba(76, 175, 80, 0.1);
            cursor: copy;
        }
        
        #model-canvas:active {
            cursor: grabbing;
        }
    `;

    // Add styles to document
    if (!document.getElementById('smooth-drag-styles')) {
        const styleEl = document.createElement('style');
        styleEl.id = 'smooth-drag-styles';
        styleEl.textContent = smoothDragStyles;
        document.head.appendChild(styleEl);
    }

    // NEW: Handle free placement
    function handleFreePlacement(e, itemType, itemValue) {
        const rect = renderer.domElement.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        // Convert screen coordinates to 3D position
        const position = screenToWorldPosition(mouseX, mouseY);
        
        if (position) {
            placeItemAtPosition(itemType, itemValue, position);
            checkAndSelectSource(itemType, itemValue);
        }
    }

    // NEW: Convert screen coordinates to 3D world position
    function screenToWorldPosition(screenX, screenY) {
        const vector = new THREE.Vector3(
            (screenX / renderer.domElement.clientWidth) * 2 - 1,
            -(screenY / renderer.domElement.clientHeight) * 2 + 1,
            0.5
        );
        
        vector.unproject(camera);
        
        // Create a plane at a reasonable height for new objects
        const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        const direction = vector.sub(camera.position).normalize();
        const raycaster = new THREE.Raycaster(camera.position, direction);
        const intersectionPoint = new THREE.Vector3();
        
        if (raycaster.ray.intersectPlane(groundPlane, intersectionPoint)) {
            return intersectionPoint;
        }
        
        return null;
    }

    // NEW: Update drag position visual feedback
    function updateDragPosition(e) {
        // This can be enhanced to show a preview of where the item will be placed
        const rect = renderer.domElement.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        // Could add a temporary preview object here
    }

    // NEW: Generic function to place items at specific positions
    function placeItemAtPosition(itemType, itemValue, position) {
        if (itemType === 'joint') {
            addJointMarker(itemValue, position);
        } else if (itemType === 'set' || itemType === 'phase') {
            if (selectedSets.size === 0 || selectedPhases.size === 0) {
                showSelectionRequiredMessage();
                return;
            }
            const currentSet = Array.from(selectedSets).pop();
            const currentPhase = Array.from(selectedPhases).pop();
            addSetPhaseMarker(currentSet, currentPhase, position);
        }
    }

    // NEW: Check and select source checkbox
    function checkAndSelectSource(itemType, itemValue) {
        const checkbox = document.querySelector(`input[name="${getCheckboxName(itemType)}"][value="${itemValue}"]`);
        if (checkbox && !checkbox.checked) {
            checkbox.checked = true;
            const changeEvent = new Event('change');
            checkbox.dispatchEvent(changeEvent);
        }
    }

    // NEW: Helper function to get checkbox name
    function getCheckboxName(itemType) {
        switch(itemType) {
            case 'joint': return 'joint-labels';
            case 'set': return 'set-numbers';
            case 'phase': return 'phase-numbers';
            default: return '';
        }
    }

    function initTransformControls() {
        // Create transform controls
        transformControls = new THREE.TransformControls(camera, renderer.domElement);
        transformControls.setSize(0.8);
        transformControls.addEventListener('dragging-changed', function(event) {
            controls.enabled = !event.value;
        });
        
        // Hide initially
        transformControls.visible = false;
        scene.add(transformControls);
    }

    function toggleGrid() {
        isGridVisible = !isGridVisible;
        
        gridHelpers.forEach(grid => {
            grid.visible = isGridVisible;
        });
        
        // Update button text
        const gridToggleBtn = document.getElementById('grid-toggle-btn');
        if (gridToggleBtn) {
            gridToggleBtn.textContent = isGridVisible ? 'Hide Grid' : 'Show Grid';
            gridToggleBtn.className = isGridVisible ? 'btn btn-warning btn-sm' : 'btn btn-success btn-sm';
        }
    }

    // Function to clear all grids
    function clearAllGrids() {
        gridHelpers.forEach(grid => {
            scene.remove(grid);
        });
        gridHelpers = [];
    }

function create3DGridCage(boundingBox) { 
    clearAllGrids();

    const size = boundingBox.getSize(new THREE.Vector3());
    const center = boundingBox.getCenter(new THREE.Vector3());

    const padding = 0.1;
    const padX = size.x * padding;
    const padY = size.y * padding;
    const padZ = size.z * padding;

    const divisionsX = 20;
    const divisionsY = Math.max(10, Math.floor(size.y));
    const divisionsZ = 20;

    // üîπ Balanced grid material (visible but not strong)
    const gridMaterial = new THREE.LineBasicMaterial({
        color: 0xaaaaaa,   // medium light gray
        transparent: true,
        opacity: 0.35,     // visible but soft
        linewidth: 1
    });

    function createGridPlane(width, height, divW, divH) {
        const geometry = new THREE.PlaneGeometry(width, height, divW, divH);
        const wireframe = new THREE.WireframeGeometry(geometry);
        return new THREE.LineSegments(wireframe, gridMaterial);
    }

    // ---------- FRONT & BACK (XY) ----------
    const front = createGridPlane(
        size.x + padX * 2,
        size.y + padY * 2,
        divisionsX,
        divisionsY
    );
    front.position.set(center.x, center.y, boundingBox.max.z + padZ);
    scene.add(front);
    gridHelpers.push(front);

    const back = front.clone();
    back.position.z = boundingBox.min.z - padZ;
    scene.add(back);
    gridHelpers.push(back);

    // ---------- LEFT & RIGHT (YZ) ----------
    const left = createGridPlane(
        size.z + padZ * 2,
        size.y + padY * 2,
        divisionsZ,
        divisionsY
    );
    left.rotation.y = Math.PI / 2;
    left.position.set(boundingBox.min.x - padX, center.y, center.z);
    scene.add(left);
    gridHelpers.push(left);

    const right = left.clone();
    right.position.x = boundingBox.max.x + padX;
    scene.add(right);
    gridHelpers.push(right);

    // ---------- TOP & BOTTOM (XZ) ----------
    const top = createGridPlane(
        size.x + padX * 2,
        size.z + padZ * 2,
        divisionsX,
        divisionsZ
    );
    top.rotation.x = -Math.PI / 2;
    top.position.set(center.x, boundingBox.max.y + padY, center.z);
    scene.add(top);
    gridHelpers.push(top);

    const bottom = top.clone();
    bottom.position.y = boundingBox.min.y - padY;
    scene.add(bottom);
    gridHelpers.push(bottom);

    isGridVisible = true;
}



    

        // NEW: Handle clicks on the 3D canvas for assigning labels
    function onCanvasClick(event) {
        event.preventDefault();

        // If we're using transform controls, don't process other clicks
        if (transformControls.dragging) return;

        const canvas = renderer.domElement;
        const rect = canvas.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        // If a label is being dropped from sidebar, place it
        if (currentDroppingItem) {
            const intersects = raycaster.intersectObjects(scene.children, true);

            if (intersects.length > 0) {
                const intersection = intersects[0];
                const point = intersection.point;

                const itemType = currentDroppingItem.type;
                const itemValue = currentDroppingItem.value;

                if (itemType === 'joint') {
                    addJointMarker(itemValue, point);
                } else if (itemType === 'set' || itemType === 'phase') {
                    if (selectedSets.size === 0 || selectedPhases.size === 0) {
                        showSelectionRequiredMessage();
                        return;
                    }
                    const currentSet = Array.from(selectedSets).pop();
                    const currentPhase = Array.from(selectedPhases).pop();
                    addSetPhaseMarker(currentSet, currentPhase, point);
                }

                // Check the source checkbox after dropping
                const checkbox = document.querySelector(`input[name="${itemType === 'joint' ? 'joint-labels' : (itemType === 'set' ? 'set-numbers' : 'phase-numbers')}"][value="${itemValue}"]`);
                if (checkbox) {
                    checkbox.checked = true;
                    const changeEvent = new Event('change');
                    checkbox.dispatchEvent(changeEvent);
                }

                currentDroppingItem = null;
                renderer.domElement.style.cursor = 'grab';
            }
            return;
        }

        // Handle selection of markers for transform controls
        const intersects = raycaster.intersectObjects(scene.children, true);
        
        // First, check if we clicked on transform controls
        const transformControlIntersects = raycaster.intersectObject(transformControls, true);
        if (transformControlIntersects.length > 0) {
            return; // Let transform controls handle the click
        }

        // Then check if we clicked on a marker
        let foundMarker = false;
        
        // Check joint markers
        Object.keys(jointMarkers).forEach(label => {
            if (jointMarkers[label].mesh === intersects[0]?.object) {
                selectObjectForTransform(jointMarkers[label].mesh, label, 'joint');
                foundMarker = true;
                return;
            }
        });
        
        // Check set-phase markers
        if (!foundMarker) {
            Object.keys(setMarkers).forEach(id => {
                if (setMarkers[id].mesh === intersects[0]?.object) {
                    selectObjectForTransform(setMarkers[id].mesh, id, 'set-phase');
                    foundMarker = true;
                    return;
                }
            });
        }

        // If clicked on empty space, deselect
        if (!foundMarker && intersects.length > 0) {
            deselectObject();
        }
    }

    function deselectObject() {
        if (selectedObject) {
            transformControls.detach();
            transformControls.visible = false;
            hideSelectionHighlight(selectedObject.object);
            selectedObject = null;
        }
    }

    // NEW: Show selection highlight
    function showSelectionHighlight(object) {
        // You can add visual feedback here, like changing color or adding outline
        if (object.material) {
            object.userData.originalColor = object.material.color.clone();
            object.material.color.set(0xffff00); // Yellow highlight
        }
    }

    // NEW: Hide selection highlight
    function hideSelectionHighlight(object) {
            if (object.material && object.userData.originalColor) {
                object.material.color.copy(object.userData.originalColor);
            }
        }

        // NEW: Select object for transform controls
        function selectObjectForTransform(object, value, type) {
        deselectObject();
        
        selectedObject = { object, value, type };
        transformControls.attach(object);
        transformControls.visible = true;
        
        transformControls.addEventListener('change', function() {
            updateObjectUI(selectedObject);
        });
        
        showSelectionHighlight(object);
        updateSelectedInfo(selectedObject);
    }
    
   

    // Setup part selection for the tower model
    function updateRendererSize() {
        const canvasContainer = document.querySelector('.model-viewer-container');
        if (canvasContainer && renderer) {
            const width = canvasContainer.clientWidth;
            const height = canvasContainer.clientHeight;
            console.log('Canvas container size:', width, height); // Add this line

            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        }
    }

        // Add a marker for a joint on the 3D model
    function addJointMarker(jointLabel, position = null) {
        if (jointMarkers[jointLabel]) return;

        // Use scaled size based on model
        const markerSize = BASE_MARKER_SIZE * (scaleFactor || 1);
        const geometry = new THREE.SphereGeometry(markerSize, 16, 16);
        const material = new THREE.MeshBasicMaterial({ 
            color: 0xff0000,
            transparent: true,
            opacity: 0.7
        });
        const sphere = new THREE.Mesh(geometry, material);

        if (position) {
            sphere.position.copy(position);
        } else {
            // Improved default positioning
            const markerCount = Object.keys(jointMarkers).length;
            const gridSize = Math.ceil(Math.sqrt(markerCount + 1));
            const row = Math.floor(markerCount / gridSize);
            const col = markerCount % gridSize;

            sphere.position.set(
                (col - gridSize / 2) * 0.8,
                2 + row * 0.4,
                (row - gridSize / 2) * 0.4
            );
        }

        // Create marker div - similar to set/phase markers
        const markerDiv = document.createElement('div');
        markerDiv.className = 'value-marker joint-marker';
        markerDiv.textContent = jointLabel;
        markerDiv.style.position = 'absolute';
        markerDiv.style.color = 'black';
        markerDiv.style.padding = '2px 5px';
        markerDiv.style.cursor = 'pointer';
        markerDiv.style.fontWeight = 'bold';
        markerDiv.style.pointerEvents = 'auto';
        markerDiv.dataset.jointLabel = jointLabel;
        document.getElementById('joint-markers-container').appendChild(markerDiv);

        // Click handler for selection - same as set/phase markers
        markerDiv.addEventListener('click', function(e) {
            e.stopPropagation();
            selectObjectForTransform(sphere, jointLabel, 'joint');
        });

            jointMarkers[jointLabel] = {
            mesh: sphere,
            div: markerDiv,
            originalScale: scaleFactor || 1,
            fontSize: 12 * (scaleFactor || 1) // Store scaled font size
        };

        scene.add(sphere);
        updateMarkerPosition(sphere, markerDiv);
    }

    // MODIFIED: addSetPhaseMarker - add selection capability
    function addSetPhaseMarker(setNumber, phaseNumber, position = null) {
    const combination = Array.from(activeCombinations.values()).find(comb => 
        comb.set === setNumber && comb.phase === phaseNumber
    );
    
    if (!combination) return null;

    const uniqueId = `${combination.id}_${Date.now()}`;
    
    // Your existing marker creation code here (keep the same)
    const markerSize = BASE_MARKER_SIZE * (scaleFactor || 1);
    const geometry = new THREE.SphereGeometry(markerSize, 16, 16);
    const material = new THREE.MeshBasicMaterial({ 
        color: 0x0000ff,
        transparent: true,
        opacity: 0.7
    });
    const sphere = new THREE.Mesh(geometry, material);

    if (position) {
        sphere.position.copy(position);
    } else {
        const markerCount = Object.keys(setMarkers).length;
        const gridSize = Math.ceil(Math.sqrt(markerCount + 1));
        const row = Math.floor(markerCount / gridSize);
        const col = markerCount % gridSize;

        sphere.position.set(
            (col - gridSize / 2) * 0.8,
            2 + row * 0.4,
            (row - gridSize / 2) * 0.4
        );
    }

    // Create HTML marker (your existing code)
    const markerDiv = document.createElement('div');
    markerDiv.className = 'value-marker set-phase-marker';
    markerDiv.textContent = `${setNumber}:${phaseNumber}`;
    markerDiv.style.position = 'absolute';
    markerDiv.style.color = 'black';
    markerDiv.style.padding = '2px 5px';
    markerDiv.style.cursor = 'pointer';
    markerDiv.style.fontWeight = 'bold';
    markerDiv.style.pointerEvents = 'auto';
    markerDiv.dataset.combinedId = uniqueId;
    markerDiv.dataset.baseCombination = `${setNumber}:${phaseNumber}`;
    document.getElementById('set-markers-container').appendChild(markerDiv);

    markerDiv.addEventListener('click', function(e) {
        e.stopPropagation();
        selectObjectForTransform(sphere, uniqueId, 'set-phase');
    });

    // Store the marker
    setMarkers[uniqueId] = {
        mesh: sphere,
        div: markerDiv,
        setNumber: setNumber,
        phaseNumber: phaseNumber,
        baseCombination: `${setNumber}:${phaseNumber}`,
        uniqueId: uniqueId,
        combinationId: combination.id,
        originalScale: scaleFactor || 1,
        fontSize: 12 * (scaleFactor || 1)
    };

    scene.add(sphere);
    updateMarkerPosition(sphere, markerDiv);
    
    return uniqueId;
}

    // Add CSS for better cursor feedback
    const style = document.createElement('style');
    style.textContent = `
        .value-marker:hover {
            transform: scale(1.1);
            transition: transform 0.2s ease;
        }
        
        #model-canvas.grabbing {
            cursor: grabbing !important;
        }
    `;
    document.head.appendChild(style);

    // Function to show combination created message
    function showCombinationCreatedMessage(combination) {
        let messageDiv = document.getElementById('combination-created-message');
        if (!messageDiv) {
            messageDiv = document.createElement('div');
            messageDiv.id = 'combination-created-message';
            messageDiv.style.position = 'fixed';
            messageDiv.style.top = '20px';
            messageDiv.style.right = '20px';
            messageDiv.style.background = '#e8f5e8';
            messageDiv.style.color = '#2e7d32';
            messageDiv.style.padding = '12px 18px';
            messageDiv.style.border = '2px solid #4caf50';
            messageDiv.style.borderRadius = '6px';
            messageDiv.style.zIndex = '1000';
            messageDiv.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
            messageDiv.style.fontWeight = 'bold';
            document.body.appendChild(messageDiv);
        }
        
        messageDiv.innerHTML = `‚úÖ Created combination: ${combination}`;
        messageDiv.style.display = 'block';
        
        setTimeout(() => {
            messageDiv.style.display = 'none';
        }, 2000);
    }

    // Function to remove a set:phase marker
    function removeSetPhaseMarker(uniqueId) {
        if (!setMarkers[uniqueId]) return;
        
        scene.remove(setMarkers[uniqueId].mesh);
        if (setMarkers[uniqueId].div && setMarkers[uniqueId].div.parentNode) {
            document.getElementById('set-markers-container').removeChild(setMarkers[uniqueId].div);
        }
        delete setMarkers[uniqueId];
        updateTable(); // Refresh the table after removal
    }

    // Function to create new set:phase combination
    function createSetPhaseCombination() {
        if (selectedSets.size === 0 || selectedPhases.size === 0) {
            showSelectionRequiredMessage();
            return;
        }
        
        // Get the currently selected set and phase
        const currentSet = Array.from(selectedSets).pop();
        const currentPhase = Array.from(selectedPhases).pop();
        
        if (currentSet && currentPhase) {
            // Always create new combination, even if same set:phase exists
            addSetPhaseMarker(currentSet, currentPhase);
            
            // Don't clear phase selection - allow creating multiple of same combination
            updateTable();
        }
    }

    // Function to show selection required message
    function showSelectionRequiredMessage() {
        let messageDiv = document.getElementById('selection-required-message');
        if (!messageDiv) {
            messageDiv = document.createElement('div');
            messageDiv.id = 'selection-required-message';
            messageDiv.style.position = 'fixed';
            messageDiv.style.top = '20px';
            messageDiv.style.right = '20px';
            messageDiv.style.background = '#fff3e0';
            messageDiv.style.color = '#ef6c00';
            messageDiv.style.padding = '12px 18px';
            messageDiv.style.border = '2px solid #ff9800';
            messageDiv.style.borderRadius = '6px';
            messageDiv.style.zIndex = '1000';
            messageDiv.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
            messageDiv.style.fontWeight = 'bold';
            document.body.appendChild(messageDiv);
        }
        
        messageDiv.innerHTML = "‚ö†Ô∏è Please select both a Set and a Phase first";
        messageDiv.style.display = 'block';
        
        setTimeout(() => {
            messageDiv.style.display = 'none';
        }, 3000);
    }

    // Clear all set:phase combinations
    function clearAllSetPhaseCombinations() {
        Object.keys(setMarkers).forEach(uniqueId => {
            removeSetPhaseMarker(uniqueId);
        });
        combinationCounter = 0; // Reset counter
    }

    // Get combinations by base type (for table display)
    function getCombinationsByBaseType() {
        const combinationsByType = {};
        
        Object.values(setMarkers).forEach(marker => {
            const baseCombination = marker.baseCombination;
            if (!combinationsByType[baseCombination]) {
                combinationsByType[baseCombination] = [];
            }
            combinationsByType[baseCombination].push(marker);
        });
        
        return combinationsByType;
    }


    function autoZoomToFit() {
        if (!modelBoundingBox || !camera || !controls) return;
        
        const box = modelBoundingBox;
        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());
        
        // Calculate camera distance based on model size
        const maxDim = Math.max(size.x, size.y, size.z);
        const fov = camera.fov * (Math.PI / 180);
        const distance = Math.abs(maxDim / Math.sin(fov / 2));
        
        // Position camera
        camera.position.set(
            center.x,
            center.y + size.y * 0.5,
            center.z + distance * 1.5
        );
        
        camera.lookAt(center);
        controls.target.copy(center);
        controls.update();
    }


    // Update HTML marker position based on 3D position
    function updateMarkerPosition(mesh, div) {
        const isJoint = div.classList.contains('joint-marker');
        const markerRef = isJoint ? jointMarkers[div.dataset.jointLabel] : setMarkers[div.dataset.combinedId];
        if (!markerRef || !mesh) return;

        const vector = mesh.position.clone();
        vector.project(camera);

        const x = (vector.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
        const y = (-(vector.y * 0.5) + 0.5) * renderer.domElement.clientHeight;

        div.style.left = `${x}px`;
        div.style.top = `${y}px`;
        div.style.transform = 'translate(-50%, -50%)';

        // Dynamic scaling based on distance AND model size
        const distance = camera.position.distanceTo(mesh.position);
        
        // Base scaling factor from model size
        const modelScaleFactor = markerRef.originalScale || scaleFactor || 1;
        
        // Distance scaling - less aggressive for small models
        const distanceFactor = Math.max(0.3, Math.min(2, 50 / distance));
        
        // Combined scaling
        const combinedScale = modelScaleFactor * distanceFactor;
        
        // Update font size
        const baseFontSize = 12;
        div.style.fontSize = `${baseFontSize * combinedScale}px`;
        
        // Scale the 3D mesh as well for consistent appearance
        const targetScale = combinedScale;
        mesh.scale.setScalar(targetScale);
        
        // Handle visibility when behind camera
        if (vector.z > 1) {
            div.style.opacity = '0.3';
        } else {
            div.style.opacity = '1';
        }
    }

    // Update load display position based on 3D position
    function updateLoadDisplayPosition(div, position) {
        const vector = position.clone();
        vector.project(camera);
        
        const x = (vector.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
        const y = (-(vector.y * 0.5) + 0.5) * renderer.domElement.clientHeight;
        
        div.style.left = `${x + 20}px`; // Offset slightly from the marker
        div.style.top = `${y}px`;
    }

    function removeJointMarker(jointLabel) {
        if (!jointMarkers[jointLabel]) return;
        
        scene.remove(jointMarkers[jointLabel].mesh);
        document.getElementById('joint-markers-container').removeChild(jointMarkers[jointLabel].div);
        delete jointMarkers[jointLabel];
    }

    
    function animate() {
        requestAnimationFrame(animate);
        
        if (!transformControls.dragging) {
            controls.update();
        }

        // Update marker positions - only markers, no load displays
        for (const jointLabel in jointMarkers) {
            updateMarkerPosition(jointMarkers[jointLabel].mesh, jointMarkers[jointLabel].div);
        }

        for (const combinedId in setMarkers) {
            updateMarkerPosition(setMarkers[combinedId].mesh, setMarkers[combinedId].div);
        }

        renderer.render(scene, camera);
    }

    document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape') {
            deselectObject();
        }
    });
    
    function onWindowResize() {
    updateRendererSize();

    // Update all marker positions
    for (const label in jointMarkers) {
        updateMarkerPosition(jointMarkers[label].mesh, jointMarkers[label].div);
    }
    for (const combinedId in setMarkers) {
        updateMarkerPosition(setMarkers[combinedId].mesh, setMarkers[combinedId].div);
    }

    }
    
    // Clear table
    function clearTable() {
        document.getElementById('load-table').getElementsByTagName('tbody')[0].innerHTML = '';
    }


    function handleRecordSelection(e) {
    const index = parseInt(e.target.dataset.index);
    const record = allTableData[index];
    
    if (e.target.checked) {
        selectedRecords.add(record);
    } else {
        selectedRecords.delete(record);
    }
    
    updateSelectedCount();
}

function updateSelectedCount() {
    const selectedCount = document.getElementById('selected-count');
    const calculateBtn = document.getElementById('calculate-btn');
    
    selectedCount.textContent = `${selectedRecords.size} selected`;
    calculateBtn.disabled = selectedRecords.size === 0;
}

// Add event listener for calculate button
// Update the calculate button event listener
document.getElementById('calculate-btn').addEventListener('click', function() {
    if (selectedRecords.size > 0) {
        // Prepare data for calculation - convert Set to Array
        const calculationData = Array.from(selectedRecords);
        
        // Create a form to submit the data via POST (FIX for 414 error)
        const form = document.createElement('form');
        form.method = 'POST';
        form.action = "{% url 'calculation' %}";  // Make sure this matches your URL name
        form.target = '_blank';
        form.style.display = 'none';
        
        // Add CSRF token for Django POST requests
        const csrfToken = document.createElement('input');
        csrfToken.type = 'hidden';
        csrfToken.name = 'csrfmiddlewaretoken';
        csrfToken.value = '{{ csrf_token }}';
        form.appendChild(csrfToken);
        
        // Add calculation data
        const input = document.createElement('input');
        input.type = 'hidden';
        input.name = 'calculation_data';
        input.value = JSON.stringify(calculationData);
        form.appendChild(input);
        
        document.body.appendChild(form);
        form.submit();
        document.body.removeChild(form);
    }
});

    
    
// Update table with selected labels
function updateTable() {
    clearTable();
    const tbody = document.getElementById('load-table').getElementsByTagName('tbody')[0];
    
    const columns = Array.from(document.querySelectorAll('#load-table thead th'))
        .map(th => th.textContent.trim())
        .filter(col => col !== 'Select');
    
    allTableData = [];
    
    // SECTION 1: Show all load cases records
    loadData.forEach((item, index) => {
        const row = tbody.insertRow();
        const dataIndex = allTableData.length;
        allTableData.push(item);
        
        const checkboxCell = row.insertCell();
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'record-checkbox';
        checkbox.dataset.index = dataIndex;
        checkbox.addEventListener('change', handleRecordSelection);
        checkboxCell.appendChild(checkbox);
        
        columns.forEach(column => {
            const cell = row.insertCell();
            cell.textContent = item[column] !== undefined ? item[column] : '';
        });
    });
    
    // SECTION 2: Show created set:phase combinations from activeCombinations
    {% if button_type == 'set_phase' %}
        if (activeCombinations.size > 0) {
            console.log('=== PROCESSING COMBINATIONS ===');
            console.log('Total active combinations:', activeCombinations.size);
            console.log('Active combinations:', Array.from(activeCombinations.values()));
            
            const separatorRow = tbody.insertRow();
            const separatorCell = separatorRow.insertCell();
            separatorCell.colSpan = columns.length + 1;
            separatorCell.innerHTML = '<hr style="margin: 20px 0; border-color: #ccc;">';
            separatorCell.style.backgroundColor = '#f8f9fa';
            
            const headerRow = tbody.insertRow();
            const headerCell = headerRow.insertCell();
            headerCell.colSpan = columns.length + 1;
            headerCell.textContent = 'CREATED COMBINATIONS';
            headerCell.style.textAlign = 'center';
            headerCell.style.backgroundColor = '#007bff';
            headerCell.style.color = 'white';
            headerCell.style.fontWeight = 'bold';
            headerCell.style.fontSize = '16px';
            
            // Convert activeCombinations to array to ensure we process ALL
            const combinationsArray = Array.from(activeCombinations.values());
            let displayedCombinationCount = 0;
            
            console.log('Processing combinations array:', combinationsArray);
            
            // Process EACH combination individually
            combinationsArray.forEach((combination, index) => {
                const setNum = combination.set;
                const phaseNum = combination.phase;
                const combinationId = combination.id;
                const combinationDisplay = combination.displayText;
                
                console.log(`Processing combination ${index + 1}: ${combinationDisplay} (ID: ${combinationId})`);
                
                // Find ALL matching records for this specific set/phase combination
                const matchingRecords = loadData.filter(item => {
                    const itemSet = item['Set No.'] !== undefined ? String(item['Set No.']) : '';
                    const itemPhase = item['Phase No.'] !== undefined ? String(item['Phase No.']) : '';
                    
                    const matches = itemSet === String(setNum) && itemPhase === String(phaseNum);
                    
                    if (matches) {
                        console.log(`‚úì Found match for ${combinationDisplay}:`, {
                            set: itemSet,
                            phase: itemPhase,
                            loadCase: item['Load Case Description']
                        });
                    }
                    
                    return matches;
                });
                
                console.log(`Records found for ${combinationDisplay}: ${matchingRecords.length}`);
                
                if (matchingRecords.length > 0) {
                    displayedCombinationCount++;
                    
                    // Group records by Load Case for this specific combination
                    const recordsByLoadCase = {};
                    
                    matchingRecords.forEach(record => {
                        const loadCase = record['Load Case Description'] || 'Uncategorized';
                        if (!recordsByLoadCase[loadCase]) {
                            recordsByLoadCase[loadCase] = [];
                        }
                        recordsByLoadCase[loadCase].push(record);
                    });
                    
                    // Create combination header
                    const combHeaderRow = tbody.insertRow();
                    const combHeaderCell = combHeaderRow.insertCell();
                    combHeaderCell.colSpan = columns.length + 1;
                    combHeaderCell.style.backgroundColor = '#e3f2fd';
                    combHeaderCell.style.borderLeft = '4px solid #1976d2';
                    combHeaderCell.style.padding = '10px';
                    combHeaderCell.style.fontWeight = 'bold';
                    combHeaderCell.style.fontSize = '14px';
                    
                    const combCheckbox = document.createElement('input');
                    combCheckbox.type = 'checkbox';
                    combCheckbox.className = 'combination-checkbox';
                    combCheckbox.dataset.combinationId = combinationId;
                    combCheckbox.checked = true;
                    combCheckbox.addEventListener('change', function(e) {
                        toggleCombinationSelection(combinationId, e.target.checked);
                    });
                    
                    const combLabel = document.createElement('span');
                    combLabel.style.marginLeft = '8px';
                    combLabel.textContent = `Combination ${displayedCombinationCount}: Set ${setNum} - Phase ${phaseNum}`;
                    
                    combHeaderCell.appendChild(combCheckbox);
                    combHeaderCell.appendChild(combLabel);
                    
                    // Display records for each load case in this combination
                    Object.keys(recordsByLoadCase).forEach(loadCase => {
                        const loadCaseRecords = recordsByLoadCase[loadCase];
                        
                        // Load Case sub-header
                        const loadCaseHeaderRow = tbody.insertRow();
                        const loadCaseHeaderCell = loadCaseHeaderRow.insertCell();
                        loadCaseHeaderCell.colSpan = columns.length + 1;
                        loadCaseHeaderCell.style.backgroundColor = '#f5f5f5';
                        loadCaseHeaderCell.style.padding = '8px 12px';
                        loadCaseHeaderCell.style.fontWeight = 'bold';
                        loadCaseHeaderCell.style.fontSize = '13px';
                        
                        const loadCaseCheckbox = document.createElement('input');
                        loadCaseCheckbox.type = 'checkbox';
                        loadCaseCheckbox.className = 'loadcase-checkbox';
                        loadCaseCheckbox.dataset.combinationId = combinationId;
                        loadCaseCheckbox.dataset.loadCase = loadCase;
                        loadCaseCheckbox.checked = true;
                        loadCaseCheckbox.addEventListener('change', function(e) {
                            toggleLoadCaseSelection(combinationId, loadCase, e.target.checked);
                        });
                        
                        const loadCaseLabel = document.createElement('span');
                        loadCaseLabel.style.marginLeft = '8px';
                        loadCaseLabel.textContent = `Load Case: ${loadCase}`;
                        
                        loadCaseHeaderCell.appendChild(loadCaseCheckbox);
                        loadCaseHeaderCell.appendChild(loadCaseLabel);
                        
                        // Display individual records
                        loadCaseRecords.forEach(record => {
                            const row = tbody.insertRow();
                            const dataIndex = allTableData.length;
                            allTableData.push(record);
                            
                            const checkboxCell = row.insertCell();
                            const checkbox = document.createElement('input');
                            checkbox.type = 'checkbox';
                            checkbox.className = 'record-checkbox';
                            checkbox.dataset.index = dataIndex;
                            checkbox.dataset.combinationId = combinationId;
                            checkbox.dataset.loadCase = loadCase;
                            checkbox.checked = true;
                            checkbox.addEventListener('change', handleRecordSelection);
                            checkboxCell.appendChild(checkbox);
                            
                            columns.forEach(column => {
                                const cell = row.insertCell();
                                // Highlight combination info
                                if (column === 'Set No.' || column === 'Phase No.') {
                                    cell.style.fontWeight = 'bold';
                                    cell.style.backgroundColor = '#f0f8ff';
                                }
                                cell.textContent = record[column] !== undefined ? record[column] : '';
                            });
                            
                            // Auto-select this record
                            selectedRecords.add(record);
                        });
                    });
                    
                    // Add small spacer between combinations
                    if (index < combinationsArray.length - 1) {
                        const spacerRow = tbody.insertRow();
                        const spacerCell = spacerRow.insertCell();
                        spacerCell.colSpan = columns.length + 1;
                        spacerCell.style.padding = '10px';
                        spacerCell.style.backgroundColor = '#f8f9fa';
                    }
                } else {
                    console.log(`‚ùå No records found for ${combinationDisplay}`);
                    
                    // Show combination with no data message
                    const noDataRow = tbody.insertRow();
                    const noDataCell = noDataRow.insertCell();
                    noDataCell.colSpan = columns.length + 1;
                    noDataCell.style.backgroundColor = '#fff3cd';
                    noDataCell.style.padding = '10px';
                    noDataCell.style.color = '#856404';
                    noDataCell.style.fontStyle = 'italic';
                    noDataCell.textContent = `Combination: Set ${setNum} - Phase ${phaseNum} - No matching records found in data`;
                }
            });
            
            console.log(`=== DISPLAYED ${displayedCombinationCount} COMBINATIONS ===`);
            
            // If no combinations had data at all
            if (displayedCombinationCount === 0) {
                const noDataRow = tbody.insertRow();
                const noDataCell = noDataRow.insertCell();
                noDataCell.colSpan = columns.length + 1;
                noDataCell.textContent = 'No matching records found in the data for any created combinations.';
                noDataCell.style.textAlign = 'center';
                noDataCell.style.color = '#666';
                noDataCell.style.fontStyle = 'italic';
                noDataCell.style.padding = '20px';
            }
        } else {
            console.log('No active combinations found');
        }
    {% endif %}
    
    // SECTION 3: Show attachment joint label records in combinations (for both modes)
    const selectedJointLabels = Array.from(selectedJoints);
    if (selectedJointLabels.length > 0) {
        // Add a separator row
        const separatorRow = tbody.insertRow();
        const separatorCell = separatorRow.insertCell();
        separatorCell.colSpan = columns.length + 1;
        separatorCell.innerHTML = '<hr style="margin: 20px 0; border-color: #ccc;">';
        separatorCell.style.backgroundColor = '#f8f9fa';
        
        // Add joint labels section header
        const headerRow = tbody.insertRow();
        const headerCell = headerRow.insertCell();
        headerCell.colSpan = columns.length + 1;
        headerCell.textContent = 'ATTACHMENT JOINT LABELS';
        headerCell.style.textAlign = 'center';
        headerCell.style.backgroundColor = '#28a745';
        headerCell.style.color = 'white';
        headerCell.style.fontWeight = 'bold';
        headerCell.style.fontSize = '16px';
        
        // Show records for each selected joint label
        selectedJointLabels.forEach(label => {
            const matchingRecords = loadData.filter(item => 
                String(item['Attach. Joint Labels']) === String(label)
            );
            
            if (matchingRecords.length > 0) {
                // Add a sub-header row for the joint label
                const jointHeaderRow = tbody.insertRow();
                const jointHeaderCell = jointHeaderRow.insertCell();
                jointHeaderCell.colSpan = columns.length + 1;
                jointHeaderCell.textContent = `Joint Label: ${label}`;
                jointHeaderCell.style.textAlign = 'center';
                jointHeaderCell.style.backgroundColor = '#e6ffe6';
                jointHeaderCell.style.fontWeight = 'bold';
                
                // Add each matching record as a row with checkbox
                matchingRecords.forEach((item, index) => {
                    const row = tbody.insertRow();
                    const dataIndex = allTableData.length;
                    allTableData.push(item);
                    
                    // Add checkbox cell
                    const checkboxCell = row.insertCell();
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'record-checkbox';
                    checkbox.dataset.index = dataIndex;
                    checkbox.addEventListener('change', handleRecordSelection);
                    checkboxCell.appendChild(checkbox);
                    
                    // Add cells for each column
                    columns.forEach(column => {
                        const cell = row.insertCell();
                        cell.textContent = item[column] !== undefined ? item[column] : '';
                    });
                });
            }
        });
    }
    
    // Update selected count
    updateSelectedCount();
}


    
function toggleCombinationGroupSelection(loadCase, isChecked) {
    // Find all combination records in this load case group
    document.querySelectorAll('.record-checkbox[data-combination-type="created"]').forEach(checkbox => {
        if (checkbox.dataset.loadCase === loadCase) {
            checkbox.checked = isChecked;
            const index = parseInt(checkbox.dataset.index);
            const record = allTableData[index];
            
            if (isChecked) {
                selectedRecords.add(record);
            } else {
                selectedRecords.delete(record);
            }
        }
    });
    
    updateSelectedCount();
}

// Initialize Set-Phase selection
function initSetPhaseSelection() {
    const setSelect = document.getElementById('set-select');
    const phaseSelect = document.getElementById('phase-select');
    
    if (setSelect) {
        setSelect.addEventListener('change', function() {
            updateSelectedSets();
            updateSelectionDisplay();
        });
    }
    
    if (phaseSelect) {
        phaseSelect.addEventListener('change', function() {
            updateSelectedPhases();
            updateSelectionDisplay();
        });
    }
    
    // Combination creation buttons
    document.getElementById('create-all-combinations')?.addEventListener('click', createAllCombinations);
    document.getElementById('create-single-combination')?.addEventListener('click', createSingleCombination);
    document.getElementById('clear-combinations')?.addEventListener('click', clearAllCombinations);
}

// Update selected sets from multi-select
function updateSelectedSets() {
    const setSelect = document.getElementById('set-select');
    selectedSets.clear();
    
    Array.from(setSelect.selectedOptions).forEach(option => {
        selectedSets.add(option.value);
    });
}

// Update selected phases from multi-select
function updateSelectedPhases() {
    const phaseSelect = document.getElementById('phase-select');
    selectedPhases.clear();
    
    Array.from(phaseSelect.selectedOptions).forEach(option => {
        selectedPhases.add(option.value);
    });
}

// Update the selection display
function updateSelectionDisplay() {
    document.getElementById('selected-sets-display').textContent = 
        selectedSets.size > 0 ? Array.from(selectedSets).join(', ') : 'None';
    
    document.getElementById('selected-phases-display').textContent = 
        selectedPhases.size > 0 ? Array.from(selectedPhases).join(', ') : 'None';
}

// Create all possible combinations from selected sets and phases
function createAllCombinations() {
    if (selectedSets.size === 0 || selectedPhases.size === 0) {
        showSelectionRequiredMessage();
        return;
    }
    
    console.log('Creating ALL combinations from:', {
        sets: Array.from(selectedSets),
        phases: Array.from(selectedPhases)
    });
    
    selectedSets.forEach(set => {
        selectedPhases.forEach(phase => {
            createCombination(set, phase);
        });
    });
    
    console.log('Total combinations after creation:', activeCombinations.size);
    updateActiveCombinationsDisplay();
    updateTable();
}

// Create a single combination
function createSingleCombination() {
    if (selectedSets.size === 0 || selectedPhases.size === 0) {
        showSelectionRequiredMessage();
        return;
    }
    
    // Use the first selected set and phase
    const set = Array.from(selectedSets)[0];
    const phase = Array.from(selectedPhases)[0];
    
    console.log('Creating single combination:', { set, phase });
    
    createCombination(set, phase);
    updateActiveCombinationsDisplay();
    updateTable();
}

// Create individual combination
function createCombination(set, phase) {
    const combinationId = `comb_${combinationCounter++}_${Date.now()}`;
    const combination = {
        id: combinationId,
        set: set,
        phase: phase,
        displayText: `Set ${set} - Phase ${phase}`,
        marker: null
    };
    
    activeCombinations.set(combinationId, combination);
    
    console.log(`Created combination: ${combination.displayText} (ID: ${combinationId})`);
    
    // Add to 3D scene if needed
    addSetPhaseMarker(set, phase);
    
    showCombinationCreatedMessage(combination.displayText);
    
    syncSelectionsWithSession(); // NEW: Sync with session
    return combinationId;
}

// Function to generate combinations (Keep this logic, but decouple storage)
function generateCombinations(mode) {
    const selectedSets = Array.from(document.getElementById('set-select').selectedOptions).map(opt => opt.value);
    const selectedPhases = Array.from(document.getElementById('phase-select').selectedOptions).map(opt => opt.value);
    
    let generatedCombinations = [];

    if (mode === 'all') {
        if (selectedSets.length === 0 || selectedPhases.length === 0) {
            alert('Please select at least one Set and one Phase for "Create All Combinations".');
            return [];
        }
        for (const set of selectedSets) {
            for (const phase of selectedPhases) {
                generatedCombinations.push(`${set}-${phase}`);
            }
        }
    } else if (mode === 'single') {
        if (selectedSets.length !== 1 || selectedPhases.length !== 1) {
            alert('Please select exactly one Set and one Phase for "Create Single Combination".');
            return [];
        }
        generatedCombinations.push(`${selectedSets[0]}-${selectedPhases[0]}`);
    }

    
    return generatedCombinations;
}

// Update the active combinations display
function updateActiveCombinationsDisplay() {
    const displayElement = document.getElementById('active-combinations');
    displayElement.innerHTML = '';

    // Load from the session data passed by Django (which now includes status)
    const activeCombinationsList = JSON.parse('{{ active_combinations|safe|escapejs }}');

    if (activeCombinationsList.length === 0) {
        displayElement.innerHTML = '<p class="text-muted">No combinations active.</p>';
        return;
    }

    activeCombinationsList.forEach(combo => {
        // combo will be like "1-2-Ahead" or "1-2-Back" (Both is no longer possible)
        const parts = combo.split('-');
        const set = parts[0];
        const phase = parts[1];
        const status = parts[2];
        
        // Determine badge class based on status (Both is removed)
        let badgeClass;
        if (status === 'Ahead') {
            badgeClass = 'badge-success';
        } else if (status === 'Back') {
            badgeClass = 'badge-warning';
        } else {
            badgeClass = 'badge-secondary'; // Fallback for any legacy data
        }
        
        const item = document.createElement('span');
        item.className = 'badge badge-primary mr-1 mb-1';
        item.innerHTML = `Set ${set}, Phase ${phase} <span class="badge ${badgeClass}">${status}</span>`;
        item.dataset.set = set;
        item.dataset.phase = phase;
        item.dataset.status = status;
        displayElement.appendChild(item);
    });
}

async function storeCombinations(status) {
    if (combinationsToConfirm.length === 0) return;

    try {
        const response = await fetch('{% url "store_set_phase_combinations" %}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken 
            },
            body: JSON.stringify({
                combinations: combinationsToConfirm,
                status: status
            })
        });

        const result = await response.json();

        if (response.ok) {
            console.log(result.message);
            
            // Use the data returned from the server to update the display
            updateActiveCombinationsDisplayFromResponse(result.new_combinations);
            updateTable();
            
            // Optionally show success message
            showSuccessMessage(`Combinations stored as ${status}`);
        } else {
            alert('Error storing combinations: ' + result.message);
        }
    } catch (error) {
        console.error('Network or other error:', error);
        alert('An unexpected error occurred. Check console.');
    } finally {
        combinationsToConfirm = [];
    }
}

// Update the function that displays combinations to handle "Both" status
function updateActiveCombinationsDisplayFromResponse(newCombinations) {
    const displayElement = document.getElementById('active-combinations');
    displayElement.innerHTML = '';

    if (!newCombinations || newCombinations.length === 0) {
        displayElement.innerHTML = '<p class="text-muted">No combinations active.</p>';
        return;
    }

    newCombinations.forEach(combo => {
        // combo will be like "1-2-Ahead" or "1-2-Back" (Both is removed)
        const parts = combo.split('-');
        const set = parts[0];
        const phase = parts[1];
        const status = parts[2]; // This could be Ahead or Back only now
        
        // Determine badge class based on status (Both is removed)
        let badgeClass;
        if (status === 'Ahead') {
            badgeClass = 'badge-success';
        } else if (status === 'Back') {
            badgeClass = 'badge-warning';
        } else {
            badgeClass = 'badge-secondary'; // Fallback
        }
        
        const item = document.createElement('span');
        item.className = 'badge badge-primary mr-1 mb-1';
        item.innerHTML = `Set ${set}, Phase ${phase} <span class="badge ${badgeClass}">${status}</span>`;
        item.dataset.set = set;
        item.dataset.phase = phase;
        item.dataset.status = status;
        displayElement.appendChild(item);
    });
}

function showSuccessMessage(message) {
    // You can use a toast library or simple alert
    const toast = document.createElement('div');
    toast.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #4CAF50;
        color: white;
        padding: 12px 20px;
        border-radius: 4px;
        z-index: 10000;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    `;
    toast.textContent = message;
    document.body.appendChild(toast);
    
    setTimeout(() => {
        document.body.removeChild(toast);
    }, 3000);
}

// Event Listeners for Create Buttons
document.getElementById('create-all-combinations').addEventListener('click', function() {
    const newCombinations = generateCombinations('all');
    if (newCombinations.length > 0) {
        combinationsToConfirm = newCombinations;
        showAheadBackModal();
    }
});

document.getElementById('create-single-combination').addEventListener('click', function() {
    const newCombinations = generateCombinations('single');
    if (newCombinations.length > 0) {
        combinationsToConfirm = newCombinations;
        showAheadBackModal();
    }
});


function showAheadBackModal() {
    const ul = document.getElementById('new-combinations-list');
    ul.innerHTML = ''; // Clear previous list
    
    if (combinationsToConfirm.length === 0) {
        return; // Should not happen if called correctly
    }

    combinationsToConfirm.forEach(combo => {
        const li = document.createElement('li');
        li.className = 'list-group-item list-group-item-info';
        const [set, phase] = combo.split('-');
        li.textContent = `Set: ${set}, Phase: ${phase}`;
        ul.appendChild(li);
    });

    // Show the Bootstrap modal
    $('#aheadBackModal').modal('show');
}

// Event listeners for Modal Buttons
document.getElementById('btn-ahead').addEventListener('click', function() {
    storeCombinations('Ahead');
});

document.getElementById('btn-back').addEventListener('click', function() {
    storeCombinations('Back');
});

document.getElementById('btn-both').addEventListener('click', function() {
    storeCombinations('Both');
});

// Call the display function on page load
document.addEventListener('DOMContentLoaded', updateActiveCombinationsDisplay);

// Remove a specific combination
function removeCombination(combinationId) {
    if (activeCombinations.has(combinationId)) {
        const comb = activeCombinations.get(combinationId);
        
        // Remove from 3D scene
        removeSetPhaseMarkerByCombination(comb.set, comb.phase, combinationId);
        
        // Remove from active combinations
        activeCombinations.delete(combinationId);
        
        updateActiveCombinationsDisplay();
        updateTable();
        syncSelectionsWithSession(); // NEW: Sync with session
    }
}


// Clear all combinations
function clearAllCombinations() {
    activeCombinations.clear();
    
    // Clear all set-phase markers from 3D scene
    Object.keys(setMarkers).forEach(uniqueId => {
        removeSetPhaseMarker(uniqueId);
    });
    
    updateActiveCombinationsDisplay();
    updateTable();
    syncSelectionsWithSession(); // NEW: Sync with session
}


// Helper function to remove set-phase marker by combination
function removeSetPhaseMarkerByCombination(set, phase, combinationId) {
    Object.keys(setMarkers).forEach(uniqueId => {
        const marker = setMarkers[uniqueId];
        if (marker.setNumber === set && marker.phaseNumber === phase && 
            uniqueId.includes(combinationId)) {
            removeSetPhaseMarker(uniqueId);
        }
    });
}

function syncSelectionsWithSession() {
    const selectedJointsArray = Array.from(selectedJoints);
    const activeCombinationsArray = Array.from(activeCombinations.values());
    
    const formData = new FormData();
    selectedJointsArray.forEach(joint => formData.append('selected_joints[]', joint));
    formData.append('active_combinations', JSON.stringify(activeCombinationsArray));
    
    fetch('/update-selection-session/', {
        method: 'POST',
        headers: {
            'X-Requested-With': 'XMLHttpRequest',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            console.log('Selections synced with session:', data);
        }
    })
    .catch(error => {
        console.error('Error syncing selections:', error);
    });
}

// Helper function to get CSRF token
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

    // Set up event listeners
    document.addEventListener('DOMContentLoaded', function() {
        initModelViewer();
        updateTable();
        initSetPhaseSelection(); // Initialize the new Set-Phase selection


        // Set selection - allow multiple sets
        const setContainer = document.getElementById('set-numbers');
            if (setContainer) {
                setContainer.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                    checkbox.addEventListener('change', function() {
                        const setValue = this.value;

                        if (this.checked) {
                            selectedSets.add(setValue);
                        } else {
                            selectedSets.delete(setValue);
                            // Remove any combinations using this set
                            Object.keys(setMarkers).forEach(combinedId => {
                                if (setMarkers[combinedId].setNumber === setValue) {
                                    removeSetPhaseMarker(combinedId);
                                }
                            });
                        }
                        updateTable();
                    });
                });
            }

        const gridToggleBtn = document.getElementById('grid-toggle-btn');
            if (gridToggleBtn) {
                gridToggleBtn.addEventListener('click', toggleGrid);
            }

        // Phase selection - allow multiple phases but create combination when selected
        const phaseContainer = document.getElementById('phase-numbers');
            if (phaseContainer) {
                phaseContainer.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                    checkbox.addEventListener('change', function() {
                        const phaseValue = this.value;

                        if (this.checked) {
                            selectedPhases.add(phaseValue);
                            // Automatically create combination if we have a set selected
                            if (selectedSets.size > 0) {
                                createSetPhaseCombination();
                            }
                        } else {
                            selectedPhases.delete(phaseValue);
                            // Remove any combinations using this phase
                            Object.keys(setMarkers).forEach(combinedId => {
                                if (setMarkers[combinedId].phaseNumber === phaseValue) {
                                    removeSetPhaseMarker(combinedId);
                                }
                            });
                        }
                        updateTable();
                    });
                });
            }

        // Add combination creation button
        const addCombinationBtn = document.createElement('button');
        addCombinationBtn.textContent = 'Create Set:Phase Combination';
        addCombinationBtn.className = 'btn btn-primary btn-sm';
        addCombinationBtn.style.marginTop = '10px';
        addCombinationBtn.addEventListener('click', createSetPhaseCombination);

        // Add clear button
        const clearCombinationsBtn = document.createElement('button');
        clearCombinationsBtn.textContent = 'Clear All Combinations';
        clearCombinationsBtn.className = 'btn btn-secondary btn-sm';
        clearCombinationsBtn.style.marginTop = '10px';
        clearCombinationsBtn.style.marginLeft = '10px';
        clearCombinationsBtn.addEventListener('click', clearAllSetPhaseCombinations);

        // Insert buttons after phase numbers
        const phaseFormGroup = document.querySelector('.form-group:has(#phase-numbers)');
        if (phaseFormGroup) {
            phaseFormGroup.appendChild(addCombinationBtn);
            phaseFormGroup.appendChild(clearCombinationsBtn);
        }

        // Joint selection (keep existing)
        const jointContainer = document.getElementById('joint-labels');
            if (jointContainer) {
                jointContainer.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                    checkbox.addEventListener('change', function() {
                        const jointValue = this.value;

                        if (this.checked) {
                            selectedJoints.add(jointValue);
                            // Add marker if it doesn't exist
                            if (!jointMarkers[jointValue]) {
                                addJointMarker(jointValue);
                            }
                        } else {
                            selectedJoints.delete(jointValue);
                            removeJointMarker(jointValue);
                        }
                        updateTable();
                        syncSelectionsWithSession(); // NEW: Sync with session
                    });
                });
            }



    document.querySelectorAll('.drag-item').forEach(item => {
            item.addEventListener('dragstart', function(e) {
                currentDroppingItem = {
                    type: this.dataset.type,
                    value: this.dataset.value
                };
                e.dataTransfer.setData('text/plain', JSON.stringify(currentDroppingItem));
                e.dataTransfer.effectAllowed = 'copy';
                this.classList.add('dragging');
                renderer.domElement.style.cursor = 'copy';
            });

            // NEW: Add dragend to reset currentDroppingItem if drag is cancelled or finishes elsewhere
            item.addEventListener('dragend', function() {
            currentDroppingItem = null;
            this.classList.remove('dragging');
            renderer.domElement.style.cursor = 'grab';
        });
        
        });
    
    // Set up drop zone on model viewer
        const modelCanvas = document.getElementById('model-canvas');

        modelCanvas.addEventListener('dragover', function(e) {
            e.preventDefault(); // Essential to allow dropping
            e.dataTransfer.dropEffect = 'copy';
        });
    
        modelCanvas.addEventListener('drop', function(e) {
        e.preventDefault();
        
        // Get the dropped data correctly
        let droppedData;
        try {
            droppedData = JSON.parse(e.dataTransfer.getData('text/plain'));
        } catch (error) {
            console.error('Error parsing dropped data:', error);
            return;
        }
        
        if (!droppedData) return;
        
        const itemType = droppedData.type;
        const itemValue = droppedData.value;
        
        // Find the corresponding checkbox and check it
        let checkbox;
        if (itemType === 'joint') {
            checkbox = document.querySelector(`input[name="joint-labels"][value="${itemValue}"]`);
            if (checkbox && !checkbox.checked) {
                checkbox.checked = true;
                const event = new Event('change');
                checkbox.dispatchEvent(event);
            }
        }
        else if (itemType === 'set') {
            checkbox = document.querySelector(`input[name="set-numbers"][value="${itemValue}"]`);
            if (checkbox && !checkbox.checked) {
                checkbox.checked = true;
                const event = new Event('change');
                checkbox.dispatchEvent(event);
            }
        }
        else if (itemType === 'phase') {
            checkbox = document.querySelector(`input[name="phase-numbers"][value="${itemValue}"]`);
            if (checkbox && !checkbox.checked) {
                checkbox.checked = true;
                const event = new Event('change');
                checkbox.dispatchEvent(event);
                
                // If we have sets selected, automatically create combination
                if (selectedSets.size > 0) {
                    createSetPhaseCombination();
                }
            }
        }
        
        currentDroppingItem = null;
        renderer.domElement.style.cursor = 'grab';
    });
    
    // Add responsive behavior
    window.addEventListener('resize', onWindowResize);
});
        
       
</script>
"


