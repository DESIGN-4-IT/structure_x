The dragging works smoothly, but the user still can’t properly set or fix the selected value. 
When a value is selected, it keeps dragging with the mouse cursor continuously. 
After clicking to place it and dragging away, the value still follows the cursor. 
The user needs to zoom the 3D model and reselect the value to assign it. After one click, 
the drag should start, and on the next click, the drag should stop. Check the code and modify it correctly. 
I want only the modified code in the response, with hints about where changes were made and what was added. 
What I need:
Clear hints on where to apply the changes. 
don't return complete code in response
this is complete code 
"<div class="container">
    <h3>OVERHEAD LOAD DESIGN CRITERIA</h3>
    
    <div class="row">
        <!-- Left side - Selection Options (reduced width) -->
        <div class="col-md-4">
            {% if button_type == 'joint_labels' %}
            <!-- Show only joint labels section when joint labels button was clicked -->
            <div class="form-group">
                <label for="joint-labels">Attachment Joint Labels:</label>
                <div class="checkbox-list" id="joint-labels">
                    {% for label in joint_labels %}
                        <label draggable="true" class="drag-item" data-type="joint" data-value="{{ label }}">
                            <input type="checkbox" name="joint-labels" value="{{ label }}"> {{ label }}
                        </label>
                    {% endfor %}
                </div>
            </div>
            {% elif button_type == 'set_phase' %}
            <!-- Show only set/phase sections when set/phase button was clicked -->
            <div class="form-group">
                <label for="set-numbers">Set No.:</label>
                <div class="checkbox-list" id="set-numbers">
                    {% for num in set_numbers %}
                        <label draggable="true" class="drag-item" data-type="set" data-value="{{ num }}">
                            <input type="checkbox" name="set-numbers" value="{{ num }}"> {{ num }}
                        </label>
                    {% endfor %}
                </div>
            </div>
            
            <div class="form-group">
                <label for="phase-numbers">Phase No.:</label>
                <div class="checkbox-list" id="phase-numbers">
                    {% for num in phase_numbers %}
                        <label draggable="true" class="drag-item" data-type="phase" data-value="{{ num }}">
                            <input type="checkbox" name="phase-numbers" value="{{ num }}"> {{ num }}
                        </label>
                    {% endfor %}
                </div>
            </div>
            {% endif %}
        </div>
        
        <!-- Right side - 3D Model Viewer (increased width) -->
        <div class="col-md-8">
            <div class="model-viewer-container">
                <canvas id="model-canvas"></canvas>
                <div id="joint-markers-container"></div>
                <div id="set-markers-container"></div>
                <div id="phase-markers-container"></div>
                <div id="load-displays-container"></div>
            </div>
        </div>
    </div>
    
    <!-- Load Display Table - now placed below and full width -->
    <div id="load-display">
        <h5>Load Values</h5>
        <div class="btn-container">
            <button id="calculate-btn" class="calculation-btn" disabled>
                <span>Calculate Selected Records</span>
            </button>
            <span id="selected-count" class="selected-count">0 selected</span>
        </div>
        <div class="table-container">
            <table class="table table-bordered" id="load-table">
                <thead>
                    <tr>
                        <th>Select</th>
                        {% for column in all_columns %}
                            <th>{{ column }}</th>
                        {% endfor %}
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
    </div>
</div>



<!-- Include Three.js library -->
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>



<script>
    // Load data passed from Django
    const loadData = JSON.parse('{{ load_data_json|escapejs }}');
    
    // Three.js variables
    let scene, camera, renderer, model, controls, raycaster, mouse;
    const jointMarkers = {};
    const selectedJoints = new Set();
    const loadDisplays = {};
    const setMarkers = {};
    const phaseMarkers = {};
    const selectedSets = new Set();
    const selectedPhases = new Set();
    let activeJoint = null;
    const selectedRecords = new Set();
    let allTableData = [];
    const setPhaseCombinations = new Map(); // Track all active combinations
    let combinationCounter = 0; // Counter to make each combination unique
    
    let currentDroppingItem = null; // Stores data of the label being dragged from the sidebar
    let isDragging3DLabel = false; // Flag to indicate if an assigned 3D label is being dragged
    let dragOffset = new THREE.Vector3(); // Offset for dragging 3D labels
    let selected3DLabel = null;
    let dragPlane = new THREE.Plane(); // NEW: A plane for smoother dragging
    let intersectionPoint = new THREE.Vector3();

    // Initialize the 3D model viewer
        // Initialize the 3D model viewer
    function initModelViewer() {
        // Create scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);

        // Create camera
        const canvasContainer = document.querySelector('.model-viewer-container');
        camera = new THREE.PerspectiveCamera(75, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 1000);
        camera.position.set(5, 5, 5);

        // Create renderer
        const canvas = document.getElementById('model-canvas');
        renderer = new THREE.WebGLRenderer({
            canvas,
            antialias: true,
            alpha: true // Allow transparency
        });

        // Set initial size
        updateRendererSize();

        // Add controls
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;

        // Initialize raycaster for part selection
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        // Add lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        // Add a second directional light for better illumination
        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight2.position.set(-1, -1, -1);
        scene.add(directionalLight2);

        // Load GLB model
        const loader = new THREE.GLTFLoader();
        loader.load(
            "{% static 'app1/images/powerTransmissionTower.glb' %}",
            function (gltf) {
                model = gltf.scene;
                scene.add(model);

                // Center the model
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                model.position.sub(center);

                // Auto-rotate
                model.rotation.y = Math.PI / 4;

                // Start animation loop
                animate();
            },
            undefined,
            function (error) {
                console.error('Error loading model:', error);
            }
        );

        // Handle window resize
        window.addEventListener('resize', onWindowResize);

        // NEW: Event Listeners for placing labels on the 3D model
        renderer.domElement.addEventListener('click', onCanvasClick);
        renderer.domElement.addEventListener('mousemove', onCanvasMouseMove); // For draggable assigned labels
        renderer.domElement.addEventListener('mouseup', onCanvasMouseUp); // For draggable assigned labels
    }
    

        // NEW: Handle clicks on the 3D canvas for assigning labels
    function onCanvasClick(event) {
        // Only proceed if a label is being "dropped" from the sidebar
        if (!currentDroppingItem) return;

        event.preventDefault();

        const canvas = renderer.domElement;
        const rect = canvas.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        const intersects = raycaster.intersectObjects(scene.children, true);

        if (intersects.length > 0) {
            const intersection = intersects[0];
            const point = intersection.point; // The 3D point on the model

            const itemType = currentDroppingItem.type;
            const itemValue = currentDroppingItem.value;

            if (itemType === 'joint') {
                addJointMarker(itemValue, point);
            } else if (itemType === 'set' || itemType === 'phase') {
                // For set/phase, we create a combination, so we need both to be selected
                if (selectedSets.size === 0 || selectedPhases.size === 0) {
                    showSelectionRequiredMessage();
                    return;
                }
                const currentSet = Array.from(selectedSets).pop();
                const currentPhase = Array.from(selectedPhases).pop();
                addSetPhaseMarker(currentSet, currentPhase, point);
            }

            // Uncheck the source checkbox after dropping
            const checkbox = document.querySelector(`input[name="${itemType === 'joint' ? 'joint-labels' : (itemType === 'set' ? 'set-numbers' : 'phase-numbers')}"][value="${itemValue}"]`);
            if (checkbox) {
                checkbox.checked = true; // Ensure it's checked when placed on model
                const changeEvent = new Event('change');
                checkbox.dispatchEvent(changeEvent);
            }

            currentDroppingItem = null; // Reset
            renderer.domElement.style.cursor = 'grab'; // Restore default cursor
        }
    }

    // NEW: Handle mouse move for dragging existing labels on the 3D canvas
    function onCanvasMouseMove(event) {
        if (!isDragging3DLabel || !selected3DLabel) return;

        event.preventDefault();

        const canvas = renderer.domElement;
        const rect = canvas.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        // NEW: Intersect with the drag plane instead of the complex model
        const newPointOnPlane = new THREE.Vector3();
        if (raycaster.ray.intersectPlane(dragPlane, newPointOnPlane)) {
            const newPosition = newPointOnPlane.add(dragOffset);

            const value = selected3DLabel.dataset.jointLabel || selected3DLabel.dataset.combinedId;
            const type = selected3DLabel.classList.contains('joint-marker') ? 'joint' : 'set-phase';

            let markerRef;
            if (type === 'joint') markerRef = jointMarkers[value];
            else if (type === 'set-phase') markerRef = setMarkers[value];

            if (markerRef) {
                markerRef.mesh.position.copy(newPosition);
                // Update HTML div position immediately during drag
                updateMarkerPosition(markerRef.mesh, markerRef.div);
                // Update load display if applicable
                if (type === 'joint' && loadDisplays[value]) {
                    updateLoadDisplayPosition(loadDisplays[value].div, newPosition);
                }
            }
        }
    }

    // NEW: Handle mouse up after dragging existing labels
    function onCanvasMouseUp(event) {
        if (!isDragging3DLabel) return; // Only process if a drag was active

        isDragging3DLabel = false;
        selected3DLabel = null;
        controls.enabled = true; // Re-enable orbit controls
    }

    // Setup part selection for the tower model
    function updateRendererSize() {
        const canvasContainer = document.querySelector('.model-viewer-container');
        if (canvasContainer && renderer) {
            const width = canvasContainer.clientWidth;
            const height = canvasContainer.clientHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        }
    }

        // Add a marker for a joint on the 3D model
    function addJointMarker(jointLabel, position = null) { // Added position parameter
        if (jointMarkers[jointLabel]) return;

        const jointLoadData = loadData.find(item => item['Attach. Joint Labels'] === jointLabel);
        if (!jointLoadData) return;

        // Create a marker with no color
        const geometry = new THREE.SphereGeometry(0.02, 16, 16);
        const material = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 }); // Completely transparent sphere
        const sphere = new THREE.Mesh(geometry, material);

        // Use provided position or a default one
        if (position) {
            sphere.position.copy(position);
        } else {
            // Original random placement as fallback
            sphere.position.set(
                (Math.random() - 0.5) * 2,
                Math.random() * 2,
                (Math.random() - 0.5) * 2
            );
        }

        // Add label - simple text only
        const markerDiv = document.createElement('div');
        markerDiv.className = 'value-marker joint-marker';
        markerDiv.textContent = jointLabel;
        markerDiv.style.position = 'absolute';
        markerDiv.style.color = 'black';
        markerDiv.style.padding = '2px 5px';
        markerDiv.style.cursor = 'grab'; // Changed to 'grab' for consistency
        markerDiv.style.pointerEvents = 'auto';
        markerDiv.dataset.jointLabel = jointLabel;
        document.getElementById('joint-markers-container').appendChild(markerDiv);

        // Click handler for the marker
        markerDiv.addEventListener('click', function(e) {
            e.stopPropagation();
            toggleLoadDisplay(jointLabel);
        });

        // NEW: Add mousedown listener for dragging the HTML label
        markerDiv.addEventListener('mousedown', function(e) {
            if (e.button === 0) { // Left mouse button
                e.stopPropagation();
                isDragging3DLabel = true;
                selected3DLabel = markerDiv;
                controls.enabled = false; // Disable orbit controls during label drag

                // NEW: Set up the drag plane
                const markerMesh = jointMarkers[jointLabel].mesh; // Or setMarkers[uniqueId].mesh for set-phase
                dragPlane.setFromNormalAndCoplanarPoint(
                    camera.getWorldDirection(dragPlane.normal).negate(), // Plane faces camera
                    markerMesh.position // Plane passes through the mesh's current position
                );

                // Calculate the offset from the mouse click to the center of the marker
                const canvas = renderer.domElement;
                const rect = canvas.getBoundingClientRect();
                mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                raycaster.ray.intersectPlane(dragPlane, intersectionPoint);
                dragOffset.subVectors(markerMesh.position, intersectionPoint);
            }
        });


        // Store references
        jointMarkers[jointLabel] = {
            mesh: sphere,
            div: markerDiv,
            loadData: jointLoadData,
            isDragging: false, // This flag is for the old HTML-only drag, now we use isDragging3DLabel
            fontSize: 12, // Default font size
            originalScale: 1 // For dynamic scaling
        };

        scene.add(sphere);
        updateMarkerPosition(sphere, markerDiv);

    }


        // Function to add a combined set:phase marker
    function addSetPhaseMarker(setNumber, phaseNumber, position = null) { // Added position parameter
        const baseCombinedId = `${setNumber}:${phaseNumber}`;
        const uniqueId = `${baseCombinedId}_${combinationCounter++}`;

        const geometry = new THREE.SphereGeometry(0.03, 16, 16);
        const material = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 }); // Completely transparent sphere
        const sphere = new THREE.Mesh(geometry, material);

        // Use provided position or a default one
        if (position) {
            sphere.position.copy(position);
        } else {
            // Original random placement as fallback (modified slightly for better initial spread)
            const markerCount = Object.keys(setMarkers).length;
            const gridSize = Math.ceil(Math.sqrt(markerCount + 1));
            const row = Math.floor(markerCount / gridSize);
            const col = markerCount % gridSize;

            sphere.position.set(
                (col - gridSize / 2) * 0.8,
                2 + row * 0.4,
                (row - gridSize / 2) * 0.4
            );
        }

        // Add HTML label - simple text only, no background
        const markerDiv = document.createElement('div');
        markerDiv.className = 'value-marker set-phase-marker';
        markerDiv.textContent = baseCombinedId;
        markerDiv.style.position = 'absolute';
        markerDiv.style.color = 'black';
        markerDiv.style.padding = '2px 5px';
        markerDiv.style.cursor = 'grab'; // Changed to 'grab'
        markerDiv.style.fontWeight = 'bold';
        markerDiv.style.pointerEvents = 'auto';
        markerDiv.dataset.combinedId = uniqueId;
        markerDiv.dataset.baseCombination = baseCombinedId;
        document.getElementById('set-markers-container').appendChild(markerDiv);

        // NEW: Add mousedown listener for dragging the HTML label
        markerDiv.addEventListener('mousedown', function(e) {
            if (e.button === 0) { // Left mouse button
                e.stopPropagation();
                isDragging3DLabel = true;
                selected3DLabel = markerDiv;
                controls.enabled = false; // Disable orbit controls during label drag

                // NEW: Set up the drag plane
                const markerMesh = setMarkers[uniqueId].mesh; // IMPORTANT: Changed from jointMarkers
                dragPlane.setFromNormalAndCoplanarPoint(
                    camera.getWorldDirection(dragPlane.normal).negate(), // Plane faces camera
                    markerMesh.position // Plane passes through the mesh's current position
                );

                // Calculate the offset from the mouse click to the center of the marker
                const canvas = renderer.domElement;
                const rect = canvas.getBoundingClientRect();
                mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                raycaster.ray.intersectPlane(dragPlane, intersectionPoint);
                dragOffset.subVectors(markerMesh.position, intersectionPoint);
            }
        });

        // Store the marker with unique ID
        setMarkers[uniqueId] = {
            mesh: sphere,
            div: markerDiv,
            isDragging: false, // This flag is for the old HTML-only drag, now we use isDragging3DLabel
            setNumber: setNumber,
            phaseNumber: phaseNumber,
            baseCombination: baseCombinedId,
            uniqueId: uniqueId,
            originalScale: 1 // For dynamic scaling
        };

        scene.add(sphere);
        updateMarkerPosition(sphere, markerDiv);
        // makeDraggable(markerDiv, uniqueId, 'set-phase'); // Removed as we're handling 3D drag differently

        // Show success message
        showCombinationCreatedMessage(baseCombinedId);

        return true;
    }

    // Function to show combination created message
    function showCombinationCreatedMessage(combination) {
        let messageDiv = document.getElementById('combination-created-message');
        if (!messageDiv) {
            messageDiv = document.createElement('div');
            messageDiv.id = 'combination-created-message';
            messageDiv.style.position = 'fixed';
            messageDiv.style.top = '20px';
            messageDiv.style.right = '20px';
            messageDiv.style.background = '#e8f5e8';
            messageDiv.style.color = '#2e7d32';
            messageDiv.style.padding = '12px 18px';
            messageDiv.style.border = '2px solid #4caf50';
            messageDiv.style.borderRadius = '6px';
            messageDiv.style.zIndex = '1000';
            messageDiv.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
            messageDiv.style.fontWeight = 'bold';
            document.body.appendChild(messageDiv);
        }
        
        messageDiv.innerHTML = `✅ Created combination: ${combination}`;
        messageDiv.style.display = 'block';
        
        setTimeout(() => {
            messageDiv.style.display = 'none';
        }, 2000);
    }

    // Function to remove a set:phase marker
    function removeSetPhaseMarker(uniqueId) {
        if (!setMarkers[uniqueId]) return;
        
        scene.remove(setMarkers[uniqueId].mesh);
        document.getElementById('set-markers-container').removeChild(setMarkers[uniqueId].div);
        delete setMarkers[uniqueId];
    }

    // Function to create new set:phase combination
    function createSetPhaseCombination() {
        if (selectedSets.size === 0 || selectedPhases.size === 0) {
            showSelectionRequiredMessage();
            return;
        }
        
        // Get the currently selected set and phase
        const currentSet = Array.from(selectedSets).pop();
        const currentPhase = Array.from(selectedPhases).pop();
        
        if (currentSet && currentPhase) {
            // Always create new combination, even if same set:phase exists
            addSetPhaseMarker(currentSet, currentPhase);
            
            // Don't clear phase selection - allow creating multiple of same combination
            updateTable();
        }
    }

    // Function to show selection required message
    function showSelectionRequiredMessage() {
        let messageDiv = document.getElementById('selection-required-message');
        if (!messageDiv) {
            messageDiv = document.createElement('div');
            messageDiv.id = 'selection-required-message';
            messageDiv.style.position = 'fixed';
            messageDiv.style.top = '20px';
            messageDiv.style.right = '20px';
            messageDiv.style.background = '#fff3e0';
            messageDiv.style.color = '#ef6c00';
            messageDiv.style.padding = '12px 18px';
            messageDiv.style.border = '2px solid #ff9800';
            messageDiv.style.borderRadius = '6px';
            messageDiv.style.zIndex = '1000';
            messageDiv.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
            messageDiv.style.fontWeight = 'bold';
            document.body.appendChild(messageDiv);
        }
        
        messageDiv.innerHTML = "⚠️ Please select both a Set and a Phase first";
        messageDiv.style.display = 'block';
        
        setTimeout(() => {
            messageDiv.style.display = 'none';
        }, 3000);
    }

    // Clear all set:phase combinations
    function clearAllSetPhaseCombinations() {
        Object.keys(setMarkers).forEach(uniqueId => {
            removeSetPhaseMarker(uniqueId);
        });
        combinationCounter = 0; // Reset counter
    }

    // Get combinations by base type (for table display)
    function getCombinationsByBaseType() {
        const combinationsByType = {};
        
        Object.values(setMarkers).forEach(marker => {
            const baseCombination = marker.baseCombination;
            if (!combinationsByType[baseCombination]) {
                combinationsByType[baseCombination] = [];
            }
            combinationsByType[baseCombination].push(marker);
        });
        
        return combinationsByType;
    }

    
    // Toggle load display visibility
    function toggleLoadDisplay(jointLabel) {
        if (loadDisplays[jointLabel]) {
            // Hide if already showing
            removeLoadDisplay(jointLabel);
            activeJoint = null;
        } else {
            // Show if hidden
            addLoadDisplay(jointLabel, jointMarkers[jointLabel].mesh.position);
            activeJoint = jointLabel;
            
            // Hide any other active displays
            Object.keys(loadDisplays).forEach(label => {
                if (label !== jointLabel) {
                    removeLoadDisplay(label);
                }
            });
        }
    }
    
    
    
    // Update 3D position from screen coordinates
    function update3DPositionFromScreen(value, type, x, y) {
        let marker;
        if (type === 'joint') marker = jointMarkers[value];
        else if (type === 'set-phase') marker = setMarkers[value];
        else return;
        
        const vector = new THREE.Vector3(
            (x / renderer.domElement.clientWidth) * 2 - 1,
            -(y / renderer.domElement.clientHeight) * 2 + 1,
            0.5
        );
        
        vector.unproject(camera);
        marker.mesh.position.copy(vector);
    }
    
    // Add load display for a joint
    function addLoadDisplay(jointLabel, position) {
        if (loadDisplays[jointLabel]) return; // Already exists

        const jointInfo = jointMarkers[jointLabel];
        if (!jointInfo) return;

        const displayDiv = document.createElement('div');
        displayDiv.className = 'load-display';
        displayDiv.dataset.jointLabel = jointLabel;
        displayDiv.style.position = 'absolute';
        displayDiv.style.pointerEvents = 'auto';

        displayDiv.innerHTML = `
            <div class="load-display-header">
                <span>${jointLabel}</span>
                <span class="close-btn" title="Remove">×</span>
            </div>
            <div class="load-display-content">
                <div>Vert: <span class="editable" data-field="vert">${jointInfo.loadData['Structure Loads Vert. (lbs)'] || '0'}</span> lbs</div>
                <div>Trans: <span class="editable" data-field="trans">${jointInfo.loadData['Structure Loads Trans. (lbs)'] || '0'}</span> lbs</div>
                <div>Long: <span class="editable" data-field="long">${jointInfo.loadData['Structure Loads Long. (lbs)'] || '0'}</span> lbs</div>
            </div>
            <div class="size-controls">
                <div class="size-btn" data-action="increase">+</div>
                <div class="size-btn" data-action="decrease">-</div>
            </div>
        `;

        document.getElementById('load-displays-container').appendChild(displayDiv);

        // Position the display
        updateLoadDisplayPosition(displayDiv, position);

        // Store reference
        loadDisplays[jointLabel] = {
            div: displayDiv,
            position: position
        };

        // Add close button event
        displayDiv.querySelector('.close-btn').addEventListener('click', function(e) {
            e.stopPropagation();
            removeJointMarker(jointLabel);
            removeLoadDisplay(jointLabel);

            // Uncheck the checkbox
            const checkbox = document.querySelector(`input[value="${jointLabel}"]`);
            if (checkbox) {
                checkbox.checked = false;
                selectedJoints.delete(jointLabel);
                updateTable(Array.from(selectedJoints));
            }
        });

        // Add size control events
        displayDiv.querySelector('[data-action="increase"]').addEventListener('click', function(e) {
            e.stopPropagation();
            // This now scales the load display text, not the joint marker itself
            displayDiv.style.fontSize = `${parseFloat(displayDiv.style.fontSize || 12) + 1}px`;
        });

        displayDiv.querySelector('[data-action="decrease"]').addEventListener('click', function(e) {
            e.stopPropagation();
            displayDiv.style.fontSize = `${Math.max(8, parseFloat(displayDiv.style.fontSize || 12) - 1)}px`;
        });

        // Add editable fields (same as before)
        displayDiv.querySelectorAll('.editable').forEach(el => {
            el.addEventListener('click', function(e) {
                e.stopPropagation();
                const field = this.dataset.field;
                const currentValue = this.textContent;
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'value-edit';
                input.value = currentValue;

                this.textContent = '';
                this.appendChild(input);
                input.focus();

                input.addEventListener('blur', function() {
                    const newValue = parseFloat(this.value) || 0;
                    const parent = this.parentElement;
                    parent.textContent = newValue;
                    parent.classList.add('editable');

                    // Update the data
                    const jointLabel = parent.closest('.load-display').dataset.jointLabel;
                    const jointInfo = jointMarkers[jointLabel];
                    if (jointInfo) {
                        if (field === 'vert') {
                            jointInfo.loadData['Structure Loads Vert. (lbs)'] = newValue;
                        } else if (field === 'trans') {
                            jointInfo.loadData['Structure Loads Trans. (lbs)'] = newValue;
                        } else if (field === 'long') {
                            jointInfo.loadData['Structure Loads Long. (lbs)'] = newValue;
                        }
                    }

                    // Update the table
                    updateTable(Array.from(selectedJoints));
                });

                input.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        this.blur();
                    }
                });
            });
        });

        // Make the display draggable (using the simplified 2D draggable)
        makeDraggable(displayDiv, jointLabel);
    }
    
    // Make load display draggable
    function makeDraggable(element, jointLabel) { // Simplified signature
        let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;

        element.onmousedown = dragMouseDown;

        function dragMouseDown(e) {
            e.preventDefault();
            e.stopPropagation();

            // Get the mouse cursor position at startup
            pos3 = e.clientX;
            pos4 = e.clientY;

            document.onmouseup = closeDragElement;
            document.onmousemove = elementDrag;
        }

        function elementDrag(e) {
            e.preventDefault();
            e.stopPropagation();

            // Calculate the new cursor position
            pos1 = pos3 - e.clientX;
            pos2 = pos4 - e.clientY;
            pos3 = e.clientX;
            pos4 = e.clientY;

            // Set the element's new position
            element.style.top = (element.offsetTop - pos2) + "px";
            element.style.left = (element.offsetLeft - pos1) + "px";

            // NO 3D UPDATE HERE: The load display is offset from the joint's 3D position
            // Its movement is purely 2D screen space.
        }

        function closeDragElement() {
            document.onmouseup = null;
            document.onmousemove = null;
        }
    }
    
    // Convert screen coordinates to 3D position
    function getPositionFromScreen(x, y) {
        const vector = new THREE.Vector3(
            (x / renderer.domElement.clientWidth) * 2 - 1,
            -(y / renderer.domElement.clientHeight) * 2 + 1,
            0.5
        );
        
        vector.unproject(camera);
        return vector;
    }
    
    // Remove load display
    function removeLoadDisplay(jointLabel) {
        if (!loadDisplays[jointLabel]) return;
        
        document.getElementById('load-displays-container').removeChild(loadDisplays[jointLabel].div);
        delete loadDisplays[jointLabel];
    }
    
    // Update HTML marker position based on 3D position
    function updateMarkerPosition(mesh, div) {
        // Get the marker reference (either joint or set-phase)
        const isJoint = div.classList.contains('joint-marker');
        const markerRef = isJoint ? jointMarkers[div.dataset.jointLabel] : setMarkers[div.dataset.combinedId];
        if (!markerRef) return;

        const vector = mesh.position.clone();
        vector.project(camera);

        const x = (vector.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
        const y = (-(vector.y * 0.5) + 0.5) * renderer.domElement.clientHeight;

        div.style.left = `${x}px`;
        div.style.top = `${y}px`;

        // NEW: Implement scaling based on distance from camera
        const distance = camera.position.distanceTo(mesh.position);
        // This factor needs tuning based on your scene scale and desired visual
        // A smaller factor means labels scale less dramatically with distance
        const scaleFactor = 100 / distance; // Inverse distance for scaling
        const baseFontSize = markerRef.fontSize || 12; // Use stored fontSize or default
        div.style.fontSize = `${baseFontSize * scaleFactor}px`;

        // Optional: adjust opacity based on distance or if it's behind the camera
        // if (vector.z > 1) { // Behind the camera
        //     div.style.display = 'none';
        // } else {
        //     div.style.display = 'block';
        // }
    }

    // Update load display position based on 3D position
    function updateLoadDisplayPosition(div, position) {
        const vector = position.clone();
        vector.project(camera);
        
        const x = (vector.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
        const y = (-(vector.y * 0.5) + 0.5) * renderer.domElement.clientHeight;
        
        div.style.left = `${x + 20}px`; // Offset slightly from the marker
        div.style.top = `${y}px`;
    }

    
    // Remove a joint marker
    function removeJointMarker(jointLabel) {
        if (!jointMarkers[jointLabel]) return;
        
        scene.remove(jointMarkers[jointLabel].mesh);
        document.getElementById('joint-markers-container').removeChild(jointMarkers[jointLabel].div);
        delete jointMarkers[jointLabel];
    }
    
    function animate() {
        requestAnimationFrame(animate);
        controls.update();

        // Update marker positions and scale
        for (const jointLabel in jointMarkers) {
            updateMarkerPosition(jointMarkers[jointLabel].mesh, jointMarkers[jointLabel].div);

            // Update load display positions if they exist
            if (loadDisplays[jointLabel]) {
                updateLoadDisplayPosition(
                    loadDisplays[jointLabel].div,
                    jointMarkers[jointLabel].mesh.position
                );
            }
        }

        // Update set-phase markers positions and scale
        for (const combinedId in setMarkers) {
            updateMarkerPosition(setMarkers[combinedId].mesh, setMarkers[combinedId].div);
        }

        renderer.render(scene, camera);
    }
    
        function onWindowResize() {
        updateRendererSize();

        // Update all marker positions and scale
        for (const label in jointMarkers) {
            updateMarkerPosition(jointMarkers[label].mesh, jointMarkers[label].div);
        }
        for (const combinedId in setMarkers) {
            updateMarkerPosition(setMarkers[combinedId].mesh, setMarkers[combinedId].div);
        }

        // Update load display positions
        for (const label in loadDisplays) {
            // Note: Load displays are 2D-draggable, but their *reference* point for initial placement
            // and attachment remains the joint marker's 3D position.
            updateLoadDisplayPosition(loadDisplays[label].div, jointMarkers[label].mesh.position);
        }
    }
    
    // Clear table
    function clearTable() {
        document.getElementById('load-table').getElementsByTagName('tbody')[0].innerHTML = '';
    }


    function handleRecordSelection(e) {
    const index = parseInt(e.target.dataset.index);
    const record = allTableData[index];
    
    if (e.target.checked) {
        selectedRecords.add(record);
    } else {
        selectedRecords.delete(record);
    }
    
    updateSelectedCount();
}

function updateSelectedCount() {
    const selectedCount = document.getElementById('selected-count');
    const calculateBtn = document.getElementById('calculate-btn');
    
    selectedCount.textContent = `${selectedRecords.size} selected`;
    calculateBtn.disabled = selectedRecords.size === 0;
}

// Add event listener for calculate button
// Update the calculate button event listener
document.getElementById('calculate-btn').addEventListener('click', function() {
    if (selectedRecords.size > 0) {
        // Prepare data for calculation - convert Set to Array
        const calculationData = Array.from(selectedRecords);
        
        // Create a form to submit the data
        const form = document.createElement('form');
        form.method = 'GET';
        form.action = '/calculation/';
        form.target = '_blank';
        
        const input = document.createElement('input');
        input.type = 'hidden';
        input.name = 'calculation_data';
        input.value = JSON.stringify(calculationData);
        form.appendChild(input);
        
        document.body.appendChild(form);
        form.submit();
        document.body.removeChild(form);
    }
});
    
    // Update table with selected labels
function updateTable() {
    clearTable();
    const tbody = document.getElementById('load-table').getElementsByTagName('tbody')[0];
    
    // Get all column names from the table headers
    const columns = Array.from(document.querySelectorAll('#load-table thead th'))
        .map(th => th.textContent.trim())
        .filter(col => col !== 'Select'); // Exclude the Select column
    
    // Store all table data for later reference
    allTableData = [];
    
    // Add new rows from the filtered data
    loadData.forEach((item, index) => {
        const row = tbody.insertRow();
        allTableData.push(item); // Store reference to this data
        
        // Add checkbox cell
        const checkboxCell = row.insertCell();
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'record-checkbox';
        checkbox.dataset.index = index;
        checkbox.addEventListener('change', handleRecordSelection);
        checkboxCell.appendChild(checkbox);
        
        // Add cells for each column
        columns.forEach(column => {
            const cell = row.insertCell();
            cell.textContent = item[column] !== undefined ? item[column] : '';
        });
    });
    
    // Update selected count
    updateSelectedCount();

    // Only add joints if we're in joint labels mode and joints are selected
    {% if button_type == 'joint_labels' %}
    Array.from(selectedJoints).forEach(label => {
        const loadInfo = loadData.find(item => item['Attach. Joint Labels'] === label);
        if (loadInfo) {
            const newRow = tbody.insertRow();
            
            // Add cells for each column
            columns.forEach(column => {
                const cell = newRow.insertCell();
                cell.textContent = loadInfo[column] !== undefined ? loadInfo[column] : '';
            });
        }
    });
    {% endif %}
    
    // Only add sets if we're in set/phase mode and sets are selected
    {% if button_type == 'set_phase' %}
    Array.from(selectedSets).forEach(setNum => {
        // Find all rows with this set number
        const setData = loadData.filter(item => item['Set No.'] == setNum);
        
        if (setData.length > 0) {
            // Add a header row for the set
            const headerRow = tbody.insertRow();
            const headerCell = headerRow.insertCell();
            headerCell.colSpan = columns.length;
            headerCell.textContent = `Set ${setNum}`;
            headerCell.style.textAlign = 'center';
            headerCell.style.backgroundColor = '#e6f2ff';
            headerCell.style.fontWeight = 'bold';
            
            // Add all data rows for this set
            setData.forEach(item => {
                const row = tbody.insertRow();
                columns.forEach(column => {
                    const cell = row.insertCell();
                    cell.textContent = item[column] !== undefined ? item[column] : '';
                });
            });
        }
    });
    
    // Only add phases if we're in set/phase mode and phases are selected
    Array.from(selectedPhases).forEach(phaseNum => {
        // Find all rows with this phase number
        const phaseData = loadData.filter(item => item['Phase No.'] == phaseNum);
        
        if (phaseData.length > 0) {
            // Add a header row for the phase
            const headerRow = tbody.insertRow();
            const headerCell = headerRow.insertCell();
            headerCell.colSpan = columns.length;
            headerCell.textContent = `Phase ${phaseNum}`;
            headerCell.style.textAlign = 'center';
            headerCell.style.backgroundColor = '#e6ffe6';
            headerCell.style.fontWeight = 'bold';
            
            // Add all data rows for this phase
            phaseData.forEach(item => {
                const row = tbody.insertRow();
                columns.forEach(column => {
                    const cell = row.insertCell();
                    cell.textContent = item[column] !== undefined ? item[column] : '';
                });
            });
        }
    });
    {% endif %}
}

    
    // Set up event listeners
    function addMarker(itemType, itemValue) {
        if (itemType === 'joint') {
            if (jointMarkers[itemValue]) return;
            addJointMarker(itemValue);
        } 
        else if (itemType === 'set') {
            if (setMarkers[itemValue]) return;
            addSetMarker(itemValue);
        }
        else if (itemType === 'phase') {
            if (phaseMarkers[itemValue]) return;
            addPhaseMarker(itemValue);
        }
    }

    

    // Set up event listeners
    document.addEventListener('DOMContentLoaded', function() {
        initModelViewer();
        updateTable();

        // Set selection - allow multiple sets
        const setContainer = document.getElementById('set-numbers');
        if (setContainer) {
            setContainer.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    const setValue = this.value;

                    if (this.checked) {
                        selectedSets.add(setValue);
                    } else {
                        selectedSets.delete(setValue);
                        // Remove any combinations using this set
                        Object.keys(setMarkers).forEach(combinedId => {
                            if (combinedId.startsWith(setValue + ':')) {
                                removeSetPhaseMarker(combinedId);
                            }
                        });
                    }

                    updateTable();
                });
            });
        }

        // Phase selection - allow multiple phases but create combination when selected
        const phaseContainer = document.getElementById('phase-numbers');
        if (phaseContainer) {
            phaseContainer.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    const phaseValue = this.value;

                    if (this.checked) {
                        selectedPhases.add(phaseValue);

                        // Automatically create combination if we have a set selected
                        if (selectedSets.size > 0) {
                            createSetPhaseCombination();
                        }
                    } else {
                        selectedPhases.delete(phaseValue);
                        // Remove any combinations using this phase
                        Object.keys(setMarkers).forEach(combinedId => {
                            if (combinedId.endsWith(':' + phaseValue)) {
                                removeSetPhaseMarker(combinedId);
                            }
                        });
                    }

                    updateTable();
                });
            });
        }

        // Add combination creation button
        const addCombinationBtn = document.createElement('button');
        addCombinationBtn.textContent = 'Create Set:Phase Combination';
        addCombinationBtn.className = 'btn btn-primary btn-sm';
        addCombinationBtn.style.marginTop = '10px';
        addCombinationBtn.addEventListener('click', createSetPhaseCombination);

        // Add clear button
        const clearCombinationsBtn = document.createElement('button');
        clearCombinationsBtn.textContent = 'Clear All Combinations';
        clearCombinationsBtn.className = 'btn btn-secondary btn-sm';
        clearCombinationsBtn.style.marginTop = '10px';
        clearCombinationsBtn.style.marginLeft = '10px';
        clearCombinationsBtn.addEventListener('click', clearAllSetPhaseCombinations);

        // Insert buttons after phase numbers
        const phaseFormGroup = document.querySelector('.form-group:has(#phase-numbers)');
        if (phaseFormGroup) {
            phaseFormGroup.appendChild(addCombinationBtn);
            phaseFormGroup.appendChild(clearCombinationsBtn);
        }

        // Joint selection (keep existing)
        const jointContainer = document.getElementById('joint-labels');
        if (jointContainer) {
            jointContainer.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    const jointValue = this.value;

                    if (this.checked) {
                        selectedJoints.add(jointValue);
                        // Only add marker if it doesn't exist. Position will be random if not dropped.
                        if (!jointMarkers[jointValue]) {
                            addJointMarker(jointValue);
                        }
                    } else {
                        selectedJoints.delete(jointValue);
                        removeJointMarker(jointValue);
                    }
                    updateTable();
                });
            });
        }

   document.querySelectorAll('.drag-item').forEach(item => {
            item.addEventListener('dragstart', function(e) {
                currentDroppingItem = {
                    type: this.dataset.type,
                    value: this.dataset.value
                };
                e.dataTransfer.setData('text/plain', JSON.stringify(currentDroppingItem)); // Required for Firefox
                e.dataTransfer.effectAllowed = 'copy';
                renderer.domElement.style.cursor = 'copy'; // Change cursor when dragging over canvas
            });

            // NEW: Add dragend to reset currentDroppingItem if drag is cancelled or finishes elsewhere
            item.addEventListener('dragend', function() {
                currentDroppingItem = null;
                renderer.domElement.style.cursor = 'grab'; // Reset cursor
            });
        });
    
    // Set up drop zone on model viewer
        const modelCanvas = document.getElementById('model-canvas');

        modelCanvas.addEventListener('dragover', function(e) {
            e.preventDefault(); // Essential to allow dropping
            e.dataTransfer.dropEffect = 'copy';
        });
    
    modelCanvas.addEventListener('drop', function(e) {
        e.preventDefault();
        const itemType = e.dataTransfer.getData('type');
        const itemValue = e.dataTransfer.getData('value');
        
        // Find the corresponding checkbox and check it
        let checkbox;
        if (itemType === 'joint') {
            checkbox = document.querySelector(`input[name="joint-labels"][value="${itemValue}"]`);
            if (checkbox && !checkbox.checked) {
                checkbox.checked = true;
                const event = new Event('change');
                checkbox.dispatchEvent(event);
            }
        }
        else if (itemType === 'set') {
            checkbox = document.querySelector(`input[name="set-numbers"][value="${itemValue}"]`);
            if (checkbox && !checkbox.checked) {
                checkbox.checked = true;
                const event = new Event('change');
                checkbox.dispatchEvent(event);
            }
        }
        else if (itemType === 'phase') {
            checkbox = document.querySelector(`input[name="phase-numbers"][value="${itemValue}"]`);
            if (checkbox && !checkbox.checked) {
                checkbox.checked = true;
                const event = new Event('change');
                checkbox.dispatchEvent(event);
            }
        }
    });
    
    // Add responsive behavior
    window.addEventListener('resize', onWindowResize);
});
        
       
</script>
"